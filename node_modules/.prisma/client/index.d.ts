
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model FoodKind
 * 
 */
export type FoodKind = $Result.DefaultSelection<Prisma.$FoodKindPayload>
/**
 * Model MemberFavoriteFoodKind
 * 
 */
export type MemberFavoriteFoodKind = $Result.DefaultSelection<Prisma.$MemberFavoriteFoodKindPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Restaurant
 * 
 */
export type Restaurant = $Result.DefaultSelection<Prisma.$RestaurantPayload>
/**
 * Model Mission
 * 
 */
export type Mission = $Result.DefaultSelection<Prisma.$MissionPayload>
/**
 * Model MemberMission
 * 
 */
export type MemberMission = $Result.DefaultSelection<Prisma.$MemberMissionPayload>
/**
 * Model FoodKindRestaurant
 * 
 */
export type FoodKindRestaurant = $Result.DefaultSelection<Prisma.$FoodKindRestaurantPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Reply
 * 
 */
export type Reply = $Result.DefaultSelection<Prisma.$ReplyPayload>
/**
 * Model Inquiry
 * 
 */
export type Inquiry = $Result.DefaultSelection<Prisma.$InquiryPayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model Alarm
 * 
 */
export type Alarm = $Result.DefaultSelection<Prisma.$AlarmPayload>
/**
 * Model AlarmNewMission
 * 
 */
export type AlarmNewMission = $Result.DefaultSelection<Prisma.$AlarmNewMissionPayload>
/**
 * Model AlarmReviewRequest
 * 
 */
export type AlarmReviewRequest = $Result.DefaultSelection<Prisma.$AlarmReviewRequestPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Members
 * const members = await prisma.member.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Members
   * const members = await prisma.member.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs>;

  /**
   * `prisma.foodKind`: Exposes CRUD operations for the **FoodKind** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodKinds
    * const foodKinds = await prisma.foodKind.findMany()
    * ```
    */
  get foodKind(): Prisma.FoodKindDelegate<ExtArgs>;

  /**
   * `prisma.memberFavoriteFoodKind`: Exposes CRUD operations for the **MemberFavoriteFoodKind** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberFavoriteFoodKinds
    * const memberFavoriteFoodKinds = await prisma.memberFavoriteFoodKind.findMany()
    * ```
    */
  get memberFavoriteFoodKind(): Prisma.MemberFavoriteFoodKindDelegate<ExtArgs>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs>;

  /**
   * `prisma.restaurant`: Exposes CRUD operations for the **Restaurant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurants
    * const restaurants = await prisma.restaurant.findMany()
    * ```
    */
  get restaurant(): Prisma.RestaurantDelegate<ExtArgs>;

  /**
   * `prisma.mission`: Exposes CRUD operations for the **Mission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Missions
    * const missions = await prisma.mission.findMany()
    * ```
    */
  get mission(): Prisma.MissionDelegate<ExtArgs>;

  /**
   * `prisma.memberMission`: Exposes CRUD operations for the **MemberMission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberMissions
    * const memberMissions = await prisma.memberMission.findMany()
    * ```
    */
  get memberMission(): Prisma.MemberMissionDelegate<ExtArgs>;

  /**
   * `prisma.foodKindRestaurant`: Exposes CRUD operations for the **FoodKindRestaurant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodKindRestaurants
    * const foodKindRestaurants = await prisma.foodKindRestaurant.findMany()
    * ```
    */
  get foodKindRestaurant(): Prisma.FoodKindRestaurantDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.reply`: Exposes CRUD operations for the **Reply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Replies
    * const replies = await prisma.reply.findMany()
    * ```
    */
  get reply(): Prisma.ReplyDelegate<ExtArgs>;

  /**
   * `prisma.inquiry`: Exposes CRUD operations for the **Inquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inquiries
    * const inquiries = await prisma.inquiry.findMany()
    * ```
    */
  get inquiry(): Prisma.InquiryDelegate<ExtArgs>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs>;

  /**
   * `prisma.alarm`: Exposes CRUD operations for the **Alarm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alarms
    * const alarms = await prisma.alarm.findMany()
    * ```
    */
  get alarm(): Prisma.AlarmDelegate<ExtArgs>;

  /**
   * `prisma.alarmNewMission`: Exposes CRUD operations for the **AlarmNewMission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlarmNewMissions
    * const alarmNewMissions = await prisma.alarmNewMission.findMany()
    * ```
    */
  get alarmNewMission(): Prisma.AlarmNewMissionDelegate<ExtArgs>;

  /**
   * `prisma.alarmReviewRequest`: Exposes CRUD operations for the **AlarmReviewRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlarmReviewRequests
    * const alarmReviewRequests = await prisma.alarmReviewRequest.findMany()
    * ```
    */
  get alarmReviewRequest(): Prisma.AlarmReviewRequestDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Member: 'Member',
    FoodKind: 'FoodKind',
    MemberFavoriteFoodKind: 'MemberFavoriteFoodKind',
    Region: 'Region',
    Restaurant: 'Restaurant',
    Mission: 'Mission',
    MemberMission: 'MemberMission',
    FoodKindRestaurant: 'FoodKindRestaurant',
    Review: 'Review',
    Reply: 'Reply',
    Inquiry: 'Inquiry',
    Image: 'Image',
    Alarm: 'Alarm',
    AlarmNewMission: 'AlarmNewMission',
    AlarmReviewRequest: 'AlarmReviewRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "member" | "foodKind" | "memberFavoriteFoodKind" | "region" | "restaurant" | "mission" | "memberMission" | "foodKindRestaurant" | "review" | "reply" | "inquiry" | "image" | "alarm" | "alarmNewMission" | "alarmReviewRequest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      FoodKind: {
        payload: Prisma.$FoodKindPayload<ExtArgs>
        fields: Prisma.FoodKindFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodKindFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodKindFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindPayload>
          }
          findFirst: {
            args: Prisma.FoodKindFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodKindFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindPayload>
          }
          findMany: {
            args: Prisma.FoodKindFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindPayload>[]
          }
          create: {
            args: Prisma.FoodKindCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindPayload>
          }
          createMany: {
            args: Prisma.FoodKindCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoodKindDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindPayload>
          }
          update: {
            args: Prisma.FoodKindUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindPayload>
          }
          deleteMany: {
            args: Prisma.FoodKindDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodKindUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoodKindUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindPayload>
          }
          aggregate: {
            args: Prisma.FoodKindAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodKind>
          }
          groupBy: {
            args: Prisma.FoodKindGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodKindGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodKindCountArgs<ExtArgs>
            result: $Utils.Optional<FoodKindCountAggregateOutputType> | number
          }
        }
      }
      MemberFavoriteFoodKind: {
        payload: Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>
        fields: Prisma.MemberFavoriteFoodKindFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFavoriteFoodKindFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFavoriteFoodKindPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFavoriteFoodKindFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFavoriteFoodKindPayload>
          }
          findFirst: {
            args: Prisma.MemberFavoriteFoodKindFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFavoriteFoodKindPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFavoriteFoodKindFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFavoriteFoodKindPayload>
          }
          findMany: {
            args: Prisma.MemberFavoriteFoodKindFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFavoriteFoodKindPayload>[]
          }
          create: {
            args: Prisma.MemberFavoriteFoodKindCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFavoriteFoodKindPayload>
          }
          createMany: {
            args: Prisma.MemberFavoriteFoodKindCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MemberFavoriteFoodKindDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFavoriteFoodKindPayload>
          }
          update: {
            args: Prisma.MemberFavoriteFoodKindUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFavoriteFoodKindPayload>
          }
          deleteMany: {
            args: Prisma.MemberFavoriteFoodKindDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberFavoriteFoodKindUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MemberFavoriteFoodKindUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberFavoriteFoodKindPayload>
          }
          aggregate: {
            args: Prisma.MemberFavoriteFoodKindAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberFavoriteFoodKind>
          }
          groupBy: {
            args: Prisma.MemberFavoriteFoodKindGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberFavoriteFoodKindGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberFavoriteFoodKindCountArgs<ExtArgs>
            result: $Utils.Optional<MemberFavoriteFoodKindCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Restaurant: {
        payload: Prisma.$RestaurantPayload<ExtArgs>
        fields: Prisma.RestaurantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findFirst: {
            args: Prisma.RestaurantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findMany: {
            args: Prisma.RestaurantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          create: {
            args: Prisma.RestaurantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          createMany: {
            args: Prisma.RestaurantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RestaurantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          update: {
            args: Prisma.RestaurantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RestaurantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          aggregate: {
            args: Prisma.RestaurantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurant>
          }
          groupBy: {
            args: Prisma.RestaurantGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantCountAggregateOutputType> | number
          }
        }
      }
      Mission: {
        payload: Prisma.$MissionPayload<ExtArgs>
        fields: Prisma.MissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findFirst: {
            args: Prisma.MissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findMany: {
            args: Prisma.MissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>[]
          }
          create: {
            args: Prisma.MissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          createMany: {
            args: Prisma.MissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          update: {
            args: Prisma.MissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          deleteMany: {
            args: Prisma.MissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          aggregate: {
            args: Prisma.MissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMission>
          }
          groupBy: {
            args: Prisma.MissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissionCountArgs<ExtArgs>
            result: $Utils.Optional<MissionCountAggregateOutputType> | number
          }
        }
      }
      MemberMission: {
        payload: Prisma.$MemberMissionPayload<ExtArgs>
        fields: Prisma.MemberMissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberMissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberMissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberMissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberMissionPayload>
          }
          findFirst: {
            args: Prisma.MemberMissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberMissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberMissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberMissionPayload>
          }
          findMany: {
            args: Prisma.MemberMissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberMissionPayload>[]
          }
          create: {
            args: Prisma.MemberMissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberMissionPayload>
          }
          createMany: {
            args: Prisma.MemberMissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MemberMissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberMissionPayload>
          }
          update: {
            args: Prisma.MemberMissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberMissionPayload>
          }
          deleteMany: {
            args: Prisma.MemberMissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberMissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MemberMissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberMissionPayload>
          }
          aggregate: {
            args: Prisma.MemberMissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMemberMission>
          }
          groupBy: {
            args: Prisma.MemberMissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberMissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberMissionCountArgs<ExtArgs>
            result: $Utils.Optional<MemberMissionCountAggregateOutputType> | number
          }
        }
      }
      FoodKindRestaurant: {
        payload: Prisma.$FoodKindRestaurantPayload<ExtArgs>
        fields: Prisma.FoodKindRestaurantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodKindRestaurantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindRestaurantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodKindRestaurantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindRestaurantPayload>
          }
          findFirst: {
            args: Prisma.FoodKindRestaurantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindRestaurantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodKindRestaurantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindRestaurantPayload>
          }
          findMany: {
            args: Prisma.FoodKindRestaurantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindRestaurantPayload>[]
          }
          create: {
            args: Prisma.FoodKindRestaurantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindRestaurantPayload>
          }
          createMany: {
            args: Prisma.FoodKindRestaurantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoodKindRestaurantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindRestaurantPayload>
          }
          update: {
            args: Prisma.FoodKindRestaurantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindRestaurantPayload>
          }
          deleteMany: {
            args: Prisma.FoodKindRestaurantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodKindRestaurantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoodKindRestaurantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodKindRestaurantPayload>
          }
          aggregate: {
            args: Prisma.FoodKindRestaurantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodKindRestaurant>
          }
          groupBy: {
            args: Prisma.FoodKindRestaurantGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodKindRestaurantGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodKindRestaurantCountArgs<ExtArgs>
            result: $Utils.Optional<FoodKindRestaurantCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Reply: {
        payload: Prisma.$ReplyPayload<ExtArgs>
        fields: Prisma.ReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          findFirst: {
            args: Prisma.ReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          findMany: {
            args: Prisma.ReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>[]
          }
          create: {
            args: Prisma.ReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          createMany: {
            args: Prisma.ReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          update: {
            args: Prisma.ReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          deleteMany: {
            args: Prisma.ReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          aggregate: {
            args: Prisma.ReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReply>
          }
          groupBy: {
            args: Prisma.ReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReplyCountArgs<ExtArgs>
            result: $Utils.Optional<ReplyCountAggregateOutputType> | number
          }
        }
      }
      Inquiry: {
        payload: Prisma.$InquiryPayload<ExtArgs>
        fields: Prisma.InquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findFirst: {
            args: Prisma.InquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findMany: {
            args: Prisma.InquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          create: {
            args: Prisma.InquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          createMany: {
            args: Prisma.InquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          update: {
            args: Prisma.InquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          deleteMany: {
            args: Prisma.InquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          aggregate: {
            args: Prisma.InquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiry>
          }
          groupBy: {
            args: Prisma.InquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      Alarm: {
        payload: Prisma.$AlarmPayload<ExtArgs>
        fields: Prisma.AlarmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlarmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlarmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          findFirst: {
            args: Prisma.AlarmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlarmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          findMany: {
            args: Prisma.AlarmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>[]
          }
          create: {
            args: Prisma.AlarmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          createMany: {
            args: Prisma.AlarmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AlarmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          update: {
            args: Prisma.AlarmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          deleteMany: {
            args: Prisma.AlarmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlarmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlarmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          aggregate: {
            args: Prisma.AlarmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlarm>
          }
          groupBy: {
            args: Prisma.AlarmGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlarmGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlarmCountArgs<ExtArgs>
            result: $Utils.Optional<AlarmCountAggregateOutputType> | number
          }
        }
      }
      AlarmNewMission: {
        payload: Prisma.$AlarmNewMissionPayload<ExtArgs>
        fields: Prisma.AlarmNewMissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlarmNewMissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmNewMissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlarmNewMissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmNewMissionPayload>
          }
          findFirst: {
            args: Prisma.AlarmNewMissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmNewMissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlarmNewMissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmNewMissionPayload>
          }
          findMany: {
            args: Prisma.AlarmNewMissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmNewMissionPayload>[]
          }
          create: {
            args: Prisma.AlarmNewMissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmNewMissionPayload>
          }
          createMany: {
            args: Prisma.AlarmNewMissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AlarmNewMissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmNewMissionPayload>
          }
          update: {
            args: Prisma.AlarmNewMissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmNewMissionPayload>
          }
          deleteMany: {
            args: Prisma.AlarmNewMissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlarmNewMissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlarmNewMissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmNewMissionPayload>
          }
          aggregate: {
            args: Prisma.AlarmNewMissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlarmNewMission>
          }
          groupBy: {
            args: Prisma.AlarmNewMissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlarmNewMissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlarmNewMissionCountArgs<ExtArgs>
            result: $Utils.Optional<AlarmNewMissionCountAggregateOutputType> | number
          }
        }
      }
      AlarmReviewRequest: {
        payload: Prisma.$AlarmReviewRequestPayload<ExtArgs>
        fields: Prisma.AlarmReviewRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlarmReviewRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmReviewRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlarmReviewRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmReviewRequestPayload>
          }
          findFirst: {
            args: Prisma.AlarmReviewRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmReviewRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlarmReviewRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmReviewRequestPayload>
          }
          findMany: {
            args: Prisma.AlarmReviewRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmReviewRequestPayload>[]
          }
          create: {
            args: Prisma.AlarmReviewRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmReviewRequestPayload>
          }
          createMany: {
            args: Prisma.AlarmReviewRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AlarmReviewRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmReviewRequestPayload>
          }
          update: {
            args: Prisma.AlarmReviewRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmReviewRequestPayload>
          }
          deleteMany: {
            args: Prisma.AlarmReviewRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlarmReviewRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlarmReviewRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmReviewRequestPayload>
          }
          aggregate: {
            args: Prisma.AlarmReviewRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlarmReviewRequest>
          }
          groupBy: {
            args: Prisma.AlarmReviewRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlarmReviewRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlarmReviewRequestCountArgs<ExtArgs>
            result: $Utils.Optional<AlarmReviewRequestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    memberfavoriteFoodKinds: number
    restaurants: number
    memberMissions: number
    reviews: number
    reply: number
    inquiries: number
    alarms: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberfavoriteFoodKinds?: boolean | MemberCountOutputTypeCountMemberfavoriteFoodKindsArgs
    restaurants?: boolean | MemberCountOutputTypeCountRestaurantsArgs
    memberMissions?: boolean | MemberCountOutputTypeCountMemberMissionsArgs
    reviews?: boolean | MemberCountOutputTypeCountReviewsArgs
    reply?: boolean | MemberCountOutputTypeCountReplyArgs
    inquiries?: boolean | MemberCountOutputTypeCountInquiriesArgs
    alarms?: boolean | MemberCountOutputTypeCountAlarmsArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMemberfavoriteFoodKindsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberFavoriteFoodKindWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountRestaurantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMemberMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberMissionWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountAlarmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlarmWhereInput
  }


  /**
   * Count Type FoodKindCountOutputType
   */

  export type FoodKindCountOutputType = {
    memberfavoriteFoodKinds: number
    foodKindRestaurants: number
  }

  export type FoodKindCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberfavoriteFoodKinds?: boolean | FoodKindCountOutputTypeCountMemberfavoriteFoodKindsArgs
    foodKindRestaurants?: boolean | FoodKindCountOutputTypeCountFoodKindRestaurantsArgs
  }

  // Custom InputTypes
  /**
   * FoodKindCountOutputType without action
   */
  export type FoodKindCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindCountOutputType
     */
    select?: FoodKindCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodKindCountOutputType without action
   */
  export type FoodKindCountOutputTypeCountMemberfavoriteFoodKindsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberFavoriteFoodKindWhereInput
  }

  /**
   * FoodKindCountOutputType without action
   */
  export type FoodKindCountOutputTypeCountFoodKindRestaurantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodKindRestaurantWhereInput
  }


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    restaurant: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RegionCountOutputTypeCountRestaurantArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountRestaurantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWhereInput
  }


  /**
   * Count Type RestaurantCountOutputType
   */

  export type RestaurantCountOutputType = {
    missions: number
    foodKindRestaurants: number
    reviews: number
    images: number
  }

  export type RestaurantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    missions?: boolean | RestaurantCountOutputTypeCountMissionsArgs
    foodKindRestaurants?: boolean | RestaurantCountOutputTypeCountFoodKindRestaurantsArgs
    reviews?: boolean | RestaurantCountOutputTypeCountReviewsArgs
    images?: boolean | RestaurantCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCountOutputType
     */
    select?: RestaurantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountFoodKindRestaurantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodKindRestaurantWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }


  /**
   * Count Type MissionCountOutputType
   */

  export type MissionCountOutputType = {
    memberMission: number
  }

  export type MissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberMission?: boolean | MissionCountOutputTypeCountMemberMissionArgs
  }

  // Custom InputTypes
  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionCountOutputType
     */
    select?: MissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeCountMemberMissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberMissionWhereInput
  }


  /**
   * Count Type ReviewCountOutputType
   */

  export type ReviewCountOutputType = {
    replys: number
    images: number
  }

  export type ReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replys?: boolean | ReviewCountOutputTypeCountReplysArgs
    images?: boolean | ReviewCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     */
    select?: ReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountReplysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyWhereInput
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }


  /**
   * Count Type InquiryCountOutputType
   */

  export type InquiryCountOutputType = {
    images: number
  }

  export type InquiryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | InquiryCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * InquiryCountOutputType without action
   */
  export type InquiryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryCountOutputType
     */
    select?: InquiryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InquiryCountOutputType without action
   */
  export type InquiryCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }


  /**
   * Count Type AlarmCountOutputType
   */

  export type AlarmCountOutputType = {
    alarmsNewMissions: number
    alarmReviewRequest: number
  }

  export type AlarmCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alarmsNewMissions?: boolean | AlarmCountOutputTypeCountAlarmsNewMissionsArgs
    alarmReviewRequest?: boolean | AlarmCountOutputTypeCountAlarmReviewRequestArgs
  }

  // Custom InputTypes
  /**
   * AlarmCountOutputType without action
   */
  export type AlarmCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmCountOutputType
     */
    select?: AlarmCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlarmCountOutputType without action
   */
  export type AlarmCountOutputTypeCountAlarmsNewMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlarmNewMissionWhereInput
  }

  /**
   * AlarmCountOutputType without action
   */
  export type AlarmCountOutputTypeCountAlarmReviewRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlarmReviewRequestWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    id: number | null
    gender: number | null
    points: number | null
    status: number | null
  }

  export type MemberSumAggregateOutputType = {
    id: bigint | null
    gender: number | null
    points: bigint | null
    status: number | null
  }

  export type MemberMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    location: string | null
    phoneNumber: string | null
    nickname: string | null
    gender: number | null
    birth: Date | null
    points: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
    inactiveAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    location: string | null
    phoneNumber: string | null
    nickname: string | null
    gender: number | null
    birth: Date | null
    points: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
    inactiveAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    name: number
    email: number
    location: number
    phoneNumber: number
    nickname: number
    gender: number
    birth: number
    points: number
    createdAt: number
    updatedAt: number
    status: number
    inactiveAt: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    id?: true
    gender?: true
    points?: true
    status?: true
  }

  export type MemberSumAggregateInputType = {
    id?: true
    gender?: true
    points?: true
    status?: true
  }

  export type MemberMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    location?: true
    phoneNumber?: true
    nickname?: true
    gender?: true
    birth?: true
    points?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    inactiveAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    location?: true
    phoneNumber?: true
    nickname?: true
    gender?: true
    birth?: true
    points?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    inactiveAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    location?: true
    phoneNumber?: true
    nickname?: true
    gender?: true
    birth?: true
    points?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    inactiveAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: bigint
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date
    points: bigint
    createdAt: Date
    updatedAt: Date
    status: number
    inactiveAt: Date | null
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    location?: boolean
    phoneNumber?: boolean
    nickname?: boolean
    gender?: boolean
    birth?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    inactiveAt?: boolean
    memberfavoriteFoodKinds?: boolean | Member$memberfavoriteFoodKindsArgs<ExtArgs>
    restaurants?: boolean | Member$restaurantsArgs<ExtArgs>
    memberMissions?: boolean | Member$memberMissionsArgs<ExtArgs>
    reviews?: boolean | Member$reviewsArgs<ExtArgs>
    reply?: boolean | Member$replyArgs<ExtArgs>
    inquiries?: boolean | Member$inquiriesArgs<ExtArgs>
    alarms?: boolean | Member$alarmsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>


  export type MemberSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    location?: boolean
    phoneNumber?: boolean
    nickname?: boolean
    gender?: boolean
    birth?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    inactiveAt?: boolean
  }

  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberfavoriteFoodKinds?: boolean | Member$memberfavoriteFoodKindsArgs<ExtArgs>
    restaurants?: boolean | Member$restaurantsArgs<ExtArgs>
    memberMissions?: boolean | Member$memberMissionsArgs<ExtArgs>
    reviews?: boolean | Member$reviewsArgs<ExtArgs>
    reply?: boolean | Member$replyArgs<ExtArgs>
    inquiries?: boolean | Member$inquiriesArgs<ExtArgs>
    alarms?: boolean | Member$alarmsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      memberfavoriteFoodKinds: Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>[]
      restaurants: Prisma.$RestaurantPayload<ExtArgs>[]
      memberMissions: Prisma.$MemberMissionPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      reply: Prisma.$ReplyPayload<ExtArgs>[]
      inquiries: Prisma.$InquiryPayload<ExtArgs>[]
      alarms: Prisma.$AlarmPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      email: string
      location: string
      phoneNumber: string
      nickname: string
      gender: number
      birth: Date
      points: bigint
      createdAt: Date
      updatedAt: Date
      status: number
      inactiveAt: Date | null
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberfavoriteFoodKinds<T extends Member$memberfavoriteFoodKindsArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberfavoriteFoodKindsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "findMany"> | Null>
    restaurants<T extends Member$restaurantsArgs<ExtArgs> = {}>(args?: Subset<T, Member$restaurantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findMany"> | Null>
    memberMissions<T extends Member$memberMissionsArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberMissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Member$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Member$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    reply<T extends Member$replyArgs<ExtArgs> = {}>(args?: Subset<T, Member$replyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findMany"> | Null>
    inquiries<T extends Member$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, Member$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany"> | Null>
    alarms<T extends Member$alarmsArgs<ExtArgs> = {}>(args?: Subset<T, Member$alarmsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */ 
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'BigInt'>
    readonly name: FieldRef<"Member", 'String'>
    readonly email: FieldRef<"Member", 'String'>
    readonly location: FieldRef<"Member", 'String'>
    readonly phoneNumber: FieldRef<"Member", 'String'>
    readonly nickname: FieldRef<"Member", 'String'>
    readonly gender: FieldRef<"Member", 'Int'>
    readonly birth: FieldRef<"Member", 'DateTime'>
    readonly points: FieldRef<"Member", 'BigInt'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
    readonly status: FieldRef<"Member", 'Int'>
    readonly inactiveAt: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
  }

  /**
   * Member.memberfavoriteFoodKinds
   */
  export type Member$memberfavoriteFoodKindsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    where?: MemberFavoriteFoodKindWhereInput
    orderBy?: MemberFavoriteFoodKindOrderByWithRelationInput | MemberFavoriteFoodKindOrderByWithRelationInput[]
    cursor?: MemberFavoriteFoodKindWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberFavoriteFoodKindScalarFieldEnum | MemberFavoriteFoodKindScalarFieldEnum[]
  }

  /**
   * Member.restaurants
   */
  export type Member$restaurantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    where?: RestaurantWhereInput
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    cursor?: RestaurantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Member.memberMissions
   */
  export type Member$memberMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    where?: MemberMissionWhereInput
    orderBy?: MemberMissionOrderByWithRelationInput | MemberMissionOrderByWithRelationInput[]
    cursor?: MemberMissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberMissionScalarFieldEnum | MemberMissionScalarFieldEnum[]
  }

  /**
   * Member.reviews
   */
  export type Member$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Member.reply
   */
  export type Member$replyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    where?: ReplyWhereInput
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    cursor?: ReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }

  /**
   * Member.inquiries
   */
  export type Member$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Member.alarms
   */
  export type Member$alarmsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    where?: AlarmWhereInput
    orderBy?: AlarmOrderByWithRelationInput | AlarmOrderByWithRelationInput[]
    cursor?: AlarmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlarmScalarFieldEnum | AlarmScalarFieldEnum[]
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model FoodKind
   */

  export type AggregateFoodKind = {
    _count: FoodKindCountAggregateOutputType | null
    _avg: FoodKindAvgAggregateOutputType | null
    _sum: FoodKindSumAggregateOutputType | null
    _min: FoodKindMinAggregateOutputType | null
    _max: FoodKindMaxAggregateOutputType | null
  }

  export type FoodKindAvgAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type FoodKindSumAggregateOutputType = {
    id: bigint | null
    status: number | null
  }

  export type FoodKindMinAggregateOutputType = {
    id: bigint | null
    kind: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type FoodKindMaxAggregateOutputType = {
    id: bigint | null
    kind: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type FoodKindCountAggregateOutputType = {
    id: number
    kind: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type FoodKindAvgAggregateInputType = {
    id?: true
    status?: true
  }

  export type FoodKindSumAggregateInputType = {
    id?: true
    status?: true
  }

  export type FoodKindMinAggregateInputType = {
    id?: true
    kind?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type FoodKindMaxAggregateInputType = {
    id?: true
    kind?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type FoodKindCountAggregateInputType = {
    id?: true
    kind?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type FoodKindAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodKind to aggregate.
     */
    where?: FoodKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodKinds to fetch.
     */
    orderBy?: FoodKindOrderByWithRelationInput | FoodKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodKinds
    **/
    _count?: true | FoodKindCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodKindAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodKindSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodKindMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodKindMaxAggregateInputType
  }

  export type GetFoodKindAggregateType<T extends FoodKindAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodKind]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodKind[P]>
      : GetScalarType<T[P], AggregateFoodKind[P]>
  }




  export type FoodKindGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodKindWhereInput
    orderBy?: FoodKindOrderByWithAggregationInput | FoodKindOrderByWithAggregationInput[]
    by: FoodKindScalarFieldEnum[] | FoodKindScalarFieldEnum
    having?: FoodKindScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodKindCountAggregateInputType | true
    _avg?: FoodKindAvgAggregateInputType
    _sum?: FoodKindSumAggregateInputType
    _min?: FoodKindMinAggregateInputType
    _max?: FoodKindMaxAggregateInputType
  }

  export type FoodKindGroupByOutputType = {
    id: bigint
    kind: string
    createdAt: Date
    updatedAt: Date
    status: number
    _count: FoodKindCountAggregateOutputType | null
    _avg: FoodKindAvgAggregateOutputType | null
    _sum: FoodKindSumAggregateOutputType | null
    _min: FoodKindMinAggregateOutputType | null
    _max: FoodKindMaxAggregateOutputType | null
  }

  type GetFoodKindGroupByPayload<T extends FoodKindGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodKindGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodKindGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodKindGroupByOutputType[P]>
            : GetScalarType<T[P], FoodKindGroupByOutputType[P]>
        }
      >
    >


  export type FoodKindSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kind?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    memberfavoriteFoodKinds?: boolean | FoodKind$memberfavoriteFoodKindsArgs<ExtArgs>
    foodKindRestaurants?: boolean | FoodKind$foodKindRestaurantsArgs<ExtArgs>
    _count?: boolean | FoodKindCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodKind"]>


  export type FoodKindSelectScalar = {
    id?: boolean
    kind?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type FoodKindInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberfavoriteFoodKinds?: boolean | FoodKind$memberfavoriteFoodKindsArgs<ExtArgs>
    foodKindRestaurants?: boolean | FoodKind$foodKindRestaurantsArgs<ExtArgs>
    _count?: boolean | FoodKindCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FoodKindPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodKind"
    objects: {
      memberfavoriteFoodKinds: Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>[]
      foodKindRestaurants: Prisma.$FoodKindRestaurantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      kind: string
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["foodKind"]>
    composites: {}
  }

  type FoodKindGetPayload<S extends boolean | null | undefined | FoodKindDefaultArgs> = $Result.GetResult<Prisma.$FoodKindPayload, S>

  type FoodKindCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FoodKindFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoodKindCountAggregateInputType | true
    }

  export interface FoodKindDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodKind'], meta: { name: 'FoodKind' } }
    /**
     * Find zero or one FoodKind that matches the filter.
     * @param {FoodKindFindUniqueArgs} args - Arguments to find a FoodKind
     * @example
     * // Get one FoodKind
     * const foodKind = await prisma.foodKind.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodKindFindUniqueArgs>(args: SelectSubset<T, FoodKindFindUniqueArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FoodKind that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FoodKindFindUniqueOrThrowArgs} args - Arguments to find a FoodKind
     * @example
     * // Get one FoodKind
     * const foodKind = await prisma.foodKind.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodKindFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodKindFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FoodKind that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindFindFirstArgs} args - Arguments to find a FoodKind
     * @example
     * // Get one FoodKind
     * const foodKind = await prisma.foodKind.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodKindFindFirstArgs>(args?: SelectSubset<T, FoodKindFindFirstArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FoodKind that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindFindFirstOrThrowArgs} args - Arguments to find a FoodKind
     * @example
     * // Get one FoodKind
     * const foodKind = await prisma.foodKind.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodKindFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodKindFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FoodKinds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodKinds
     * const foodKinds = await prisma.foodKind.findMany()
     * 
     * // Get first 10 FoodKinds
     * const foodKinds = await prisma.foodKind.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodKindWithIdOnly = await prisma.foodKind.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodKindFindManyArgs>(args?: SelectSubset<T, FoodKindFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FoodKind.
     * @param {FoodKindCreateArgs} args - Arguments to create a FoodKind.
     * @example
     * // Create one FoodKind
     * const FoodKind = await prisma.foodKind.create({
     *   data: {
     *     // ... data to create a FoodKind
     *   }
     * })
     * 
     */
    create<T extends FoodKindCreateArgs>(args: SelectSubset<T, FoodKindCreateArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FoodKinds.
     * @param {FoodKindCreateManyArgs} args - Arguments to create many FoodKinds.
     * @example
     * // Create many FoodKinds
     * const foodKind = await prisma.foodKind.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodKindCreateManyArgs>(args?: SelectSubset<T, FoodKindCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoodKind.
     * @param {FoodKindDeleteArgs} args - Arguments to delete one FoodKind.
     * @example
     * // Delete one FoodKind
     * const FoodKind = await prisma.foodKind.delete({
     *   where: {
     *     // ... filter to delete one FoodKind
     *   }
     * })
     * 
     */
    delete<T extends FoodKindDeleteArgs>(args: SelectSubset<T, FoodKindDeleteArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FoodKind.
     * @param {FoodKindUpdateArgs} args - Arguments to update one FoodKind.
     * @example
     * // Update one FoodKind
     * const foodKind = await prisma.foodKind.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodKindUpdateArgs>(args: SelectSubset<T, FoodKindUpdateArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FoodKinds.
     * @param {FoodKindDeleteManyArgs} args - Arguments to filter FoodKinds to delete.
     * @example
     * // Delete a few FoodKinds
     * const { count } = await prisma.foodKind.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodKindDeleteManyArgs>(args?: SelectSubset<T, FoodKindDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodKinds
     * const foodKind = await prisma.foodKind.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodKindUpdateManyArgs>(args: SelectSubset<T, FoodKindUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoodKind.
     * @param {FoodKindUpsertArgs} args - Arguments to update or create a FoodKind.
     * @example
     * // Update or create a FoodKind
     * const foodKind = await prisma.foodKind.upsert({
     *   create: {
     *     // ... data to create a FoodKind
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodKind we want to update
     *   }
     * })
     */
    upsert<T extends FoodKindUpsertArgs>(args: SelectSubset<T, FoodKindUpsertArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FoodKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindCountArgs} args - Arguments to filter FoodKinds to count.
     * @example
     * // Count the number of FoodKinds
     * const count = await prisma.foodKind.count({
     *   where: {
     *     // ... the filter for the FoodKinds we want to count
     *   }
     * })
    **/
    count<T extends FoodKindCountArgs>(
      args?: Subset<T, FoodKindCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodKindCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodKindAggregateArgs>(args: Subset<T, FoodKindAggregateArgs>): Prisma.PrismaPromise<GetFoodKindAggregateType<T>>

    /**
     * Group by FoodKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodKindGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodKindGroupByArgs['orderBy'] }
        : { orderBy?: FoodKindGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodKindGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodKindGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodKind model
   */
  readonly fields: FoodKindFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodKind.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodKindClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberfavoriteFoodKinds<T extends FoodKind$memberfavoriteFoodKindsArgs<ExtArgs> = {}>(args?: Subset<T, FoodKind$memberfavoriteFoodKindsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "findMany"> | Null>
    foodKindRestaurants<T extends FoodKind$foodKindRestaurantsArgs<ExtArgs> = {}>(args?: Subset<T, FoodKind$foodKindRestaurantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodKind model
   */ 
  interface FoodKindFieldRefs {
    readonly id: FieldRef<"FoodKind", 'BigInt'>
    readonly kind: FieldRef<"FoodKind", 'String'>
    readonly createdAt: FieldRef<"FoodKind", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodKind", 'DateTime'>
    readonly status: FieldRef<"FoodKind", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FoodKind findUnique
   */
  export type FoodKindFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
    /**
     * Filter, which FoodKind to fetch.
     */
    where: FoodKindWhereUniqueInput
  }

  /**
   * FoodKind findUniqueOrThrow
   */
  export type FoodKindFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
    /**
     * Filter, which FoodKind to fetch.
     */
    where: FoodKindWhereUniqueInput
  }

  /**
   * FoodKind findFirst
   */
  export type FoodKindFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
    /**
     * Filter, which FoodKind to fetch.
     */
    where?: FoodKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodKinds to fetch.
     */
    orderBy?: FoodKindOrderByWithRelationInput | FoodKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodKinds.
     */
    cursor?: FoodKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodKinds.
     */
    distinct?: FoodKindScalarFieldEnum | FoodKindScalarFieldEnum[]
  }

  /**
   * FoodKind findFirstOrThrow
   */
  export type FoodKindFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
    /**
     * Filter, which FoodKind to fetch.
     */
    where?: FoodKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodKinds to fetch.
     */
    orderBy?: FoodKindOrderByWithRelationInput | FoodKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodKinds.
     */
    cursor?: FoodKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodKinds.
     */
    distinct?: FoodKindScalarFieldEnum | FoodKindScalarFieldEnum[]
  }

  /**
   * FoodKind findMany
   */
  export type FoodKindFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
    /**
     * Filter, which FoodKinds to fetch.
     */
    where?: FoodKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodKinds to fetch.
     */
    orderBy?: FoodKindOrderByWithRelationInput | FoodKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodKinds.
     */
    cursor?: FoodKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodKinds.
     */
    skip?: number
    distinct?: FoodKindScalarFieldEnum | FoodKindScalarFieldEnum[]
  }

  /**
   * FoodKind create
   */
  export type FoodKindCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodKind.
     */
    data: XOR<FoodKindCreateInput, FoodKindUncheckedCreateInput>
  }

  /**
   * FoodKind createMany
   */
  export type FoodKindCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodKinds.
     */
    data: FoodKindCreateManyInput | FoodKindCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodKind update
   */
  export type FoodKindUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodKind.
     */
    data: XOR<FoodKindUpdateInput, FoodKindUncheckedUpdateInput>
    /**
     * Choose, which FoodKind to update.
     */
    where: FoodKindWhereUniqueInput
  }

  /**
   * FoodKind updateMany
   */
  export type FoodKindUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodKinds.
     */
    data: XOR<FoodKindUpdateManyMutationInput, FoodKindUncheckedUpdateManyInput>
    /**
     * Filter which FoodKinds to update
     */
    where?: FoodKindWhereInput
  }

  /**
   * FoodKind upsert
   */
  export type FoodKindUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodKind to update in case it exists.
     */
    where: FoodKindWhereUniqueInput
    /**
     * In case the FoodKind found by the `where` argument doesn't exist, create a new FoodKind with this data.
     */
    create: XOR<FoodKindCreateInput, FoodKindUncheckedCreateInput>
    /**
     * In case the FoodKind was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodKindUpdateInput, FoodKindUncheckedUpdateInput>
  }

  /**
   * FoodKind delete
   */
  export type FoodKindDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
    /**
     * Filter which FoodKind to delete.
     */
    where: FoodKindWhereUniqueInput
  }

  /**
   * FoodKind deleteMany
   */
  export type FoodKindDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodKinds to delete
     */
    where?: FoodKindWhereInput
  }

  /**
   * FoodKind.memberfavoriteFoodKinds
   */
  export type FoodKind$memberfavoriteFoodKindsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    where?: MemberFavoriteFoodKindWhereInput
    orderBy?: MemberFavoriteFoodKindOrderByWithRelationInput | MemberFavoriteFoodKindOrderByWithRelationInput[]
    cursor?: MemberFavoriteFoodKindWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberFavoriteFoodKindScalarFieldEnum | MemberFavoriteFoodKindScalarFieldEnum[]
  }

  /**
   * FoodKind.foodKindRestaurants
   */
  export type FoodKind$foodKindRestaurantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    where?: FoodKindRestaurantWhereInput
    orderBy?: FoodKindRestaurantOrderByWithRelationInput | FoodKindRestaurantOrderByWithRelationInput[]
    cursor?: FoodKindRestaurantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodKindRestaurantScalarFieldEnum | FoodKindRestaurantScalarFieldEnum[]
  }

  /**
   * FoodKind without action
   */
  export type FoodKindDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKind
     */
    select?: FoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindInclude<ExtArgs> | null
  }


  /**
   * Model MemberFavoriteFoodKind
   */

  export type AggregateMemberFavoriteFoodKind = {
    _count: MemberFavoriteFoodKindCountAggregateOutputType | null
    _avg: MemberFavoriteFoodKindAvgAggregateOutputType | null
    _sum: MemberFavoriteFoodKindSumAggregateOutputType | null
    _min: MemberFavoriteFoodKindMinAggregateOutputType | null
    _max: MemberFavoriteFoodKindMaxAggregateOutputType | null
  }

  export type MemberFavoriteFoodKindAvgAggregateOutputType = {
    id: number | null
    memberId: number | null
    foodKindId: number | null
    status: number | null
  }

  export type MemberFavoriteFoodKindSumAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    foodKindId: bigint | null
    status: number | null
  }

  export type MemberFavoriteFoodKindMinAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    foodKindId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type MemberFavoriteFoodKindMaxAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    foodKindId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type MemberFavoriteFoodKindCountAggregateOutputType = {
    id: number
    memberId: number
    foodKindId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type MemberFavoriteFoodKindAvgAggregateInputType = {
    id?: true
    memberId?: true
    foodKindId?: true
    status?: true
  }

  export type MemberFavoriteFoodKindSumAggregateInputType = {
    id?: true
    memberId?: true
    foodKindId?: true
    status?: true
  }

  export type MemberFavoriteFoodKindMinAggregateInputType = {
    id?: true
    memberId?: true
    foodKindId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type MemberFavoriteFoodKindMaxAggregateInputType = {
    id?: true
    memberId?: true
    foodKindId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type MemberFavoriteFoodKindCountAggregateInputType = {
    id?: true
    memberId?: true
    foodKindId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type MemberFavoriteFoodKindAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberFavoriteFoodKind to aggregate.
     */
    where?: MemberFavoriteFoodKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberFavoriteFoodKinds to fetch.
     */
    orderBy?: MemberFavoriteFoodKindOrderByWithRelationInput | MemberFavoriteFoodKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberFavoriteFoodKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberFavoriteFoodKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberFavoriteFoodKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberFavoriteFoodKinds
    **/
    _count?: true | MemberFavoriteFoodKindCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberFavoriteFoodKindAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberFavoriteFoodKindSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberFavoriteFoodKindMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberFavoriteFoodKindMaxAggregateInputType
  }

  export type GetMemberFavoriteFoodKindAggregateType<T extends MemberFavoriteFoodKindAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberFavoriteFoodKind]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberFavoriteFoodKind[P]>
      : GetScalarType<T[P], AggregateMemberFavoriteFoodKind[P]>
  }




  export type MemberFavoriteFoodKindGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberFavoriteFoodKindWhereInput
    orderBy?: MemberFavoriteFoodKindOrderByWithAggregationInput | MemberFavoriteFoodKindOrderByWithAggregationInput[]
    by: MemberFavoriteFoodKindScalarFieldEnum[] | MemberFavoriteFoodKindScalarFieldEnum
    having?: MemberFavoriteFoodKindScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberFavoriteFoodKindCountAggregateInputType | true
    _avg?: MemberFavoriteFoodKindAvgAggregateInputType
    _sum?: MemberFavoriteFoodKindSumAggregateInputType
    _min?: MemberFavoriteFoodKindMinAggregateInputType
    _max?: MemberFavoriteFoodKindMaxAggregateInputType
  }

  export type MemberFavoriteFoodKindGroupByOutputType = {
    id: bigint
    memberId: bigint
    foodKindId: bigint
    createdAt: Date
    updatedAt: Date
    status: number
    _count: MemberFavoriteFoodKindCountAggregateOutputType | null
    _avg: MemberFavoriteFoodKindAvgAggregateOutputType | null
    _sum: MemberFavoriteFoodKindSumAggregateOutputType | null
    _min: MemberFavoriteFoodKindMinAggregateOutputType | null
    _max: MemberFavoriteFoodKindMaxAggregateOutputType | null
  }

  type GetMemberFavoriteFoodKindGroupByPayload<T extends MemberFavoriteFoodKindGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberFavoriteFoodKindGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberFavoriteFoodKindGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberFavoriteFoodKindGroupByOutputType[P]>
            : GetScalarType<T[P], MemberFavoriteFoodKindGroupByOutputType[P]>
        }
      >
    >


  export type MemberFavoriteFoodKindSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    foodKindId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    foodKind?: boolean | FoodKindDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberFavoriteFoodKind"]>


  export type MemberFavoriteFoodKindSelectScalar = {
    id?: boolean
    memberId?: boolean
    foodKindId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type MemberFavoriteFoodKindInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    foodKind?: boolean | FoodKindDefaultArgs<ExtArgs>
  }

  export type $MemberFavoriteFoodKindPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberFavoriteFoodKind"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      foodKind: Prisma.$FoodKindPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      memberId: bigint
      foodKindId: bigint
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["memberFavoriteFoodKind"]>
    composites: {}
  }

  type MemberFavoriteFoodKindGetPayload<S extends boolean | null | undefined | MemberFavoriteFoodKindDefaultArgs> = $Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload, S>

  type MemberFavoriteFoodKindCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberFavoriteFoodKindFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberFavoriteFoodKindCountAggregateInputType | true
    }

  export interface MemberFavoriteFoodKindDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberFavoriteFoodKind'], meta: { name: 'MemberFavoriteFoodKind' } }
    /**
     * Find zero or one MemberFavoriteFoodKind that matches the filter.
     * @param {MemberFavoriteFoodKindFindUniqueArgs} args - Arguments to find a MemberFavoriteFoodKind
     * @example
     * // Get one MemberFavoriteFoodKind
     * const memberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFavoriteFoodKindFindUniqueArgs>(args: SelectSubset<T, MemberFavoriteFoodKindFindUniqueArgs<ExtArgs>>): Prisma__MemberFavoriteFoodKindClient<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MemberFavoriteFoodKind that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MemberFavoriteFoodKindFindUniqueOrThrowArgs} args - Arguments to find a MemberFavoriteFoodKind
     * @example
     * // Get one MemberFavoriteFoodKind
     * const memberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFavoriteFoodKindFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFavoriteFoodKindFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberFavoriteFoodKindClient<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MemberFavoriteFoodKind that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFavoriteFoodKindFindFirstArgs} args - Arguments to find a MemberFavoriteFoodKind
     * @example
     * // Get one MemberFavoriteFoodKind
     * const memberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFavoriteFoodKindFindFirstArgs>(args?: SelectSubset<T, MemberFavoriteFoodKindFindFirstArgs<ExtArgs>>): Prisma__MemberFavoriteFoodKindClient<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MemberFavoriteFoodKind that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFavoriteFoodKindFindFirstOrThrowArgs} args - Arguments to find a MemberFavoriteFoodKind
     * @example
     * // Get one MemberFavoriteFoodKind
     * const memberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFavoriteFoodKindFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFavoriteFoodKindFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberFavoriteFoodKindClient<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MemberFavoriteFoodKinds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFavoriteFoodKindFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberFavoriteFoodKinds
     * const memberFavoriteFoodKinds = await prisma.memberFavoriteFoodKind.findMany()
     * 
     * // Get first 10 MemberFavoriteFoodKinds
     * const memberFavoriteFoodKinds = await prisma.memberFavoriteFoodKind.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberFavoriteFoodKindWithIdOnly = await prisma.memberFavoriteFoodKind.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFavoriteFoodKindFindManyArgs>(args?: SelectSubset<T, MemberFavoriteFoodKindFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MemberFavoriteFoodKind.
     * @param {MemberFavoriteFoodKindCreateArgs} args - Arguments to create a MemberFavoriteFoodKind.
     * @example
     * // Create one MemberFavoriteFoodKind
     * const MemberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.create({
     *   data: {
     *     // ... data to create a MemberFavoriteFoodKind
     *   }
     * })
     * 
     */
    create<T extends MemberFavoriteFoodKindCreateArgs>(args: SelectSubset<T, MemberFavoriteFoodKindCreateArgs<ExtArgs>>): Prisma__MemberFavoriteFoodKindClient<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MemberFavoriteFoodKinds.
     * @param {MemberFavoriteFoodKindCreateManyArgs} args - Arguments to create many MemberFavoriteFoodKinds.
     * @example
     * // Create many MemberFavoriteFoodKinds
     * const memberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberFavoriteFoodKindCreateManyArgs>(args?: SelectSubset<T, MemberFavoriteFoodKindCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MemberFavoriteFoodKind.
     * @param {MemberFavoriteFoodKindDeleteArgs} args - Arguments to delete one MemberFavoriteFoodKind.
     * @example
     * // Delete one MemberFavoriteFoodKind
     * const MemberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.delete({
     *   where: {
     *     // ... filter to delete one MemberFavoriteFoodKind
     *   }
     * })
     * 
     */
    delete<T extends MemberFavoriteFoodKindDeleteArgs>(args: SelectSubset<T, MemberFavoriteFoodKindDeleteArgs<ExtArgs>>): Prisma__MemberFavoriteFoodKindClient<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MemberFavoriteFoodKind.
     * @param {MemberFavoriteFoodKindUpdateArgs} args - Arguments to update one MemberFavoriteFoodKind.
     * @example
     * // Update one MemberFavoriteFoodKind
     * const memberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberFavoriteFoodKindUpdateArgs>(args: SelectSubset<T, MemberFavoriteFoodKindUpdateArgs<ExtArgs>>): Prisma__MemberFavoriteFoodKindClient<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MemberFavoriteFoodKinds.
     * @param {MemberFavoriteFoodKindDeleteManyArgs} args - Arguments to filter MemberFavoriteFoodKinds to delete.
     * @example
     * // Delete a few MemberFavoriteFoodKinds
     * const { count } = await prisma.memberFavoriteFoodKind.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberFavoriteFoodKindDeleteManyArgs>(args?: SelectSubset<T, MemberFavoriteFoodKindDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberFavoriteFoodKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFavoriteFoodKindUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberFavoriteFoodKinds
     * const memberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberFavoriteFoodKindUpdateManyArgs>(args: SelectSubset<T, MemberFavoriteFoodKindUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MemberFavoriteFoodKind.
     * @param {MemberFavoriteFoodKindUpsertArgs} args - Arguments to update or create a MemberFavoriteFoodKind.
     * @example
     * // Update or create a MemberFavoriteFoodKind
     * const memberFavoriteFoodKind = await prisma.memberFavoriteFoodKind.upsert({
     *   create: {
     *     // ... data to create a MemberFavoriteFoodKind
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberFavoriteFoodKind we want to update
     *   }
     * })
     */
    upsert<T extends MemberFavoriteFoodKindUpsertArgs>(args: SelectSubset<T, MemberFavoriteFoodKindUpsertArgs<ExtArgs>>): Prisma__MemberFavoriteFoodKindClient<$Result.GetResult<Prisma.$MemberFavoriteFoodKindPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MemberFavoriteFoodKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFavoriteFoodKindCountArgs} args - Arguments to filter MemberFavoriteFoodKinds to count.
     * @example
     * // Count the number of MemberFavoriteFoodKinds
     * const count = await prisma.memberFavoriteFoodKind.count({
     *   where: {
     *     // ... the filter for the MemberFavoriteFoodKinds we want to count
     *   }
     * })
    **/
    count<T extends MemberFavoriteFoodKindCountArgs>(
      args?: Subset<T, MemberFavoriteFoodKindCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberFavoriteFoodKindCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberFavoriteFoodKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFavoriteFoodKindAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberFavoriteFoodKindAggregateArgs>(args: Subset<T, MemberFavoriteFoodKindAggregateArgs>): Prisma.PrismaPromise<GetMemberFavoriteFoodKindAggregateType<T>>

    /**
     * Group by MemberFavoriteFoodKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFavoriteFoodKindGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberFavoriteFoodKindGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberFavoriteFoodKindGroupByArgs['orderBy'] }
        : { orderBy?: MemberFavoriteFoodKindGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberFavoriteFoodKindGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberFavoriteFoodKindGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberFavoriteFoodKind model
   */
  readonly fields: MemberFavoriteFoodKindFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberFavoriteFoodKind.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberFavoriteFoodKindClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    foodKind<T extends FoodKindDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodKindDefaultArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberFavoriteFoodKind model
   */ 
  interface MemberFavoriteFoodKindFieldRefs {
    readonly id: FieldRef<"MemberFavoriteFoodKind", 'BigInt'>
    readonly memberId: FieldRef<"MemberFavoriteFoodKind", 'BigInt'>
    readonly foodKindId: FieldRef<"MemberFavoriteFoodKind", 'BigInt'>
    readonly createdAt: FieldRef<"MemberFavoriteFoodKind", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberFavoriteFoodKind", 'DateTime'>
    readonly status: FieldRef<"MemberFavoriteFoodKind", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MemberFavoriteFoodKind findUnique
   */
  export type MemberFavoriteFoodKindFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    /**
     * Filter, which MemberFavoriteFoodKind to fetch.
     */
    where: MemberFavoriteFoodKindWhereUniqueInput
  }

  /**
   * MemberFavoriteFoodKind findUniqueOrThrow
   */
  export type MemberFavoriteFoodKindFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    /**
     * Filter, which MemberFavoriteFoodKind to fetch.
     */
    where: MemberFavoriteFoodKindWhereUniqueInput
  }

  /**
   * MemberFavoriteFoodKind findFirst
   */
  export type MemberFavoriteFoodKindFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    /**
     * Filter, which MemberFavoriteFoodKind to fetch.
     */
    where?: MemberFavoriteFoodKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberFavoriteFoodKinds to fetch.
     */
    orderBy?: MemberFavoriteFoodKindOrderByWithRelationInput | MemberFavoriteFoodKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberFavoriteFoodKinds.
     */
    cursor?: MemberFavoriteFoodKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberFavoriteFoodKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberFavoriteFoodKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberFavoriteFoodKinds.
     */
    distinct?: MemberFavoriteFoodKindScalarFieldEnum | MemberFavoriteFoodKindScalarFieldEnum[]
  }

  /**
   * MemberFavoriteFoodKind findFirstOrThrow
   */
  export type MemberFavoriteFoodKindFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    /**
     * Filter, which MemberFavoriteFoodKind to fetch.
     */
    where?: MemberFavoriteFoodKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberFavoriteFoodKinds to fetch.
     */
    orderBy?: MemberFavoriteFoodKindOrderByWithRelationInput | MemberFavoriteFoodKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberFavoriteFoodKinds.
     */
    cursor?: MemberFavoriteFoodKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberFavoriteFoodKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberFavoriteFoodKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberFavoriteFoodKinds.
     */
    distinct?: MemberFavoriteFoodKindScalarFieldEnum | MemberFavoriteFoodKindScalarFieldEnum[]
  }

  /**
   * MemberFavoriteFoodKind findMany
   */
  export type MemberFavoriteFoodKindFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    /**
     * Filter, which MemberFavoriteFoodKinds to fetch.
     */
    where?: MemberFavoriteFoodKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberFavoriteFoodKinds to fetch.
     */
    orderBy?: MemberFavoriteFoodKindOrderByWithRelationInput | MemberFavoriteFoodKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberFavoriteFoodKinds.
     */
    cursor?: MemberFavoriteFoodKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberFavoriteFoodKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberFavoriteFoodKinds.
     */
    skip?: number
    distinct?: MemberFavoriteFoodKindScalarFieldEnum | MemberFavoriteFoodKindScalarFieldEnum[]
  }

  /**
   * MemberFavoriteFoodKind create
   */
  export type MemberFavoriteFoodKindCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberFavoriteFoodKind.
     */
    data: XOR<MemberFavoriteFoodKindCreateInput, MemberFavoriteFoodKindUncheckedCreateInput>
  }

  /**
   * MemberFavoriteFoodKind createMany
   */
  export type MemberFavoriteFoodKindCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberFavoriteFoodKinds.
     */
    data: MemberFavoriteFoodKindCreateManyInput | MemberFavoriteFoodKindCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberFavoriteFoodKind update
   */
  export type MemberFavoriteFoodKindUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberFavoriteFoodKind.
     */
    data: XOR<MemberFavoriteFoodKindUpdateInput, MemberFavoriteFoodKindUncheckedUpdateInput>
    /**
     * Choose, which MemberFavoriteFoodKind to update.
     */
    where: MemberFavoriteFoodKindWhereUniqueInput
  }

  /**
   * MemberFavoriteFoodKind updateMany
   */
  export type MemberFavoriteFoodKindUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberFavoriteFoodKinds.
     */
    data: XOR<MemberFavoriteFoodKindUpdateManyMutationInput, MemberFavoriteFoodKindUncheckedUpdateManyInput>
    /**
     * Filter which MemberFavoriteFoodKinds to update
     */
    where?: MemberFavoriteFoodKindWhereInput
  }

  /**
   * MemberFavoriteFoodKind upsert
   */
  export type MemberFavoriteFoodKindUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberFavoriteFoodKind to update in case it exists.
     */
    where: MemberFavoriteFoodKindWhereUniqueInput
    /**
     * In case the MemberFavoriteFoodKind found by the `where` argument doesn't exist, create a new MemberFavoriteFoodKind with this data.
     */
    create: XOR<MemberFavoriteFoodKindCreateInput, MemberFavoriteFoodKindUncheckedCreateInput>
    /**
     * In case the MemberFavoriteFoodKind was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberFavoriteFoodKindUpdateInput, MemberFavoriteFoodKindUncheckedUpdateInput>
  }

  /**
   * MemberFavoriteFoodKind delete
   */
  export type MemberFavoriteFoodKindDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
    /**
     * Filter which MemberFavoriteFoodKind to delete.
     */
    where: MemberFavoriteFoodKindWhereUniqueInput
  }

  /**
   * MemberFavoriteFoodKind deleteMany
   */
  export type MemberFavoriteFoodKindDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberFavoriteFoodKinds to delete
     */
    where?: MemberFavoriteFoodKindWhereInput
  }

  /**
   * MemberFavoriteFoodKind without action
   */
  export type MemberFavoriteFoodKindDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberFavoriteFoodKind
     */
    select?: MemberFavoriteFoodKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberFavoriteFoodKindInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: bigint | null
    status: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: bigint | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type RegionMaxAggregateOutputType = {
    id: bigint | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    address: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
    status?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
    status?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: bigint
    address: string
    createdAt: Date
    updatedAt: Date
    status: number
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    restaurant?: boolean | Region$restaurantArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>


  export type RegionSelectScalar = {
    id?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | Region$restaurantArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      address: string
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends Region$restaurantArgs<ExtArgs> = {}>(args?: Subset<T, Region$restaurantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */ 
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'BigInt'>
    readonly address: FieldRef<"Region", 'String'>
    readonly createdAt: FieldRef<"Region", 'DateTime'>
    readonly updatedAt: FieldRef<"Region", 'DateTime'>
    readonly status: FieldRef<"Region", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
  }

  /**
   * Region.restaurant
   */
  export type Region$restaurantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    where?: RestaurantWhereInput
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    cursor?: RestaurantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model Restaurant
   */

  export type AggregateRestaurant = {
    _count: RestaurantCountAggregateOutputType | null
    _avg: RestaurantAvgAggregateOutputType | null
    _sum: RestaurantSumAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  export type RestaurantAvgAggregateOutputType = {
    id: number | null
    ceoId: number | null
    regionId: number | null
    totalRating: Decimal | null
    status: number | null
  }

  export type RestaurantSumAggregateOutputType = {
    id: bigint | null
    ceoId: bigint | null
    regionId: bigint | null
    totalRating: Decimal | null
    status: number | null
  }

  export type RestaurantMinAggregateOutputType = {
    id: bigint | null
    ceoId: bigint | null
    regionId: bigint | null
    name: string | null
    introduction: string | null
    startTime: string | null
    endTime: string | null
    totalRating: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type RestaurantMaxAggregateOutputType = {
    id: bigint | null
    ceoId: bigint | null
    regionId: bigint | null
    name: string | null
    introduction: string | null
    startTime: string | null
    endTime: string | null
    totalRating: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type RestaurantCountAggregateOutputType = {
    id: number
    ceoId: number
    regionId: number
    name: number
    introduction: number
    startTime: number
    endTime: number
    totalRating: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type RestaurantAvgAggregateInputType = {
    id?: true
    ceoId?: true
    regionId?: true
    totalRating?: true
    status?: true
  }

  export type RestaurantSumAggregateInputType = {
    id?: true
    ceoId?: true
    regionId?: true
    totalRating?: true
    status?: true
  }

  export type RestaurantMinAggregateInputType = {
    id?: true
    ceoId?: true
    regionId?: true
    name?: true
    introduction?: true
    startTime?: true
    endTime?: true
    totalRating?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type RestaurantMaxAggregateInputType = {
    id?: true
    ceoId?: true
    regionId?: true
    name?: true
    introduction?: true
    startTime?: true
    endTime?: true
    totalRating?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type RestaurantCountAggregateInputType = {
    id?: true
    ceoId?: true
    regionId?: true
    name?: true
    introduction?: true
    startTime?: true
    endTime?: true
    totalRating?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type RestaurantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurant to aggregate.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Restaurants
    **/
    _count?: true | RestaurantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantMaxAggregateInputType
  }

  export type GetRestaurantAggregateType<T extends RestaurantAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurant[P]>
      : GetScalarType<T[P], AggregateRestaurant[P]>
  }




  export type RestaurantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWhereInput
    orderBy?: RestaurantOrderByWithAggregationInput | RestaurantOrderByWithAggregationInput[]
    by: RestaurantScalarFieldEnum[] | RestaurantScalarFieldEnum
    having?: RestaurantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantCountAggregateInputType | true
    _avg?: RestaurantAvgAggregateInputType
    _sum?: RestaurantSumAggregateInputType
    _min?: RestaurantMinAggregateInputType
    _max?: RestaurantMaxAggregateInputType
  }

  export type RestaurantGroupByOutputType = {
    id: bigint
    ceoId: bigint
    regionId: bigint
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating: Decimal
    createdAt: Date
    updatedAt: Date
    status: number
    _count: RestaurantCountAggregateOutputType | null
    _avg: RestaurantAvgAggregateOutputType | null
    _sum: RestaurantSumAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  type GetRestaurantGroupByPayload<T extends RestaurantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ceoId?: boolean
    regionId?: boolean
    name?: boolean
    introduction?: boolean
    startTime?: boolean
    endTime?: boolean
    totalRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    ceo?: boolean | MemberDefaultArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
    missions?: boolean | Restaurant$missionsArgs<ExtArgs>
    foodKindRestaurants?: boolean | Restaurant$foodKindRestaurantsArgs<ExtArgs>
    reviews?: boolean | Restaurant$reviewsArgs<ExtArgs>
    images?: boolean | Restaurant$imagesArgs<ExtArgs>
    _count?: boolean | RestaurantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurant"]>


  export type RestaurantSelectScalar = {
    id?: boolean
    ceoId?: boolean
    regionId?: boolean
    name?: boolean
    introduction?: boolean
    startTime?: boolean
    endTime?: boolean
    totalRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type RestaurantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ceo?: boolean | MemberDefaultArgs<ExtArgs>
    region?: boolean | RegionDefaultArgs<ExtArgs>
    missions?: boolean | Restaurant$missionsArgs<ExtArgs>
    foodKindRestaurants?: boolean | Restaurant$foodKindRestaurantsArgs<ExtArgs>
    reviews?: boolean | Restaurant$reviewsArgs<ExtArgs>
    images?: boolean | Restaurant$imagesArgs<ExtArgs>
    _count?: boolean | RestaurantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RestaurantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Restaurant"
    objects: {
      ceo: Prisma.$MemberPayload<ExtArgs>
      region: Prisma.$RegionPayload<ExtArgs>
      missions: Prisma.$MissionPayload<ExtArgs>[]
      foodKindRestaurants: Prisma.$FoodKindRestaurantPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      images: Prisma.$ImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      ceoId: bigint
      regionId: bigint
      name: string
      introduction: string
      startTime: string
      endTime: string
      totalRating: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["restaurant"]>
    composites: {}
  }

  type RestaurantGetPayload<S extends boolean | null | undefined | RestaurantDefaultArgs> = $Result.GetResult<Prisma.$RestaurantPayload, S>

  type RestaurantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RestaurantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RestaurantCountAggregateInputType | true
    }

  export interface RestaurantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Restaurant'], meta: { name: 'Restaurant' } }
    /**
     * Find zero or one Restaurant that matches the filter.
     * @param {RestaurantFindUniqueArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantFindUniqueArgs>(args: SelectSubset<T, RestaurantFindUniqueArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Restaurant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RestaurantFindUniqueOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Restaurant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantFindFirstArgs>(args?: SelectSubset<T, RestaurantFindFirstArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Restaurant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Restaurants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restaurants
     * const restaurants = await prisma.restaurant.findMany()
     * 
     * // Get first 10 Restaurants
     * const restaurants = await prisma.restaurant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantFindManyArgs>(args?: SelectSubset<T, RestaurantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Restaurant.
     * @param {RestaurantCreateArgs} args - Arguments to create a Restaurant.
     * @example
     * // Create one Restaurant
     * const Restaurant = await prisma.restaurant.create({
     *   data: {
     *     // ... data to create a Restaurant
     *   }
     * })
     * 
     */
    create<T extends RestaurantCreateArgs>(args: SelectSubset<T, RestaurantCreateArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Restaurants.
     * @param {RestaurantCreateManyArgs} args - Arguments to create many Restaurants.
     * @example
     * // Create many Restaurants
     * const restaurant = await prisma.restaurant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantCreateManyArgs>(args?: SelectSubset<T, RestaurantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Restaurant.
     * @param {RestaurantDeleteArgs} args - Arguments to delete one Restaurant.
     * @example
     * // Delete one Restaurant
     * const Restaurant = await prisma.restaurant.delete({
     *   where: {
     *     // ... filter to delete one Restaurant
     *   }
     * })
     * 
     */
    delete<T extends RestaurantDeleteArgs>(args: SelectSubset<T, RestaurantDeleteArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Restaurant.
     * @param {RestaurantUpdateArgs} args - Arguments to update one Restaurant.
     * @example
     * // Update one Restaurant
     * const restaurant = await prisma.restaurant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantUpdateArgs>(args: SelectSubset<T, RestaurantUpdateArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Restaurants.
     * @param {RestaurantDeleteManyArgs} args - Arguments to filter Restaurants to delete.
     * @example
     * // Delete a few Restaurants
     * const { count } = await prisma.restaurant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantDeleteManyArgs>(args?: SelectSubset<T, RestaurantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restaurants
     * const restaurant = await prisma.restaurant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantUpdateManyArgs>(args: SelectSubset<T, RestaurantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Restaurant.
     * @param {RestaurantUpsertArgs} args - Arguments to update or create a Restaurant.
     * @example
     * // Update or create a Restaurant
     * const restaurant = await prisma.restaurant.upsert({
     *   create: {
     *     // ... data to create a Restaurant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restaurant we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantUpsertArgs>(args: SelectSubset<T, RestaurantUpsertArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCountArgs} args - Arguments to filter Restaurants to count.
     * @example
     * // Count the number of Restaurants
     * const count = await prisma.restaurant.count({
     *   where: {
     *     // ... the filter for the Restaurants we want to count
     *   }
     * })
    **/
    count<T extends RestaurantCountArgs>(
      args?: Subset<T, RestaurantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantAggregateArgs>(args: Subset<T, RestaurantAggregateArgs>): Prisma.PrismaPromise<GetRestaurantAggregateType<T>>

    /**
     * Group by Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Restaurant model
   */
  readonly fields: RestaurantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Restaurant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ceo<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    missions<T extends Restaurant$missionsArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$missionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany"> | Null>
    foodKindRestaurants<T extends Restaurant$foodKindRestaurantsArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$foodKindRestaurantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Restaurant$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    images<T extends Restaurant$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Restaurant model
   */ 
  interface RestaurantFieldRefs {
    readonly id: FieldRef<"Restaurant", 'BigInt'>
    readonly ceoId: FieldRef<"Restaurant", 'BigInt'>
    readonly regionId: FieldRef<"Restaurant", 'BigInt'>
    readonly name: FieldRef<"Restaurant", 'String'>
    readonly introduction: FieldRef<"Restaurant", 'String'>
    readonly startTime: FieldRef<"Restaurant", 'String'>
    readonly endTime: FieldRef<"Restaurant", 'String'>
    readonly totalRating: FieldRef<"Restaurant", 'Decimal'>
    readonly createdAt: FieldRef<"Restaurant", 'DateTime'>
    readonly updatedAt: FieldRef<"Restaurant", 'DateTime'>
    readonly status: FieldRef<"Restaurant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Restaurant findUnique
   */
  export type RestaurantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant findUniqueOrThrow
   */
  export type RestaurantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant findFirst
   */
  export type RestaurantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant findFirstOrThrow
   */
  export type RestaurantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant findMany
   */
  export type RestaurantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurants to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant create
   */
  export type RestaurantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to create a Restaurant.
     */
    data: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
  }

  /**
   * Restaurant createMany
   */
  export type RestaurantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Restaurants.
     */
    data: RestaurantCreateManyInput | RestaurantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Restaurant update
   */
  export type RestaurantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to update a Restaurant.
     */
    data: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
    /**
     * Choose, which Restaurant to update.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant updateMany
   */
  export type RestaurantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Restaurants.
     */
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyInput>
    /**
     * Filter which Restaurants to update
     */
    where?: RestaurantWhereInput
  }

  /**
   * Restaurant upsert
   */
  export type RestaurantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The filter to search for the Restaurant to update in case it exists.
     */
    where: RestaurantWhereUniqueInput
    /**
     * In case the Restaurant found by the `where` argument doesn't exist, create a new Restaurant with this data.
     */
    create: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
    /**
     * In case the Restaurant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
  }

  /**
   * Restaurant delete
   */
  export type RestaurantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter which Restaurant to delete.
     */
    where: RestaurantWhereUniqueInput
  }

  /**
   * Restaurant deleteMany
   */
  export type RestaurantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurants to delete
     */
    where?: RestaurantWhereInput
  }

  /**
   * Restaurant.missions
   */
  export type Restaurant$missionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    cursor?: MissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Restaurant.foodKindRestaurants
   */
  export type Restaurant$foodKindRestaurantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    where?: FoodKindRestaurantWhereInput
    orderBy?: FoodKindRestaurantOrderByWithRelationInput | FoodKindRestaurantOrderByWithRelationInput[]
    cursor?: FoodKindRestaurantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodKindRestaurantScalarFieldEnum | FoodKindRestaurantScalarFieldEnum[]
  }

  /**
   * Restaurant.reviews
   */
  export type Restaurant$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Restaurant.images
   */
  export type Restaurant$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Restaurant without action
   */
  export type RestaurantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
  }


  /**
   * Model Mission
   */

  export type AggregateMission = {
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  export type MissionAvgAggregateOutputType = {
    id: number | null
    restaurantId: number | null
    points: number | null
    status: number | null
  }

  export type MissionSumAggregateOutputType = {
    id: bigint | null
    restaurantId: bigint | null
    points: number | null
    status: number | null
  }

  export type MissionMinAggregateOutputType = {
    id: bigint | null
    restaurantId: bigint | null
    name: string | null
    introduction: string | null
    deadline: Date | null
    points: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type MissionMaxAggregateOutputType = {
    id: bigint | null
    restaurantId: bigint | null
    name: string | null
    introduction: string | null
    deadline: Date | null
    points: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type MissionCountAggregateOutputType = {
    id: number
    restaurantId: number
    name: number
    introduction: number
    deadline: number
    points: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type MissionAvgAggregateInputType = {
    id?: true
    restaurantId?: true
    points?: true
    status?: true
  }

  export type MissionSumAggregateInputType = {
    id?: true
    restaurantId?: true
    points?: true
    status?: true
  }

  export type MissionMinAggregateInputType = {
    id?: true
    restaurantId?: true
    name?: true
    introduction?: true
    deadline?: true
    points?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type MissionMaxAggregateInputType = {
    id?: true
    restaurantId?: true
    name?: true
    introduction?: true
    deadline?: true
    points?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type MissionCountAggregateInputType = {
    id?: true
    restaurantId?: true
    name?: true
    introduction?: true
    deadline?: true
    points?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type MissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mission to aggregate.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Missions
    **/
    _count?: true | MissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionMaxAggregateInputType
  }

  export type GetMissionAggregateType<T extends MissionAggregateArgs> = {
        [P in keyof T & keyof AggregateMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMission[P]>
      : GetScalarType<T[P], AggregateMission[P]>
  }




  export type MissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithAggregationInput | MissionOrderByWithAggregationInput[]
    by: MissionScalarFieldEnum[] | MissionScalarFieldEnum
    having?: MissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionCountAggregateInputType | true
    _avg?: MissionAvgAggregateInputType
    _sum?: MissionSumAggregateInputType
    _min?: MissionMinAggregateInputType
    _max?: MissionMaxAggregateInputType
  }

  export type MissionGroupByOutputType = {
    id: bigint
    restaurantId: bigint
    name: string
    introduction: string
    deadline: Date
    points: number
    createdAt: Date
    updatedAt: Date
    status: number
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  type GetMissionGroupByPayload<T extends MissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionGroupByOutputType[P]>
            : GetScalarType<T[P], MissionGroupByOutputType[P]>
        }
      >
    >


  export type MissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    restaurantId?: boolean
    name?: boolean
    introduction?: boolean
    deadline?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    memberMission?: boolean | Mission$memberMissionArgs<ExtArgs>
    _count?: boolean | MissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mission"]>


  export type MissionSelectScalar = {
    id?: boolean
    restaurantId?: boolean
    name?: boolean
    introduction?: boolean
    deadline?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type MissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    memberMission?: boolean | Mission$memberMissionArgs<ExtArgs>
    _count?: boolean | MissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mission"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
      memberMission: Prisma.$MemberMissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      restaurantId: bigint
      name: string
      introduction: string
      deadline: Date
      points: number
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["mission"]>
    composites: {}
  }

  type MissionGetPayload<S extends boolean | null | undefined | MissionDefaultArgs> = $Result.GetResult<Prisma.$MissionPayload, S>

  type MissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MissionCountAggregateInputType | true
    }

  export interface MissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mission'], meta: { name: 'Mission' } }
    /**
     * Find zero or one Mission that matches the filter.
     * @param {MissionFindUniqueArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionFindUniqueArgs>(args: SelectSubset<T, MissionFindUniqueArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MissionFindUniqueOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionFindFirstArgs>(args?: SelectSubset<T, MissionFindFirstArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Missions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Missions
     * const missions = await prisma.mission.findMany()
     * 
     * // Get first 10 Missions
     * const missions = await prisma.mission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missionWithIdOnly = await prisma.mission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissionFindManyArgs>(args?: SelectSubset<T, MissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mission.
     * @param {MissionCreateArgs} args - Arguments to create a Mission.
     * @example
     * // Create one Mission
     * const Mission = await prisma.mission.create({
     *   data: {
     *     // ... data to create a Mission
     *   }
     * })
     * 
     */
    create<T extends MissionCreateArgs>(args: SelectSubset<T, MissionCreateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Missions.
     * @param {MissionCreateManyArgs} args - Arguments to create many Missions.
     * @example
     * // Create many Missions
     * const mission = await prisma.mission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionCreateManyArgs>(args?: SelectSubset<T, MissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mission.
     * @param {MissionDeleteArgs} args - Arguments to delete one Mission.
     * @example
     * // Delete one Mission
     * const Mission = await prisma.mission.delete({
     *   where: {
     *     // ... filter to delete one Mission
     *   }
     * })
     * 
     */
    delete<T extends MissionDeleteArgs>(args: SelectSubset<T, MissionDeleteArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mission.
     * @param {MissionUpdateArgs} args - Arguments to update one Mission.
     * @example
     * // Update one Mission
     * const mission = await prisma.mission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionUpdateArgs>(args: SelectSubset<T, MissionUpdateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Missions.
     * @param {MissionDeleteManyArgs} args - Arguments to filter Missions to delete.
     * @example
     * // Delete a few Missions
     * const { count } = await prisma.mission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionDeleteManyArgs>(args?: SelectSubset<T, MissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Missions
     * const mission = await prisma.mission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionUpdateManyArgs>(args: SelectSubset<T, MissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mission.
     * @param {MissionUpsertArgs} args - Arguments to update or create a Mission.
     * @example
     * // Update or create a Mission
     * const mission = await prisma.mission.upsert({
     *   create: {
     *     // ... data to create a Mission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mission we want to update
     *   }
     * })
     */
    upsert<T extends MissionUpsertArgs>(args: SelectSubset<T, MissionUpsertArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionCountArgs} args - Arguments to filter Missions to count.
     * @example
     * // Count the number of Missions
     * const count = await prisma.mission.count({
     *   where: {
     *     // ... the filter for the Missions we want to count
     *   }
     * })
    **/
    count<T extends MissionCountArgs>(
      args?: Subset<T, MissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionAggregateArgs>(args: Subset<T, MissionAggregateArgs>): Prisma.PrismaPromise<GetMissionAggregateType<T>>

    /**
     * Group by Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionGroupByArgs['orderBy'] }
        : { orderBy?: MissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mission model
   */
  readonly fields: MissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    memberMission<T extends Mission$memberMissionArgs<ExtArgs> = {}>(args?: Subset<T, Mission$memberMissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mission model
   */ 
  interface MissionFieldRefs {
    readonly id: FieldRef<"Mission", 'BigInt'>
    readonly restaurantId: FieldRef<"Mission", 'BigInt'>
    readonly name: FieldRef<"Mission", 'String'>
    readonly introduction: FieldRef<"Mission", 'String'>
    readonly deadline: FieldRef<"Mission", 'DateTime'>
    readonly points: FieldRef<"Mission", 'Int'>
    readonly createdAt: FieldRef<"Mission", 'DateTime'>
    readonly updatedAt: FieldRef<"Mission", 'DateTime'>
    readonly status: FieldRef<"Mission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Mission findUnique
   */
  export type MissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findUniqueOrThrow
   */
  export type MissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findFirst
   */
  export type MissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findFirstOrThrow
   */
  export type MissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findMany
   */
  export type MissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Missions to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission create
   */
  export type MissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Mission.
     */
    data: XOR<MissionCreateInput, MissionUncheckedCreateInput>
  }

  /**
   * Mission createMany
   */
  export type MissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Missions.
     */
    data: MissionCreateManyInput | MissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mission update
   */
  export type MissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Mission.
     */
    data: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
    /**
     * Choose, which Mission to update.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission updateMany
   */
  export type MissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Missions.
     */
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyInput>
    /**
     * Filter which Missions to update
     */
    where?: MissionWhereInput
  }

  /**
   * Mission upsert
   */
  export type MissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Mission to update in case it exists.
     */
    where: MissionWhereUniqueInput
    /**
     * In case the Mission found by the `where` argument doesn't exist, create a new Mission with this data.
     */
    create: XOR<MissionCreateInput, MissionUncheckedCreateInput>
    /**
     * In case the Mission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
  }

  /**
   * Mission delete
   */
  export type MissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter which Mission to delete.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission deleteMany
   */
  export type MissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Missions to delete
     */
    where?: MissionWhereInput
  }

  /**
   * Mission.memberMission
   */
  export type Mission$memberMissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    where?: MemberMissionWhereInput
    orderBy?: MemberMissionOrderByWithRelationInput | MemberMissionOrderByWithRelationInput[]
    cursor?: MemberMissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberMissionScalarFieldEnum | MemberMissionScalarFieldEnum[]
  }

  /**
   * Mission without action
   */
  export type MissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
  }


  /**
   * Model MemberMission
   */

  export type AggregateMemberMission = {
    _count: MemberMissionCountAggregateOutputType | null
    _avg: MemberMissionAvgAggregateOutputType | null
    _sum: MemberMissionSumAggregateOutputType | null
    _min: MemberMissionMinAggregateOutputType | null
    _max: MemberMissionMaxAggregateOutputType | null
  }

  export type MemberMissionAvgAggregateOutputType = {
    id: number | null
    memberId: number | null
    missionId: number | null
    status: number | null
  }

  export type MemberMissionSumAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    missionId: bigint | null
    status: number | null
  }

  export type MemberMissionMinAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    missionId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type MemberMissionMaxAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    missionId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type MemberMissionCountAggregateOutputType = {
    id: number
    memberId: number
    missionId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type MemberMissionAvgAggregateInputType = {
    id?: true
    memberId?: true
    missionId?: true
    status?: true
  }

  export type MemberMissionSumAggregateInputType = {
    id?: true
    memberId?: true
    missionId?: true
    status?: true
  }

  export type MemberMissionMinAggregateInputType = {
    id?: true
    memberId?: true
    missionId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type MemberMissionMaxAggregateInputType = {
    id?: true
    memberId?: true
    missionId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type MemberMissionCountAggregateInputType = {
    id?: true
    memberId?: true
    missionId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type MemberMissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberMission to aggregate.
     */
    where?: MemberMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberMissions to fetch.
     */
    orderBy?: MemberMissionOrderByWithRelationInput | MemberMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberMissions
    **/
    _count?: true | MemberMissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberMissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberMissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMissionMaxAggregateInputType
  }

  export type GetMemberMissionAggregateType<T extends MemberMissionAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberMission[P]>
      : GetScalarType<T[P], AggregateMemberMission[P]>
  }




  export type MemberMissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberMissionWhereInput
    orderBy?: MemberMissionOrderByWithAggregationInput | MemberMissionOrderByWithAggregationInput[]
    by: MemberMissionScalarFieldEnum[] | MemberMissionScalarFieldEnum
    having?: MemberMissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberMissionCountAggregateInputType | true
    _avg?: MemberMissionAvgAggregateInputType
    _sum?: MemberMissionSumAggregateInputType
    _min?: MemberMissionMinAggregateInputType
    _max?: MemberMissionMaxAggregateInputType
  }

  export type MemberMissionGroupByOutputType = {
    id: bigint
    memberId: bigint
    missionId: bigint
    createdAt: Date
    updatedAt: Date
    status: number
    _count: MemberMissionCountAggregateOutputType | null
    _avg: MemberMissionAvgAggregateOutputType | null
    _sum: MemberMissionSumAggregateOutputType | null
    _min: MemberMissionMinAggregateOutputType | null
    _max: MemberMissionMaxAggregateOutputType | null
  }

  type GetMemberMissionGroupByPayload<T extends MemberMissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberMissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberMissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberMissionGroupByOutputType[P]>
            : GetScalarType<T[P], MemberMissionGroupByOutputType[P]>
        }
      >
    >


  export type MemberMissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    missionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberMission"]>


  export type MemberMissionSelectScalar = {
    id?: boolean
    memberId?: boolean
    missionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type MemberMissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }

  export type $MemberMissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberMission"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      mission: Prisma.$MissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      memberId: bigint
      missionId: bigint
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["memberMission"]>
    composites: {}
  }

  type MemberMissionGetPayload<S extends boolean | null | undefined | MemberMissionDefaultArgs> = $Result.GetResult<Prisma.$MemberMissionPayload, S>

  type MemberMissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberMissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberMissionCountAggregateInputType | true
    }

  export interface MemberMissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberMission'], meta: { name: 'MemberMission' } }
    /**
     * Find zero or one MemberMission that matches the filter.
     * @param {MemberMissionFindUniqueArgs} args - Arguments to find a MemberMission
     * @example
     * // Get one MemberMission
     * const memberMission = await prisma.memberMission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberMissionFindUniqueArgs>(args: SelectSubset<T, MemberMissionFindUniqueArgs<ExtArgs>>): Prisma__MemberMissionClient<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MemberMission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MemberMissionFindUniqueOrThrowArgs} args - Arguments to find a MemberMission
     * @example
     * // Get one MemberMission
     * const memberMission = await prisma.memberMission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberMissionFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberMissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberMissionClient<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MemberMission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberMissionFindFirstArgs} args - Arguments to find a MemberMission
     * @example
     * // Get one MemberMission
     * const memberMission = await prisma.memberMission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberMissionFindFirstArgs>(args?: SelectSubset<T, MemberMissionFindFirstArgs<ExtArgs>>): Prisma__MemberMissionClient<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MemberMission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberMissionFindFirstOrThrowArgs} args - Arguments to find a MemberMission
     * @example
     * // Get one MemberMission
     * const memberMission = await prisma.memberMission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberMissionFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberMissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberMissionClient<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MemberMissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberMissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberMissions
     * const memberMissions = await prisma.memberMission.findMany()
     * 
     * // Get first 10 MemberMissions
     * const memberMissions = await prisma.memberMission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberMissionWithIdOnly = await prisma.memberMission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberMissionFindManyArgs>(args?: SelectSubset<T, MemberMissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MemberMission.
     * @param {MemberMissionCreateArgs} args - Arguments to create a MemberMission.
     * @example
     * // Create one MemberMission
     * const MemberMission = await prisma.memberMission.create({
     *   data: {
     *     // ... data to create a MemberMission
     *   }
     * })
     * 
     */
    create<T extends MemberMissionCreateArgs>(args: SelectSubset<T, MemberMissionCreateArgs<ExtArgs>>): Prisma__MemberMissionClient<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MemberMissions.
     * @param {MemberMissionCreateManyArgs} args - Arguments to create many MemberMissions.
     * @example
     * // Create many MemberMissions
     * const memberMission = await prisma.memberMission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberMissionCreateManyArgs>(args?: SelectSubset<T, MemberMissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MemberMission.
     * @param {MemberMissionDeleteArgs} args - Arguments to delete one MemberMission.
     * @example
     * // Delete one MemberMission
     * const MemberMission = await prisma.memberMission.delete({
     *   where: {
     *     // ... filter to delete one MemberMission
     *   }
     * })
     * 
     */
    delete<T extends MemberMissionDeleteArgs>(args: SelectSubset<T, MemberMissionDeleteArgs<ExtArgs>>): Prisma__MemberMissionClient<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MemberMission.
     * @param {MemberMissionUpdateArgs} args - Arguments to update one MemberMission.
     * @example
     * // Update one MemberMission
     * const memberMission = await prisma.memberMission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberMissionUpdateArgs>(args: SelectSubset<T, MemberMissionUpdateArgs<ExtArgs>>): Prisma__MemberMissionClient<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MemberMissions.
     * @param {MemberMissionDeleteManyArgs} args - Arguments to filter MemberMissions to delete.
     * @example
     * // Delete a few MemberMissions
     * const { count } = await prisma.memberMission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberMissionDeleteManyArgs>(args?: SelectSubset<T, MemberMissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberMissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberMissions
     * const memberMission = await prisma.memberMission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberMissionUpdateManyArgs>(args: SelectSubset<T, MemberMissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MemberMission.
     * @param {MemberMissionUpsertArgs} args - Arguments to update or create a MemberMission.
     * @example
     * // Update or create a MemberMission
     * const memberMission = await prisma.memberMission.upsert({
     *   create: {
     *     // ... data to create a MemberMission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberMission we want to update
     *   }
     * })
     */
    upsert<T extends MemberMissionUpsertArgs>(args: SelectSubset<T, MemberMissionUpsertArgs<ExtArgs>>): Prisma__MemberMissionClient<$Result.GetResult<Prisma.$MemberMissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MemberMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberMissionCountArgs} args - Arguments to filter MemberMissions to count.
     * @example
     * // Count the number of MemberMissions
     * const count = await prisma.memberMission.count({
     *   where: {
     *     // ... the filter for the MemberMissions we want to count
     *   }
     * })
    **/
    count<T extends MemberMissionCountArgs>(
      args?: Subset<T, MemberMissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberMissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberMissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberMissionAggregateArgs>(args: Subset<T, MemberMissionAggregateArgs>): Prisma.PrismaPromise<GetMemberMissionAggregateType<T>>

    /**
     * Group by MemberMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberMissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberMissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberMissionGroupByArgs['orderBy'] }
        : { orderBy?: MemberMissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberMissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberMission model
   */
  readonly fields: MemberMissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberMission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberMissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mission<T extends MissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MissionDefaultArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MemberMission model
   */ 
  interface MemberMissionFieldRefs {
    readonly id: FieldRef<"MemberMission", 'BigInt'>
    readonly memberId: FieldRef<"MemberMission", 'BigInt'>
    readonly missionId: FieldRef<"MemberMission", 'BigInt'>
    readonly createdAt: FieldRef<"MemberMission", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberMission", 'DateTime'>
    readonly status: FieldRef<"MemberMission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MemberMission findUnique
   */
  export type MemberMissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    /**
     * Filter, which MemberMission to fetch.
     */
    where: MemberMissionWhereUniqueInput
  }

  /**
   * MemberMission findUniqueOrThrow
   */
  export type MemberMissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    /**
     * Filter, which MemberMission to fetch.
     */
    where: MemberMissionWhereUniqueInput
  }

  /**
   * MemberMission findFirst
   */
  export type MemberMissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    /**
     * Filter, which MemberMission to fetch.
     */
    where?: MemberMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberMissions to fetch.
     */
    orderBy?: MemberMissionOrderByWithRelationInput | MemberMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberMissions.
     */
    cursor?: MemberMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberMissions.
     */
    distinct?: MemberMissionScalarFieldEnum | MemberMissionScalarFieldEnum[]
  }

  /**
   * MemberMission findFirstOrThrow
   */
  export type MemberMissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    /**
     * Filter, which MemberMission to fetch.
     */
    where?: MemberMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberMissions to fetch.
     */
    orderBy?: MemberMissionOrderByWithRelationInput | MemberMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberMissions.
     */
    cursor?: MemberMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberMissions.
     */
    distinct?: MemberMissionScalarFieldEnum | MemberMissionScalarFieldEnum[]
  }

  /**
   * MemberMission findMany
   */
  export type MemberMissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    /**
     * Filter, which MemberMissions to fetch.
     */
    where?: MemberMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberMissions to fetch.
     */
    orderBy?: MemberMissionOrderByWithRelationInput | MemberMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberMissions.
     */
    cursor?: MemberMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberMissions.
     */
    skip?: number
    distinct?: MemberMissionScalarFieldEnum | MemberMissionScalarFieldEnum[]
  }

  /**
   * MemberMission create
   */
  export type MemberMissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberMission.
     */
    data: XOR<MemberMissionCreateInput, MemberMissionUncheckedCreateInput>
  }

  /**
   * MemberMission createMany
   */
  export type MemberMissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberMissions.
     */
    data: MemberMissionCreateManyInput | MemberMissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MemberMission update
   */
  export type MemberMissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberMission.
     */
    data: XOR<MemberMissionUpdateInput, MemberMissionUncheckedUpdateInput>
    /**
     * Choose, which MemberMission to update.
     */
    where: MemberMissionWhereUniqueInput
  }

  /**
   * MemberMission updateMany
   */
  export type MemberMissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberMissions.
     */
    data: XOR<MemberMissionUpdateManyMutationInput, MemberMissionUncheckedUpdateManyInput>
    /**
     * Filter which MemberMissions to update
     */
    where?: MemberMissionWhereInput
  }

  /**
   * MemberMission upsert
   */
  export type MemberMissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberMission to update in case it exists.
     */
    where: MemberMissionWhereUniqueInput
    /**
     * In case the MemberMission found by the `where` argument doesn't exist, create a new MemberMission with this data.
     */
    create: XOR<MemberMissionCreateInput, MemberMissionUncheckedCreateInput>
    /**
     * In case the MemberMission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberMissionUpdateInput, MemberMissionUncheckedUpdateInput>
  }

  /**
   * MemberMission delete
   */
  export type MemberMissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
    /**
     * Filter which MemberMission to delete.
     */
    where: MemberMissionWhereUniqueInput
  }

  /**
   * MemberMission deleteMany
   */
  export type MemberMissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberMissions to delete
     */
    where?: MemberMissionWhereInput
  }

  /**
   * MemberMission without action
   */
  export type MemberMissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberMission
     */
    select?: MemberMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberMissionInclude<ExtArgs> | null
  }


  /**
   * Model FoodKindRestaurant
   */

  export type AggregateFoodKindRestaurant = {
    _count: FoodKindRestaurantCountAggregateOutputType | null
    _avg: FoodKindRestaurantAvgAggregateOutputType | null
    _sum: FoodKindRestaurantSumAggregateOutputType | null
    _min: FoodKindRestaurantMinAggregateOutputType | null
    _max: FoodKindRestaurantMaxAggregateOutputType | null
  }

  export type FoodKindRestaurantAvgAggregateOutputType = {
    id: number | null
    foodKindId: number | null
    restaurantId: number | null
    status: number | null
  }

  export type FoodKindRestaurantSumAggregateOutputType = {
    id: bigint | null
    foodKindId: bigint | null
    restaurantId: bigint | null
    status: number | null
  }

  export type FoodKindRestaurantMinAggregateOutputType = {
    id: bigint | null
    foodKindId: bigint | null
    restaurantId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type FoodKindRestaurantMaxAggregateOutputType = {
    id: bigint | null
    foodKindId: bigint | null
    restaurantId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type FoodKindRestaurantCountAggregateOutputType = {
    id: number
    foodKindId: number
    restaurantId: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type FoodKindRestaurantAvgAggregateInputType = {
    id?: true
    foodKindId?: true
    restaurantId?: true
    status?: true
  }

  export type FoodKindRestaurantSumAggregateInputType = {
    id?: true
    foodKindId?: true
    restaurantId?: true
    status?: true
  }

  export type FoodKindRestaurantMinAggregateInputType = {
    id?: true
    foodKindId?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type FoodKindRestaurantMaxAggregateInputType = {
    id?: true
    foodKindId?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type FoodKindRestaurantCountAggregateInputType = {
    id?: true
    foodKindId?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type FoodKindRestaurantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodKindRestaurant to aggregate.
     */
    where?: FoodKindRestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodKindRestaurants to fetch.
     */
    orderBy?: FoodKindRestaurantOrderByWithRelationInput | FoodKindRestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodKindRestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodKindRestaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodKindRestaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodKindRestaurants
    **/
    _count?: true | FoodKindRestaurantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodKindRestaurantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodKindRestaurantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodKindRestaurantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodKindRestaurantMaxAggregateInputType
  }

  export type GetFoodKindRestaurantAggregateType<T extends FoodKindRestaurantAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodKindRestaurant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodKindRestaurant[P]>
      : GetScalarType<T[P], AggregateFoodKindRestaurant[P]>
  }




  export type FoodKindRestaurantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodKindRestaurantWhereInput
    orderBy?: FoodKindRestaurantOrderByWithAggregationInput | FoodKindRestaurantOrderByWithAggregationInput[]
    by: FoodKindRestaurantScalarFieldEnum[] | FoodKindRestaurantScalarFieldEnum
    having?: FoodKindRestaurantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodKindRestaurantCountAggregateInputType | true
    _avg?: FoodKindRestaurantAvgAggregateInputType
    _sum?: FoodKindRestaurantSumAggregateInputType
    _min?: FoodKindRestaurantMinAggregateInputType
    _max?: FoodKindRestaurantMaxAggregateInputType
  }

  export type FoodKindRestaurantGroupByOutputType = {
    id: bigint
    foodKindId: bigint
    restaurantId: bigint
    createdAt: Date
    updatedAt: Date
    status: number
    _count: FoodKindRestaurantCountAggregateOutputType | null
    _avg: FoodKindRestaurantAvgAggregateOutputType | null
    _sum: FoodKindRestaurantSumAggregateOutputType | null
    _min: FoodKindRestaurantMinAggregateOutputType | null
    _max: FoodKindRestaurantMaxAggregateOutputType | null
  }

  type GetFoodKindRestaurantGroupByPayload<T extends FoodKindRestaurantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodKindRestaurantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodKindRestaurantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodKindRestaurantGroupByOutputType[P]>
            : GetScalarType<T[P], FoodKindRestaurantGroupByOutputType[P]>
        }
      >
    >


  export type FoodKindRestaurantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodKindId?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    foodKind?: boolean | FoodKindDefaultArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodKindRestaurant"]>


  export type FoodKindRestaurantSelectScalar = {
    id?: boolean
    foodKindId?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type FoodKindRestaurantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foodKind?: boolean | FoodKindDefaultArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }

  export type $FoodKindRestaurantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodKindRestaurant"
    objects: {
      foodKind: Prisma.$FoodKindPayload<ExtArgs>
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      foodKindId: bigint
      restaurantId: bigint
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["foodKindRestaurant"]>
    composites: {}
  }

  type FoodKindRestaurantGetPayload<S extends boolean | null | undefined | FoodKindRestaurantDefaultArgs> = $Result.GetResult<Prisma.$FoodKindRestaurantPayload, S>

  type FoodKindRestaurantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FoodKindRestaurantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoodKindRestaurantCountAggregateInputType | true
    }

  export interface FoodKindRestaurantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodKindRestaurant'], meta: { name: 'FoodKindRestaurant' } }
    /**
     * Find zero or one FoodKindRestaurant that matches the filter.
     * @param {FoodKindRestaurantFindUniqueArgs} args - Arguments to find a FoodKindRestaurant
     * @example
     * // Get one FoodKindRestaurant
     * const foodKindRestaurant = await prisma.foodKindRestaurant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodKindRestaurantFindUniqueArgs>(args: SelectSubset<T, FoodKindRestaurantFindUniqueArgs<ExtArgs>>): Prisma__FoodKindRestaurantClient<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FoodKindRestaurant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FoodKindRestaurantFindUniqueOrThrowArgs} args - Arguments to find a FoodKindRestaurant
     * @example
     * // Get one FoodKindRestaurant
     * const foodKindRestaurant = await prisma.foodKindRestaurant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodKindRestaurantFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodKindRestaurantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodKindRestaurantClient<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FoodKindRestaurant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindRestaurantFindFirstArgs} args - Arguments to find a FoodKindRestaurant
     * @example
     * // Get one FoodKindRestaurant
     * const foodKindRestaurant = await prisma.foodKindRestaurant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodKindRestaurantFindFirstArgs>(args?: SelectSubset<T, FoodKindRestaurantFindFirstArgs<ExtArgs>>): Prisma__FoodKindRestaurantClient<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FoodKindRestaurant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindRestaurantFindFirstOrThrowArgs} args - Arguments to find a FoodKindRestaurant
     * @example
     * // Get one FoodKindRestaurant
     * const foodKindRestaurant = await prisma.foodKindRestaurant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodKindRestaurantFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodKindRestaurantFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodKindRestaurantClient<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FoodKindRestaurants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindRestaurantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodKindRestaurants
     * const foodKindRestaurants = await prisma.foodKindRestaurant.findMany()
     * 
     * // Get first 10 FoodKindRestaurants
     * const foodKindRestaurants = await prisma.foodKindRestaurant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodKindRestaurantWithIdOnly = await prisma.foodKindRestaurant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodKindRestaurantFindManyArgs>(args?: SelectSubset<T, FoodKindRestaurantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FoodKindRestaurant.
     * @param {FoodKindRestaurantCreateArgs} args - Arguments to create a FoodKindRestaurant.
     * @example
     * // Create one FoodKindRestaurant
     * const FoodKindRestaurant = await prisma.foodKindRestaurant.create({
     *   data: {
     *     // ... data to create a FoodKindRestaurant
     *   }
     * })
     * 
     */
    create<T extends FoodKindRestaurantCreateArgs>(args: SelectSubset<T, FoodKindRestaurantCreateArgs<ExtArgs>>): Prisma__FoodKindRestaurantClient<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FoodKindRestaurants.
     * @param {FoodKindRestaurantCreateManyArgs} args - Arguments to create many FoodKindRestaurants.
     * @example
     * // Create many FoodKindRestaurants
     * const foodKindRestaurant = await prisma.foodKindRestaurant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodKindRestaurantCreateManyArgs>(args?: SelectSubset<T, FoodKindRestaurantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoodKindRestaurant.
     * @param {FoodKindRestaurantDeleteArgs} args - Arguments to delete one FoodKindRestaurant.
     * @example
     * // Delete one FoodKindRestaurant
     * const FoodKindRestaurant = await prisma.foodKindRestaurant.delete({
     *   where: {
     *     // ... filter to delete one FoodKindRestaurant
     *   }
     * })
     * 
     */
    delete<T extends FoodKindRestaurantDeleteArgs>(args: SelectSubset<T, FoodKindRestaurantDeleteArgs<ExtArgs>>): Prisma__FoodKindRestaurantClient<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FoodKindRestaurant.
     * @param {FoodKindRestaurantUpdateArgs} args - Arguments to update one FoodKindRestaurant.
     * @example
     * // Update one FoodKindRestaurant
     * const foodKindRestaurant = await prisma.foodKindRestaurant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodKindRestaurantUpdateArgs>(args: SelectSubset<T, FoodKindRestaurantUpdateArgs<ExtArgs>>): Prisma__FoodKindRestaurantClient<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FoodKindRestaurants.
     * @param {FoodKindRestaurantDeleteManyArgs} args - Arguments to filter FoodKindRestaurants to delete.
     * @example
     * // Delete a few FoodKindRestaurants
     * const { count } = await prisma.foodKindRestaurant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodKindRestaurantDeleteManyArgs>(args?: SelectSubset<T, FoodKindRestaurantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodKindRestaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindRestaurantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodKindRestaurants
     * const foodKindRestaurant = await prisma.foodKindRestaurant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodKindRestaurantUpdateManyArgs>(args: SelectSubset<T, FoodKindRestaurantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoodKindRestaurant.
     * @param {FoodKindRestaurantUpsertArgs} args - Arguments to update or create a FoodKindRestaurant.
     * @example
     * // Update or create a FoodKindRestaurant
     * const foodKindRestaurant = await prisma.foodKindRestaurant.upsert({
     *   create: {
     *     // ... data to create a FoodKindRestaurant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodKindRestaurant we want to update
     *   }
     * })
     */
    upsert<T extends FoodKindRestaurantUpsertArgs>(args: SelectSubset<T, FoodKindRestaurantUpsertArgs<ExtArgs>>): Prisma__FoodKindRestaurantClient<$Result.GetResult<Prisma.$FoodKindRestaurantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FoodKindRestaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindRestaurantCountArgs} args - Arguments to filter FoodKindRestaurants to count.
     * @example
     * // Count the number of FoodKindRestaurants
     * const count = await prisma.foodKindRestaurant.count({
     *   where: {
     *     // ... the filter for the FoodKindRestaurants we want to count
     *   }
     * })
    **/
    count<T extends FoodKindRestaurantCountArgs>(
      args?: Subset<T, FoodKindRestaurantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodKindRestaurantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodKindRestaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindRestaurantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodKindRestaurantAggregateArgs>(args: Subset<T, FoodKindRestaurantAggregateArgs>): Prisma.PrismaPromise<GetFoodKindRestaurantAggregateType<T>>

    /**
     * Group by FoodKindRestaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodKindRestaurantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodKindRestaurantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodKindRestaurantGroupByArgs['orderBy'] }
        : { orderBy?: FoodKindRestaurantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodKindRestaurantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodKindRestaurantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodKindRestaurant model
   */
  readonly fields: FoodKindRestaurantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodKindRestaurant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodKindRestaurantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foodKind<T extends FoodKindDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodKindDefaultArgs<ExtArgs>>): Prisma__FoodKindClient<$Result.GetResult<Prisma.$FoodKindPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodKindRestaurant model
   */ 
  interface FoodKindRestaurantFieldRefs {
    readonly id: FieldRef<"FoodKindRestaurant", 'BigInt'>
    readonly foodKindId: FieldRef<"FoodKindRestaurant", 'BigInt'>
    readonly restaurantId: FieldRef<"FoodKindRestaurant", 'BigInt'>
    readonly createdAt: FieldRef<"FoodKindRestaurant", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodKindRestaurant", 'DateTime'>
    readonly status: FieldRef<"FoodKindRestaurant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FoodKindRestaurant findUnique
   */
  export type FoodKindRestaurantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    /**
     * Filter, which FoodKindRestaurant to fetch.
     */
    where: FoodKindRestaurantWhereUniqueInput
  }

  /**
   * FoodKindRestaurant findUniqueOrThrow
   */
  export type FoodKindRestaurantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    /**
     * Filter, which FoodKindRestaurant to fetch.
     */
    where: FoodKindRestaurantWhereUniqueInput
  }

  /**
   * FoodKindRestaurant findFirst
   */
  export type FoodKindRestaurantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    /**
     * Filter, which FoodKindRestaurant to fetch.
     */
    where?: FoodKindRestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodKindRestaurants to fetch.
     */
    orderBy?: FoodKindRestaurantOrderByWithRelationInput | FoodKindRestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodKindRestaurants.
     */
    cursor?: FoodKindRestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodKindRestaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodKindRestaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodKindRestaurants.
     */
    distinct?: FoodKindRestaurantScalarFieldEnum | FoodKindRestaurantScalarFieldEnum[]
  }

  /**
   * FoodKindRestaurant findFirstOrThrow
   */
  export type FoodKindRestaurantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    /**
     * Filter, which FoodKindRestaurant to fetch.
     */
    where?: FoodKindRestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodKindRestaurants to fetch.
     */
    orderBy?: FoodKindRestaurantOrderByWithRelationInput | FoodKindRestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodKindRestaurants.
     */
    cursor?: FoodKindRestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodKindRestaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodKindRestaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodKindRestaurants.
     */
    distinct?: FoodKindRestaurantScalarFieldEnum | FoodKindRestaurantScalarFieldEnum[]
  }

  /**
   * FoodKindRestaurant findMany
   */
  export type FoodKindRestaurantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    /**
     * Filter, which FoodKindRestaurants to fetch.
     */
    where?: FoodKindRestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodKindRestaurants to fetch.
     */
    orderBy?: FoodKindRestaurantOrderByWithRelationInput | FoodKindRestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodKindRestaurants.
     */
    cursor?: FoodKindRestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodKindRestaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodKindRestaurants.
     */
    skip?: number
    distinct?: FoodKindRestaurantScalarFieldEnum | FoodKindRestaurantScalarFieldEnum[]
  }

  /**
   * FoodKindRestaurant create
   */
  export type FoodKindRestaurantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodKindRestaurant.
     */
    data: XOR<FoodKindRestaurantCreateInput, FoodKindRestaurantUncheckedCreateInput>
  }

  /**
   * FoodKindRestaurant createMany
   */
  export type FoodKindRestaurantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodKindRestaurants.
     */
    data: FoodKindRestaurantCreateManyInput | FoodKindRestaurantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodKindRestaurant update
   */
  export type FoodKindRestaurantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodKindRestaurant.
     */
    data: XOR<FoodKindRestaurantUpdateInput, FoodKindRestaurantUncheckedUpdateInput>
    /**
     * Choose, which FoodKindRestaurant to update.
     */
    where: FoodKindRestaurantWhereUniqueInput
  }

  /**
   * FoodKindRestaurant updateMany
   */
  export type FoodKindRestaurantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodKindRestaurants.
     */
    data: XOR<FoodKindRestaurantUpdateManyMutationInput, FoodKindRestaurantUncheckedUpdateManyInput>
    /**
     * Filter which FoodKindRestaurants to update
     */
    where?: FoodKindRestaurantWhereInput
  }

  /**
   * FoodKindRestaurant upsert
   */
  export type FoodKindRestaurantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodKindRestaurant to update in case it exists.
     */
    where: FoodKindRestaurantWhereUniqueInput
    /**
     * In case the FoodKindRestaurant found by the `where` argument doesn't exist, create a new FoodKindRestaurant with this data.
     */
    create: XOR<FoodKindRestaurantCreateInput, FoodKindRestaurantUncheckedCreateInput>
    /**
     * In case the FoodKindRestaurant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodKindRestaurantUpdateInput, FoodKindRestaurantUncheckedUpdateInput>
  }

  /**
   * FoodKindRestaurant delete
   */
  export type FoodKindRestaurantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
    /**
     * Filter which FoodKindRestaurant to delete.
     */
    where: FoodKindRestaurantWhereUniqueInput
  }

  /**
   * FoodKindRestaurant deleteMany
   */
  export type FoodKindRestaurantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodKindRestaurants to delete
     */
    where?: FoodKindRestaurantWhereInput
  }

  /**
   * FoodKindRestaurant without action
   */
  export type FoodKindRestaurantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodKindRestaurant
     */
    select?: FoodKindRestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodKindRestaurantInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    memberId: number | null
    restaurantId: number | null
    rating: Decimal | null
    status: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    restaurantId: bigint | null
    rating: Decimal | null
    status: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    restaurantId: bigint | null
    rating: Decimal | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    restaurantId: bigint | null
    rating: Decimal | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    memberId: number
    restaurantId: number
    rating: number
    content: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    memberId?: true
    restaurantId?: true
    rating?: true
    status?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    memberId?: true
    restaurantId?: true
    rating?: true
    status?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    memberId?: true
    restaurantId?: true
    rating?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    memberId?: true
    restaurantId?: true
    rating?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    memberId?: true
    restaurantId?: true
    rating?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: bigint
    memberId: bigint
    restaurantId: bigint
    rating: Decimal
    content: string
    createdAt: Date
    updatedAt: Date
    status: number
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    restaurantId?: boolean
    rating?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    replys?: boolean | Review$replysArgs<ExtArgs>
    images?: boolean | Review$imagesArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>


  export type ReviewSelectScalar = {
    id?: boolean
    memberId?: boolean
    restaurantId?: boolean
    rating?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    replys?: boolean | Review$replysArgs<ExtArgs>
    images?: boolean | Review$imagesArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
      replys: Prisma.$ReplyPayload<ExtArgs>[]
      images: Prisma.$ImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      memberId: bigint
      restaurantId: bigint
      rating: Prisma.Decimal
      content: string
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    replys<T extends Review$replysArgs<ExtArgs> = {}>(args?: Subset<T, Review$replysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findMany"> | Null>
    images<T extends Review$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Review$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'BigInt'>
    readonly memberId: FieldRef<"Review", 'BigInt'>
    readonly restaurantId: FieldRef<"Review", 'BigInt'>
    readonly rating: FieldRef<"Review", 'Decimal'>
    readonly content: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
    readonly status: FieldRef<"Review", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review.replys
   */
  export type Review$replysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    where?: ReplyWhereInput
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    cursor?: ReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }

  /**
   * Review.images
   */
  export type Review$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Reply
   */

  export type AggregateReply = {
    _count: ReplyCountAggregateOutputType | null
    _avg: ReplyAvgAggregateOutputType | null
    _sum: ReplySumAggregateOutputType | null
    _min: ReplyMinAggregateOutputType | null
    _max: ReplyMaxAggregateOutputType | null
  }

  export type ReplyAvgAggregateOutputType = {
    id: number | null
    memberId: number | null
    reviewId: number | null
    status: number | null
  }

  export type ReplySumAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    reviewId: bigint | null
    status: number | null
  }

  export type ReplyMinAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    reviewId: bigint | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type ReplyMaxAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    reviewId: bigint | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type ReplyCountAggregateOutputType = {
    id: number
    memberId: number
    reviewId: number
    content: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type ReplyAvgAggregateInputType = {
    id?: true
    memberId?: true
    reviewId?: true
    status?: true
  }

  export type ReplySumAggregateInputType = {
    id?: true
    memberId?: true
    reviewId?: true
    status?: true
  }

  export type ReplyMinAggregateInputType = {
    id?: true
    memberId?: true
    reviewId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ReplyMaxAggregateInputType = {
    id?: true
    memberId?: true
    reviewId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ReplyCountAggregateInputType = {
    id?: true
    memberId?: true
    reviewId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type ReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reply to aggregate.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Replies
    **/
    _count?: true | ReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReplyMaxAggregateInputType
  }

  export type GetReplyAggregateType<T extends ReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReply[P]>
      : GetScalarType<T[P], AggregateReply[P]>
  }




  export type ReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyWhereInput
    orderBy?: ReplyOrderByWithAggregationInput | ReplyOrderByWithAggregationInput[]
    by: ReplyScalarFieldEnum[] | ReplyScalarFieldEnum
    having?: ReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReplyCountAggregateInputType | true
    _avg?: ReplyAvgAggregateInputType
    _sum?: ReplySumAggregateInputType
    _min?: ReplyMinAggregateInputType
    _max?: ReplyMaxAggregateInputType
  }

  export type ReplyGroupByOutputType = {
    id: bigint
    memberId: bigint
    reviewId: bigint
    content: string
    createdAt: Date
    updatedAt: Date
    status: number
    _count: ReplyCountAggregateOutputType | null
    _avg: ReplyAvgAggregateOutputType | null
    _sum: ReplySumAggregateOutputType | null
    _min: ReplyMinAggregateOutputType | null
    _max: ReplyMaxAggregateOutputType | null
  }

  type GetReplyGroupByPayload<T extends ReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReplyGroupByOutputType[P]>
            : GetScalarType<T[P], ReplyGroupByOutputType[P]>
        }
      >
    >


  export type ReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    reviewId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reply"]>


  export type ReplySelectScalar = {
    id?: boolean
    memberId?: boolean
    reviewId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type ReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }

  export type $ReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reply"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      review: Prisma.$ReviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      memberId: bigint
      reviewId: bigint
      content: string
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["reply"]>
    composites: {}
  }

  type ReplyGetPayload<S extends boolean | null | undefined | ReplyDefaultArgs> = $Result.GetResult<Prisma.$ReplyPayload, S>

  type ReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReplyCountAggregateInputType | true
    }

  export interface ReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reply'], meta: { name: 'Reply' } }
    /**
     * Find zero or one Reply that matches the filter.
     * @param {ReplyFindUniqueArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReplyFindUniqueArgs>(args: SelectSubset<T, ReplyFindUniqueArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reply that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReplyFindUniqueOrThrowArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, ReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindFirstArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReplyFindFirstArgs>(args?: SelectSubset<T, ReplyFindFirstArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindFirstOrThrowArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, ReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Replies
     * const replies = await prisma.reply.findMany()
     * 
     * // Get first 10 Replies
     * const replies = await prisma.reply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const replyWithIdOnly = await prisma.reply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReplyFindManyArgs>(args?: SelectSubset<T, ReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reply.
     * @param {ReplyCreateArgs} args - Arguments to create a Reply.
     * @example
     * // Create one Reply
     * const Reply = await prisma.reply.create({
     *   data: {
     *     // ... data to create a Reply
     *   }
     * })
     * 
     */
    create<T extends ReplyCreateArgs>(args: SelectSubset<T, ReplyCreateArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Replies.
     * @param {ReplyCreateManyArgs} args - Arguments to create many Replies.
     * @example
     * // Create many Replies
     * const reply = await prisma.reply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReplyCreateManyArgs>(args?: SelectSubset<T, ReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reply.
     * @param {ReplyDeleteArgs} args - Arguments to delete one Reply.
     * @example
     * // Delete one Reply
     * const Reply = await prisma.reply.delete({
     *   where: {
     *     // ... filter to delete one Reply
     *   }
     * })
     * 
     */
    delete<T extends ReplyDeleteArgs>(args: SelectSubset<T, ReplyDeleteArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reply.
     * @param {ReplyUpdateArgs} args - Arguments to update one Reply.
     * @example
     * // Update one Reply
     * const reply = await prisma.reply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReplyUpdateArgs>(args: SelectSubset<T, ReplyUpdateArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Replies.
     * @param {ReplyDeleteManyArgs} args - Arguments to filter Replies to delete.
     * @example
     * // Delete a few Replies
     * const { count } = await prisma.reply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReplyDeleteManyArgs>(args?: SelectSubset<T, ReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Replies
     * const reply = await prisma.reply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReplyUpdateManyArgs>(args: SelectSubset<T, ReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reply.
     * @param {ReplyUpsertArgs} args - Arguments to update or create a Reply.
     * @example
     * // Update or create a Reply
     * const reply = await prisma.reply.upsert({
     *   create: {
     *     // ... data to create a Reply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reply we want to update
     *   }
     * })
     */
    upsert<T extends ReplyUpsertArgs>(args: SelectSubset<T, ReplyUpsertArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCountArgs} args - Arguments to filter Replies to count.
     * @example
     * // Count the number of Replies
     * const count = await prisma.reply.count({
     *   where: {
     *     // ... the filter for the Replies we want to count
     *   }
     * })
    **/
    count<T extends ReplyCountArgs>(
      args?: Subset<T, ReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReplyAggregateArgs>(args: Subset<T, ReplyAggregateArgs>): Prisma.PrismaPromise<GetReplyAggregateType<T>>

    /**
     * Group by Reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReplyGroupByArgs['orderBy'] }
        : { orderBy?: ReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reply model
   */
  readonly fields: ReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reply model
   */ 
  interface ReplyFieldRefs {
    readonly id: FieldRef<"Reply", 'BigInt'>
    readonly memberId: FieldRef<"Reply", 'BigInt'>
    readonly reviewId: FieldRef<"Reply", 'BigInt'>
    readonly content: FieldRef<"Reply", 'String'>
    readonly createdAt: FieldRef<"Reply", 'DateTime'>
    readonly updatedAt: FieldRef<"Reply", 'DateTime'>
    readonly status: FieldRef<"Reply", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Reply findUnique
   */
  export type ReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where: ReplyWhereUniqueInput
  }

  /**
   * Reply findUniqueOrThrow
   */
  export type ReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where: ReplyWhereUniqueInput
  }

  /**
   * Reply findFirst
   */
  export type ReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Replies.
     */
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }

  /**
   * Reply findFirstOrThrow
   */
  export type ReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Replies.
     */
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }

  /**
   * Reply findMany
   */
  export type ReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Replies to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }

  /**
   * Reply create
   */
  export type ReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a Reply.
     */
    data: XOR<ReplyCreateInput, ReplyUncheckedCreateInput>
  }

  /**
   * Reply createMany
   */
  export type ReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Replies.
     */
    data: ReplyCreateManyInput | ReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reply update
   */
  export type ReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a Reply.
     */
    data: XOR<ReplyUpdateInput, ReplyUncheckedUpdateInput>
    /**
     * Choose, which Reply to update.
     */
    where: ReplyWhereUniqueInput
  }

  /**
   * Reply updateMany
   */
  export type ReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Replies.
     */
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyInput>
    /**
     * Filter which Replies to update
     */
    where?: ReplyWhereInput
  }

  /**
   * Reply upsert
   */
  export type ReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the Reply to update in case it exists.
     */
    where: ReplyWhereUniqueInput
    /**
     * In case the Reply found by the `where` argument doesn't exist, create a new Reply with this data.
     */
    create: XOR<ReplyCreateInput, ReplyUncheckedCreateInput>
    /**
     * In case the Reply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReplyUpdateInput, ReplyUncheckedUpdateInput>
  }

  /**
   * Reply delete
   */
  export type ReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter which Reply to delete.
     */
    where: ReplyWhereUniqueInput
  }

  /**
   * Reply deleteMany
   */
  export type ReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Replies to delete
     */
    where?: ReplyWhereInput
  }

  /**
   * Reply without action
   */
  export type ReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
  }


  /**
   * Model Inquiry
   */

  export type AggregateInquiry = {
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  export type InquiryAvgAggregateOutputType = {
    id: number | null
    memberId: number | null
    isConfirmed: number | null
    status: number | null
  }

  export type InquirySumAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    isConfirmed: number | null
    status: number | null
  }

  export type InquiryMinAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    title: string | null
    content: string | null
    isConfirmed: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type InquiryMaxAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    title: string | null
    content: string | null
    isConfirmed: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type InquiryCountAggregateOutputType = {
    id: number
    memberId: number
    title: number
    content: number
    isConfirmed: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type InquiryAvgAggregateInputType = {
    id?: true
    memberId?: true
    isConfirmed?: true
    status?: true
  }

  export type InquirySumAggregateInputType = {
    id?: true
    memberId?: true
    isConfirmed?: true
    status?: true
  }

  export type InquiryMinAggregateInputType = {
    id?: true
    memberId?: true
    title?: true
    content?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type InquiryMaxAggregateInputType = {
    id?: true
    memberId?: true
    title?: true
    content?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type InquiryCountAggregateInputType = {
    id?: true
    memberId?: true
    title?: true
    content?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type InquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiry to aggregate.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inquiries
    **/
    _count?: true | InquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMaxAggregateInputType
  }

  export type GetInquiryAggregateType<T extends InquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiry[P]>
      : GetScalarType<T[P], AggregateInquiry[P]>
  }




  export type InquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithAggregationInput | InquiryOrderByWithAggregationInput[]
    by: InquiryScalarFieldEnum[] | InquiryScalarFieldEnum
    having?: InquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryCountAggregateInputType | true
    _avg?: InquiryAvgAggregateInputType
    _sum?: InquirySumAggregateInputType
    _min?: InquiryMinAggregateInputType
    _max?: InquiryMaxAggregateInputType
  }

  export type InquiryGroupByOutputType = {
    id: bigint
    memberId: bigint
    title: string
    content: string
    isConfirmed: number
    createdAt: Date
    updatedAt: Date
    status: number
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  type GetInquiryGroupByPayload<T extends InquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryGroupByOutputType[P]>
        }
      >
    >


  export type InquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    title?: boolean
    content?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    images?: boolean | Inquiry$imagesArgs<ExtArgs>
    _count?: boolean | InquiryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>


  export type InquirySelectScalar = {
    id?: boolean
    memberId?: boolean
    title?: boolean
    content?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type InquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    images?: boolean | Inquiry$imagesArgs<ExtArgs>
    _count?: boolean | InquiryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inquiry"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      images: Prisma.$ImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      memberId: bigint
      title: string
      content: string
      isConfirmed: number
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["inquiry"]>
    composites: {}
  }

  type InquiryGetPayload<S extends boolean | null | undefined | InquiryDefaultArgs> = $Result.GetResult<Prisma.$InquiryPayload, S>

  type InquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InquiryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InquiryCountAggregateInputType | true
    }

  export interface InquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inquiry'], meta: { name: 'Inquiry' } }
    /**
     * Find zero or one Inquiry that matches the filter.
     * @param {InquiryFindUniqueArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryFindUniqueArgs>(args: SelectSubset<T, InquiryFindUniqueArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inquiry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InquiryFindUniqueOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryFindFirstArgs>(args?: SelectSubset<T, InquiryFindFirstArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inquiries
     * const inquiries = await prisma.inquiry.findMany()
     * 
     * // Get first 10 Inquiries
     * const inquiries = await prisma.inquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryFindManyArgs>(args?: SelectSubset<T, InquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inquiry.
     * @param {InquiryCreateArgs} args - Arguments to create a Inquiry.
     * @example
     * // Create one Inquiry
     * const Inquiry = await prisma.inquiry.create({
     *   data: {
     *     // ... data to create a Inquiry
     *   }
     * })
     * 
     */
    create<T extends InquiryCreateArgs>(args: SelectSubset<T, InquiryCreateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inquiries.
     * @param {InquiryCreateManyArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryCreateManyArgs>(args?: SelectSubset<T, InquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inquiry.
     * @param {InquiryDeleteArgs} args - Arguments to delete one Inquiry.
     * @example
     * // Delete one Inquiry
     * const Inquiry = await prisma.inquiry.delete({
     *   where: {
     *     // ... filter to delete one Inquiry
     *   }
     * })
     * 
     */
    delete<T extends InquiryDeleteArgs>(args: SelectSubset<T, InquiryDeleteArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inquiry.
     * @param {InquiryUpdateArgs} args - Arguments to update one Inquiry.
     * @example
     * // Update one Inquiry
     * const inquiry = await prisma.inquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryUpdateArgs>(args: SelectSubset<T, InquiryUpdateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inquiries.
     * @param {InquiryDeleteManyArgs} args - Arguments to filter Inquiries to delete.
     * @example
     * // Delete a few Inquiries
     * const { count } = await prisma.inquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryDeleteManyArgs>(args?: SelectSubset<T, InquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryUpdateManyArgs>(args: SelectSubset<T, InquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inquiry.
     * @param {InquiryUpsertArgs} args - Arguments to update or create a Inquiry.
     * @example
     * // Update or create a Inquiry
     * const inquiry = await prisma.inquiry.upsert({
     *   create: {
     *     // ... data to create a Inquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inquiry we want to update
     *   }
     * })
     */
    upsert<T extends InquiryUpsertArgs>(args: SelectSubset<T, InquiryUpsertArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryCountArgs} args - Arguments to filter Inquiries to count.
     * @example
     * // Count the number of Inquiries
     * const count = await prisma.inquiry.count({
     *   where: {
     *     // ... the filter for the Inquiries we want to count
     *   }
     * })
    **/
    count<T extends InquiryCountArgs>(
      args?: Subset<T, InquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryAggregateArgs>(args: Subset<T, InquiryAggregateArgs>): Prisma.PrismaPromise<GetInquiryAggregateType<T>>

    /**
     * Group by Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryGroupByArgs['orderBy'] }
        : { orderBy?: InquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inquiry model
   */
  readonly fields: InquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    images<T extends Inquiry$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Inquiry$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inquiry model
   */ 
  interface InquiryFieldRefs {
    readonly id: FieldRef<"Inquiry", 'BigInt'>
    readonly memberId: FieldRef<"Inquiry", 'BigInt'>
    readonly title: FieldRef<"Inquiry", 'String'>
    readonly content: FieldRef<"Inquiry", 'String'>
    readonly isConfirmed: FieldRef<"Inquiry", 'Int'>
    readonly createdAt: FieldRef<"Inquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"Inquiry", 'DateTime'>
    readonly status: FieldRef<"Inquiry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Inquiry findUnique
   */
  export type InquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findUniqueOrThrow
   */
  export type InquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findFirst
   */
  export type InquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findFirstOrThrow
   */
  export type InquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findMany
   */
  export type InquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiries to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry create
   */
  export type InquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inquiry.
     */
    data: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
  }

  /**
   * Inquiry createMany
   */
  export type InquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inquiry update
   */
  export type InquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inquiry.
     */
    data: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
    /**
     * Choose, which Inquiry to update.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry updateMany
   */
  export type InquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
  }

  /**
   * Inquiry upsert
   */
  export type InquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inquiry to update in case it exists.
     */
    where: InquiryWhereUniqueInput
    /**
     * In case the Inquiry found by the `where` argument doesn't exist, create a new Inquiry with this data.
     */
    create: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
    /**
     * In case the Inquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
  }

  /**
   * Inquiry delete
   */
  export type InquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter which Inquiry to delete.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry deleteMany
   */
  export type InquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiries to delete
     */
    where?: InquiryWhereInput
  }

  /**
   * Inquiry.images
   */
  export type Inquiry$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Inquiry without action
   */
  export type InquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
    restaurantId: number | null
    reviewId: number | null
    inquiryId: number | null
    status: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: bigint | null
    restaurantId: bigint | null
    reviewId: bigint | null
    inquiryId: bigint | null
    status: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: bigint | null
    restaurantId: bigint | null
    reviewId: bigint | null
    inquiryId: bigint | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type ImageMaxAggregateOutputType = {
    id: bigint | null
    restaurantId: bigint | null
    reviewId: bigint | null
    inquiryId: bigint | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    restaurantId: number
    reviewId: number
    inquiryId: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    restaurantId?: true
    reviewId?: true
    inquiryId?: true
    status?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    restaurantId?: true
    reviewId?: true
    inquiryId?: true
    status?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    restaurantId?: true
    reviewId?: true
    inquiryId?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    restaurantId?: true
    reviewId?: true
    inquiryId?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    restaurantId?: true
    reviewId?: true
    inquiryId?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: bigint
    restaurantId: bigint | null
    reviewId: bigint | null
    inquiryId: bigint | null
    imageUrl: string
    createdAt: Date
    updatedAt: Date
    status: number
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    restaurantId?: boolean
    reviewId?: boolean
    inquiryId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    restaurant?: boolean | Image$restaurantArgs<ExtArgs>
    review?: boolean | Image$reviewArgs<ExtArgs>
    inquiry?: boolean | Image$inquiryArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>


  export type ImageSelectScalar = {
    id?: boolean
    restaurantId?: boolean
    reviewId?: boolean
    inquiryId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | Image$restaurantArgs<ExtArgs>
    review?: boolean | Image$reviewArgs<ExtArgs>
    inquiry?: boolean | Image$inquiryArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs> | null
      review: Prisma.$ReviewPayload<ExtArgs> | null
      inquiry: Prisma.$InquiryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      restaurantId: bigint | null
      reviewId: bigint | null
      inquiryId: bigint | null
      imageUrl: string
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends Image$restaurantArgs<ExtArgs> = {}>(args?: Subset<T, Image$restaurantArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    review<T extends Image$reviewArgs<ExtArgs> = {}>(args?: Subset<T, Image$reviewArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inquiry<T extends Image$inquiryArgs<ExtArgs> = {}>(args?: Subset<T, Image$inquiryArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */ 
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'BigInt'>
    readonly restaurantId: FieldRef<"Image", 'BigInt'>
    readonly reviewId: FieldRef<"Image", 'BigInt'>
    readonly inquiryId: FieldRef<"Image", 'BigInt'>
    readonly imageUrl: FieldRef<"Image", 'String'>
    readonly createdAt: FieldRef<"Image", 'DateTime'>
    readonly updatedAt: FieldRef<"Image", 'DateTime'>
    readonly status: FieldRef<"Image", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
  }

  /**
   * Image.restaurant
   */
  export type Image$restaurantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    where?: RestaurantWhereInput
  }

  /**
   * Image.review
   */
  export type Image$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
  }

  /**
   * Image.inquiry
   */
  export type Image$inquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model Alarm
   */

  export type AggregateAlarm = {
    _count: AlarmCountAggregateOutputType | null
    _avg: AlarmAvgAggregateOutputType | null
    _sum: AlarmSumAggregateOutputType | null
    _min: AlarmMinAggregateOutputType | null
    _max: AlarmMaxAggregateOutputType | null
  }

  export type AlarmAvgAggregateOutputType = {
    id: number | null
    memberId: number | null
    isConfirmed: number | null
    status: number | null
  }

  export type AlarmSumAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    isConfirmed: number | null
    status: number | null
  }

  export type AlarmMinAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    isConfirmed: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type AlarmMaxAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    isConfirmed: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type AlarmCountAggregateOutputType = {
    id: number
    memberId: number
    isConfirmed: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type AlarmAvgAggregateInputType = {
    id?: true
    memberId?: true
    isConfirmed?: true
    status?: true
  }

  export type AlarmSumAggregateInputType = {
    id?: true
    memberId?: true
    isConfirmed?: true
    status?: true
  }

  export type AlarmMinAggregateInputType = {
    id?: true
    memberId?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AlarmMaxAggregateInputType = {
    id?: true
    memberId?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AlarmCountAggregateInputType = {
    id?: true
    memberId?: true
    isConfirmed?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type AlarmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alarm to aggregate.
     */
    where?: AlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alarms to fetch.
     */
    orderBy?: AlarmOrderByWithRelationInput | AlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alarms
    **/
    _count?: true | AlarmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlarmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlarmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlarmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlarmMaxAggregateInputType
  }

  export type GetAlarmAggregateType<T extends AlarmAggregateArgs> = {
        [P in keyof T & keyof AggregateAlarm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlarm[P]>
      : GetScalarType<T[P], AggregateAlarm[P]>
  }




  export type AlarmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlarmWhereInput
    orderBy?: AlarmOrderByWithAggregationInput | AlarmOrderByWithAggregationInput[]
    by: AlarmScalarFieldEnum[] | AlarmScalarFieldEnum
    having?: AlarmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlarmCountAggregateInputType | true
    _avg?: AlarmAvgAggregateInputType
    _sum?: AlarmSumAggregateInputType
    _min?: AlarmMinAggregateInputType
    _max?: AlarmMaxAggregateInputType
  }

  export type AlarmGroupByOutputType = {
    id: bigint
    memberId: bigint
    isConfirmed: number
    createdAt: Date
    updatedAt: Date
    status: number
    _count: AlarmCountAggregateOutputType | null
    _avg: AlarmAvgAggregateOutputType | null
    _sum: AlarmSumAggregateOutputType | null
    _min: AlarmMinAggregateOutputType | null
    _max: AlarmMaxAggregateOutputType | null
  }

  type GetAlarmGroupByPayload<T extends AlarmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlarmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlarmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlarmGroupByOutputType[P]>
            : GetScalarType<T[P], AlarmGroupByOutputType[P]>
        }
      >
    >


  export type AlarmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberId?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    alarmsNewMissions?: boolean | Alarm$alarmsNewMissionsArgs<ExtArgs>
    alarmReviewRequest?: boolean | Alarm$alarmReviewRequestArgs<ExtArgs>
    _count?: boolean | AlarmCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alarm"]>


  export type AlarmSelectScalar = {
    id?: boolean
    memberId?: boolean
    isConfirmed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type AlarmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    alarmsNewMissions?: boolean | Alarm$alarmsNewMissionsArgs<ExtArgs>
    alarmReviewRequest?: boolean | Alarm$alarmReviewRequestArgs<ExtArgs>
    _count?: boolean | AlarmCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AlarmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alarm"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      alarmsNewMissions: Prisma.$AlarmNewMissionPayload<ExtArgs>[]
      alarmReviewRequest: Prisma.$AlarmReviewRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      memberId: bigint
      isConfirmed: number
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["alarm"]>
    composites: {}
  }

  type AlarmGetPayload<S extends boolean | null | undefined | AlarmDefaultArgs> = $Result.GetResult<Prisma.$AlarmPayload, S>

  type AlarmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlarmFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlarmCountAggregateInputType | true
    }

  export interface AlarmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alarm'], meta: { name: 'Alarm' } }
    /**
     * Find zero or one Alarm that matches the filter.
     * @param {AlarmFindUniqueArgs} args - Arguments to find a Alarm
     * @example
     * // Get one Alarm
     * const alarm = await prisma.alarm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlarmFindUniqueArgs>(args: SelectSubset<T, AlarmFindUniqueArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alarm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlarmFindUniqueOrThrowArgs} args - Arguments to find a Alarm
     * @example
     * // Get one Alarm
     * const alarm = await prisma.alarm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlarmFindUniqueOrThrowArgs>(args: SelectSubset<T, AlarmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alarm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmFindFirstArgs} args - Arguments to find a Alarm
     * @example
     * // Get one Alarm
     * const alarm = await prisma.alarm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlarmFindFirstArgs>(args?: SelectSubset<T, AlarmFindFirstArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alarm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmFindFirstOrThrowArgs} args - Arguments to find a Alarm
     * @example
     * // Get one Alarm
     * const alarm = await prisma.alarm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlarmFindFirstOrThrowArgs>(args?: SelectSubset<T, AlarmFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alarms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alarms
     * const alarms = await prisma.alarm.findMany()
     * 
     * // Get first 10 Alarms
     * const alarms = await prisma.alarm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alarmWithIdOnly = await prisma.alarm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlarmFindManyArgs>(args?: SelectSubset<T, AlarmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alarm.
     * @param {AlarmCreateArgs} args - Arguments to create a Alarm.
     * @example
     * // Create one Alarm
     * const Alarm = await prisma.alarm.create({
     *   data: {
     *     // ... data to create a Alarm
     *   }
     * })
     * 
     */
    create<T extends AlarmCreateArgs>(args: SelectSubset<T, AlarmCreateArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alarms.
     * @param {AlarmCreateManyArgs} args - Arguments to create many Alarms.
     * @example
     * // Create many Alarms
     * const alarm = await prisma.alarm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlarmCreateManyArgs>(args?: SelectSubset<T, AlarmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alarm.
     * @param {AlarmDeleteArgs} args - Arguments to delete one Alarm.
     * @example
     * // Delete one Alarm
     * const Alarm = await prisma.alarm.delete({
     *   where: {
     *     // ... filter to delete one Alarm
     *   }
     * })
     * 
     */
    delete<T extends AlarmDeleteArgs>(args: SelectSubset<T, AlarmDeleteArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alarm.
     * @param {AlarmUpdateArgs} args - Arguments to update one Alarm.
     * @example
     * // Update one Alarm
     * const alarm = await prisma.alarm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlarmUpdateArgs>(args: SelectSubset<T, AlarmUpdateArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alarms.
     * @param {AlarmDeleteManyArgs} args - Arguments to filter Alarms to delete.
     * @example
     * // Delete a few Alarms
     * const { count } = await prisma.alarm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlarmDeleteManyArgs>(args?: SelectSubset<T, AlarmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alarms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alarms
     * const alarm = await prisma.alarm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlarmUpdateManyArgs>(args: SelectSubset<T, AlarmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alarm.
     * @param {AlarmUpsertArgs} args - Arguments to update or create a Alarm.
     * @example
     * // Update or create a Alarm
     * const alarm = await prisma.alarm.upsert({
     *   create: {
     *     // ... data to create a Alarm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alarm we want to update
     *   }
     * })
     */
    upsert<T extends AlarmUpsertArgs>(args: SelectSubset<T, AlarmUpsertArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alarms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmCountArgs} args - Arguments to filter Alarms to count.
     * @example
     * // Count the number of Alarms
     * const count = await prisma.alarm.count({
     *   where: {
     *     // ... the filter for the Alarms we want to count
     *   }
     * })
    **/
    count<T extends AlarmCountArgs>(
      args?: Subset<T, AlarmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlarmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alarm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlarmAggregateArgs>(args: Subset<T, AlarmAggregateArgs>): Prisma.PrismaPromise<GetAlarmAggregateType<T>>

    /**
     * Group by Alarm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlarmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlarmGroupByArgs['orderBy'] }
        : { orderBy?: AlarmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlarmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlarmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alarm model
   */
  readonly fields: AlarmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alarm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlarmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    alarmsNewMissions<T extends Alarm$alarmsNewMissionsArgs<ExtArgs> = {}>(args?: Subset<T, Alarm$alarmsNewMissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "findMany"> | Null>
    alarmReviewRequest<T extends Alarm$alarmReviewRequestArgs<ExtArgs> = {}>(args?: Subset<T, Alarm$alarmReviewRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alarm model
   */ 
  interface AlarmFieldRefs {
    readonly id: FieldRef<"Alarm", 'BigInt'>
    readonly memberId: FieldRef<"Alarm", 'BigInt'>
    readonly isConfirmed: FieldRef<"Alarm", 'Int'>
    readonly createdAt: FieldRef<"Alarm", 'DateTime'>
    readonly updatedAt: FieldRef<"Alarm", 'DateTime'>
    readonly status: FieldRef<"Alarm", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Alarm findUnique
   */
  export type AlarmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    /**
     * Filter, which Alarm to fetch.
     */
    where: AlarmWhereUniqueInput
  }

  /**
   * Alarm findUniqueOrThrow
   */
  export type AlarmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    /**
     * Filter, which Alarm to fetch.
     */
    where: AlarmWhereUniqueInput
  }

  /**
   * Alarm findFirst
   */
  export type AlarmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    /**
     * Filter, which Alarm to fetch.
     */
    where?: AlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alarms to fetch.
     */
    orderBy?: AlarmOrderByWithRelationInput | AlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alarms.
     */
    cursor?: AlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alarms.
     */
    distinct?: AlarmScalarFieldEnum | AlarmScalarFieldEnum[]
  }

  /**
   * Alarm findFirstOrThrow
   */
  export type AlarmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    /**
     * Filter, which Alarm to fetch.
     */
    where?: AlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alarms to fetch.
     */
    orderBy?: AlarmOrderByWithRelationInput | AlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alarms.
     */
    cursor?: AlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alarms.
     */
    distinct?: AlarmScalarFieldEnum | AlarmScalarFieldEnum[]
  }

  /**
   * Alarm findMany
   */
  export type AlarmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    /**
     * Filter, which Alarms to fetch.
     */
    where?: AlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alarms to fetch.
     */
    orderBy?: AlarmOrderByWithRelationInput | AlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alarms.
     */
    cursor?: AlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alarms.
     */
    skip?: number
    distinct?: AlarmScalarFieldEnum | AlarmScalarFieldEnum[]
  }

  /**
   * Alarm create
   */
  export type AlarmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    /**
     * The data needed to create a Alarm.
     */
    data: XOR<AlarmCreateInput, AlarmUncheckedCreateInput>
  }

  /**
   * Alarm createMany
   */
  export type AlarmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alarms.
     */
    data: AlarmCreateManyInput | AlarmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alarm update
   */
  export type AlarmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    /**
     * The data needed to update a Alarm.
     */
    data: XOR<AlarmUpdateInput, AlarmUncheckedUpdateInput>
    /**
     * Choose, which Alarm to update.
     */
    where: AlarmWhereUniqueInput
  }

  /**
   * Alarm updateMany
   */
  export type AlarmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alarms.
     */
    data: XOR<AlarmUpdateManyMutationInput, AlarmUncheckedUpdateManyInput>
    /**
     * Filter which Alarms to update
     */
    where?: AlarmWhereInput
  }

  /**
   * Alarm upsert
   */
  export type AlarmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    /**
     * The filter to search for the Alarm to update in case it exists.
     */
    where: AlarmWhereUniqueInput
    /**
     * In case the Alarm found by the `where` argument doesn't exist, create a new Alarm with this data.
     */
    create: XOR<AlarmCreateInput, AlarmUncheckedCreateInput>
    /**
     * In case the Alarm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlarmUpdateInput, AlarmUncheckedUpdateInput>
  }

  /**
   * Alarm delete
   */
  export type AlarmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
    /**
     * Filter which Alarm to delete.
     */
    where: AlarmWhereUniqueInput
  }

  /**
   * Alarm deleteMany
   */
  export type AlarmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alarms to delete
     */
    where?: AlarmWhereInput
  }

  /**
   * Alarm.alarmsNewMissions
   */
  export type Alarm$alarmsNewMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    where?: AlarmNewMissionWhereInput
    orderBy?: AlarmNewMissionOrderByWithRelationInput | AlarmNewMissionOrderByWithRelationInput[]
    cursor?: AlarmNewMissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlarmNewMissionScalarFieldEnum | AlarmNewMissionScalarFieldEnum[]
  }

  /**
   * Alarm.alarmReviewRequest
   */
  export type Alarm$alarmReviewRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    where?: AlarmReviewRequestWhereInput
    orderBy?: AlarmReviewRequestOrderByWithRelationInput | AlarmReviewRequestOrderByWithRelationInput[]
    cursor?: AlarmReviewRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlarmReviewRequestScalarFieldEnum | AlarmReviewRequestScalarFieldEnum[]
  }

  /**
   * Alarm without action
   */
  export type AlarmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmInclude<ExtArgs> | null
  }


  /**
   * Model AlarmNewMission
   */

  export type AggregateAlarmNewMission = {
    _count: AlarmNewMissionCountAggregateOutputType | null
    _avg: AlarmNewMissionAvgAggregateOutputType | null
    _sum: AlarmNewMissionSumAggregateOutputType | null
    _min: AlarmNewMissionMinAggregateOutputType | null
    _max: AlarmNewMissionMaxAggregateOutputType | null
  }

  export type AlarmNewMissionAvgAggregateOutputType = {
    id: number | null
    alarmId: number | null
    status: number | null
  }

  export type AlarmNewMissionSumAggregateOutputType = {
    id: bigint | null
    alarmId: bigint | null
    status: number | null
  }

  export type AlarmNewMissionMinAggregateOutputType = {
    id: bigint | null
    alarmId: bigint | null
    title: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type AlarmNewMissionMaxAggregateOutputType = {
    id: bigint | null
    alarmId: bigint | null
    title: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type AlarmNewMissionCountAggregateOutputType = {
    id: number
    alarmId: number
    title: number
    body: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type AlarmNewMissionAvgAggregateInputType = {
    id?: true
    alarmId?: true
    status?: true
  }

  export type AlarmNewMissionSumAggregateInputType = {
    id?: true
    alarmId?: true
    status?: true
  }

  export type AlarmNewMissionMinAggregateInputType = {
    id?: true
    alarmId?: true
    title?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AlarmNewMissionMaxAggregateInputType = {
    id?: true
    alarmId?: true
    title?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AlarmNewMissionCountAggregateInputType = {
    id?: true
    alarmId?: true
    title?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type AlarmNewMissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlarmNewMission to aggregate.
     */
    where?: AlarmNewMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmNewMissions to fetch.
     */
    orderBy?: AlarmNewMissionOrderByWithRelationInput | AlarmNewMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlarmNewMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmNewMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmNewMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlarmNewMissions
    **/
    _count?: true | AlarmNewMissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlarmNewMissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlarmNewMissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlarmNewMissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlarmNewMissionMaxAggregateInputType
  }

  export type GetAlarmNewMissionAggregateType<T extends AlarmNewMissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAlarmNewMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlarmNewMission[P]>
      : GetScalarType<T[P], AggregateAlarmNewMission[P]>
  }




  export type AlarmNewMissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlarmNewMissionWhereInput
    orderBy?: AlarmNewMissionOrderByWithAggregationInput | AlarmNewMissionOrderByWithAggregationInput[]
    by: AlarmNewMissionScalarFieldEnum[] | AlarmNewMissionScalarFieldEnum
    having?: AlarmNewMissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlarmNewMissionCountAggregateInputType | true
    _avg?: AlarmNewMissionAvgAggregateInputType
    _sum?: AlarmNewMissionSumAggregateInputType
    _min?: AlarmNewMissionMinAggregateInputType
    _max?: AlarmNewMissionMaxAggregateInputType
  }

  export type AlarmNewMissionGroupByOutputType = {
    id: bigint
    alarmId: bigint
    title: string
    body: string
    createdAt: Date
    updatedAt: Date
    status: number
    _count: AlarmNewMissionCountAggregateOutputType | null
    _avg: AlarmNewMissionAvgAggregateOutputType | null
    _sum: AlarmNewMissionSumAggregateOutputType | null
    _min: AlarmNewMissionMinAggregateOutputType | null
    _max: AlarmNewMissionMaxAggregateOutputType | null
  }

  type GetAlarmNewMissionGroupByPayload<T extends AlarmNewMissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlarmNewMissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlarmNewMissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlarmNewMissionGroupByOutputType[P]>
            : GetScalarType<T[P], AlarmNewMissionGroupByOutputType[P]>
        }
      >
    >


  export type AlarmNewMissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alarmId?: boolean
    title?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    alarm?: boolean | AlarmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alarmNewMission"]>


  export type AlarmNewMissionSelectScalar = {
    id?: boolean
    alarmId?: boolean
    title?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type AlarmNewMissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alarm?: boolean | AlarmDefaultArgs<ExtArgs>
  }

  export type $AlarmNewMissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlarmNewMission"
    objects: {
      alarm: Prisma.$AlarmPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      alarmId: bigint
      title: string
      body: string
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["alarmNewMission"]>
    composites: {}
  }

  type AlarmNewMissionGetPayload<S extends boolean | null | undefined | AlarmNewMissionDefaultArgs> = $Result.GetResult<Prisma.$AlarmNewMissionPayload, S>

  type AlarmNewMissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlarmNewMissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlarmNewMissionCountAggregateInputType | true
    }

  export interface AlarmNewMissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlarmNewMission'], meta: { name: 'AlarmNewMission' } }
    /**
     * Find zero or one AlarmNewMission that matches the filter.
     * @param {AlarmNewMissionFindUniqueArgs} args - Arguments to find a AlarmNewMission
     * @example
     * // Get one AlarmNewMission
     * const alarmNewMission = await prisma.alarmNewMission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlarmNewMissionFindUniqueArgs>(args: SelectSubset<T, AlarmNewMissionFindUniqueArgs<ExtArgs>>): Prisma__AlarmNewMissionClient<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AlarmNewMission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlarmNewMissionFindUniqueOrThrowArgs} args - Arguments to find a AlarmNewMission
     * @example
     * // Get one AlarmNewMission
     * const alarmNewMission = await prisma.alarmNewMission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlarmNewMissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AlarmNewMissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlarmNewMissionClient<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AlarmNewMission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmNewMissionFindFirstArgs} args - Arguments to find a AlarmNewMission
     * @example
     * // Get one AlarmNewMission
     * const alarmNewMission = await prisma.alarmNewMission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlarmNewMissionFindFirstArgs>(args?: SelectSubset<T, AlarmNewMissionFindFirstArgs<ExtArgs>>): Prisma__AlarmNewMissionClient<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AlarmNewMission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmNewMissionFindFirstOrThrowArgs} args - Arguments to find a AlarmNewMission
     * @example
     * // Get one AlarmNewMission
     * const alarmNewMission = await prisma.alarmNewMission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlarmNewMissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AlarmNewMissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlarmNewMissionClient<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AlarmNewMissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmNewMissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlarmNewMissions
     * const alarmNewMissions = await prisma.alarmNewMission.findMany()
     * 
     * // Get first 10 AlarmNewMissions
     * const alarmNewMissions = await prisma.alarmNewMission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alarmNewMissionWithIdOnly = await prisma.alarmNewMission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlarmNewMissionFindManyArgs>(args?: SelectSubset<T, AlarmNewMissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AlarmNewMission.
     * @param {AlarmNewMissionCreateArgs} args - Arguments to create a AlarmNewMission.
     * @example
     * // Create one AlarmNewMission
     * const AlarmNewMission = await prisma.alarmNewMission.create({
     *   data: {
     *     // ... data to create a AlarmNewMission
     *   }
     * })
     * 
     */
    create<T extends AlarmNewMissionCreateArgs>(args: SelectSubset<T, AlarmNewMissionCreateArgs<ExtArgs>>): Prisma__AlarmNewMissionClient<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AlarmNewMissions.
     * @param {AlarmNewMissionCreateManyArgs} args - Arguments to create many AlarmNewMissions.
     * @example
     * // Create many AlarmNewMissions
     * const alarmNewMission = await prisma.alarmNewMission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlarmNewMissionCreateManyArgs>(args?: SelectSubset<T, AlarmNewMissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AlarmNewMission.
     * @param {AlarmNewMissionDeleteArgs} args - Arguments to delete one AlarmNewMission.
     * @example
     * // Delete one AlarmNewMission
     * const AlarmNewMission = await prisma.alarmNewMission.delete({
     *   where: {
     *     // ... filter to delete one AlarmNewMission
     *   }
     * })
     * 
     */
    delete<T extends AlarmNewMissionDeleteArgs>(args: SelectSubset<T, AlarmNewMissionDeleteArgs<ExtArgs>>): Prisma__AlarmNewMissionClient<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AlarmNewMission.
     * @param {AlarmNewMissionUpdateArgs} args - Arguments to update one AlarmNewMission.
     * @example
     * // Update one AlarmNewMission
     * const alarmNewMission = await prisma.alarmNewMission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlarmNewMissionUpdateArgs>(args: SelectSubset<T, AlarmNewMissionUpdateArgs<ExtArgs>>): Prisma__AlarmNewMissionClient<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AlarmNewMissions.
     * @param {AlarmNewMissionDeleteManyArgs} args - Arguments to filter AlarmNewMissions to delete.
     * @example
     * // Delete a few AlarmNewMissions
     * const { count } = await prisma.alarmNewMission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlarmNewMissionDeleteManyArgs>(args?: SelectSubset<T, AlarmNewMissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlarmNewMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmNewMissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlarmNewMissions
     * const alarmNewMission = await prisma.alarmNewMission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlarmNewMissionUpdateManyArgs>(args: SelectSubset<T, AlarmNewMissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlarmNewMission.
     * @param {AlarmNewMissionUpsertArgs} args - Arguments to update or create a AlarmNewMission.
     * @example
     * // Update or create a AlarmNewMission
     * const alarmNewMission = await prisma.alarmNewMission.upsert({
     *   create: {
     *     // ... data to create a AlarmNewMission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlarmNewMission we want to update
     *   }
     * })
     */
    upsert<T extends AlarmNewMissionUpsertArgs>(args: SelectSubset<T, AlarmNewMissionUpsertArgs<ExtArgs>>): Prisma__AlarmNewMissionClient<$Result.GetResult<Prisma.$AlarmNewMissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AlarmNewMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmNewMissionCountArgs} args - Arguments to filter AlarmNewMissions to count.
     * @example
     * // Count the number of AlarmNewMissions
     * const count = await prisma.alarmNewMission.count({
     *   where: {
     *     // ... the filter for the AlarmNewMissions we want to count
     *   }
     * })
    **/
    count<T extends AlarmNewMissionCountArgs>(
      args?: Subset<T, AlarmNewMissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlarmNewMissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlarmNewMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmNewMissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlarmNewMissionAggregateArgs>(args: Subset<T, AlarmNewMissionAggregateArgs>): Prisma.PrismaPromise<GetAlarmNewMissionAggregateType<T>>

    /**
     * Group by AlarmNewMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmNewMissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlarmNewMissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlarmNewMissionGroupByArgs['orderBy'] }
        : { orderBy?: AlarmNewMissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlarmNewMissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlarmNewMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlarmNewMission model
   */
  readonly fields: AlarmNewMissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlarmNewMission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlarmNewMissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alarm<T extends AlarmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlarmDefaultArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlarmNewMission model
   */ 
  interface AlarmNewMissionFieldRefs {
    readonly id: FieldRef<"AlarmNewMission", 'BigInt'>
    readonly alarmId: FieldRef<"AlarmNewMission", 'BigInt'>
    readonly title: FieldRef<"AlarmNewMission", 'String'>
    readonly body: FieldRef<"AlarmNewMission", 'String'>
    readonly createdAt: FieldRef<"AlarmNewMission", 'DateTime'>
    readonly updatedAt: FieldRef<"AlarmNewMission", 'DateTime'>
    readonly status: FieldRef<"AlarmNewMission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AlarmNewMission findUnique
   */
  export type AlarmNewMissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    /**
     * Filter, which AlarmNewMission to fetch.
     */
    where: AlarmNewMissionWhereUniqueInput
  }

  /**
   * AlarmNewMission findUniqueOrThrow
   */
  export type AlarmNewMissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    /**
     * Filter, which AlarmNewMission to fetch.
     */
    where: AlarmNewMissionWhereUniqueInput
  }

  /**
   * AlarmNewMission findFirst
   */
  export type AlarmNewMissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    /**
     * Filter, which AlarmNewMission to fetch.
     */
    where?: AlarmNewMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmNewMissions to fetch.
     */
    orderBy?: AlarmNewMissionOrderByWithRelationInput | AlarmNewMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlarmNewMissions.
     */
    cursor?: AlarmNewMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmNewMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmNewMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlarmNewMissions.
     */
    distinct?: AlarmNewMissionScalarFieldEnum | AlarmNewMissionScalarFieldEnum[]
  }

  /**
   * AlarmNewMission findFirstOrThrow
   */
  export type AlarmNewMissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    /**
     * Filter, which AlarmNewMission to fetch.
     */
    where?: AlarmNewMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmNewMissions to fetch.
     */
    orderBy?: AlarmNewMissionOrderByWithRelationInput | AlarmNewMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlarmNewMissions.
     */
    cursor?: AlarmNewMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmNewMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmNewMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlarmNewMissions.
     */
    distinct?: AlarmNewMissionScalarFieldEnum | AlarmNewMissionScalarFieldEnum[]
  }

  /**
   * AlarmNewMission findMany
   */
  export type AlarmNewMissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    /**
     * Filter, which AlarmNewMissions to fetch.
     */
    where?: AlarmNewMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmNewMissions to fetch.
     */
    orderBy?: AlarmNewMissionOrderByWithRelationInput | AlarmNewMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlarmNewMissions.
     */
    cursor?: AlarmNewMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmNewMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmNewMissions.
     */
    skip?: number
    distinct?: AlarmNewMissionScalarFieldEnum | AlarmNewMissionScalarFieldEnum[]
  }

  /**
   * AlarmNewMission create
   */
  export type AlarmNewMissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AlarmNewMission.
     */
    data: XOR<AlarmNewMissionCreateInput, AlarmNewMissionUncheckedCreateInput>
  }

  /**
   * AlarmNewMission createMany
   */
  export type AlarmNewMissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlarmNewMissions.
     */
    data: AlarmNewMissionCreateManyInput | AlarmNewMissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlarmNewMission update
   */
  export type AlarmNewMissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AlarmNewMission.
     */
    data: XOR<AlarmNewMissionUpdateInput, AlarmNewMissionUncheckedUpdateInput>
    /**
     * Choose, which AlarmNewMission to update.
     */
    where: AlarmNewMissionWhereUniqueInput
  }

  /**
   * AlarmNewMission updateMany
   */
  export type AlarmNewMissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlarmNewMissions.
     */
    data: XOR<AlarmNewMissionUpdateManyMutationInput, AlarmNewMissionUncheckedUpdateManyInput>
    /**
     * Filter which AlarmNewMissions to update
     */
    where?: AlarmNewMissionWhereInput
  }

  /**
   * AlarmNewMission upsert
   */
  export type AlarmNewMissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AlarmNewMission to update in case it exists.
     */
    where: AlarmNewMissionWhereUniqueInput
    /**
     * In case the AlarmNewMission found by the `where` argument doesn't exist, create a new AlarmNewMission with this data.
     */
    create: XOR<AlarmNewMissionCreateInput, AlarmNewMissionUncheckedCreateInput>
    /**
     * In case the AlarmNewMission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlarmNewMissionUpdateInput, AlarmNewMissionUncheckedUpdateInput>
  }

  /**
   * AlarmNewMission delete
   */
  export type AlarmNewMissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
    /**
     * Filter which AlarmNewMission to delete.
     */
    where: AlarmNewMissionWhereUniqueInput
  }

  /**
   * AlarmNewMission deleteMany
   */
  export type AlarmNewMissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlarmNewMissions to delete
     */
    where?: AlarmNewMissionWhereInput
  }

  /**
   * AlarmNewMission without action
   */
  export type AlarmNewMissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmNewMission
     */
    select?: AlarmNewMissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmNewMissionInclude<ExtArgs> | null
  }


  /**
   * Model AlarmReviewRequest
   */

  export type AggregateAlarmReviewRequest = {
    _count: AlarmReviewRequestCountAggregateOutputType | null
    _avg: AlarmReviewRequestAvgAggregateOutputType | null
    _sum: AlarmReviewRequestSumAggregateOutputType | null
    _min: AlarmReviewRequestMinAggregateOutputType | null
    _max: AlarmReviewRequestMaxAggregateOutputType | null
  }

  export type AlarmReviewRequestAvgAggregateOutputType = {
    id: number | null
    alarmId: number | null
    status: number | null
  }

  export type AlarmReviewRequestSumAggregateOutputType = {
    id: bigint | null
    alarmId: bigint | null
    status: number | null
  }

  export type AlarmReviewRequestMinAggregateOutputType = {
    id: bigint | null
    alarmId: bigint | null
    title: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type AlarmReviewRequestMaxAggregateOutputType = {
    id: bigint | null
    alarmId: bigint | null
    title: string | null
    body: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: number | null
  }

  export type AlarmReviewRequestCountAggregateOutputType = {
    id: number
    alarmId: number
    title: number
    body: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type AlarmReviewRequestAvgAggregateInputType = {
    id?: true
    alarmId?: true
    status?: true
  }

  export type AlarmReviewRequestSumAggregateInputType = {
    id?: true
    alarmId?: true
    status?: true
  }

  export type AlarmReviewRequestMinAggregateInputType = {
    id?: true
    alarmId?: true
    title?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AlarmReviewRequestMaxAggregateInputType = {
    id?: true
    alarmId?: true
    title?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type AlarmReviewRequestCountAggregateInputType = {
    id?: true
    alarmId?: true
    title?: true
    body?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type AlarmReviewRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlarmReviewRequest to aggregate.
     */
    where?: AlarmReviewRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmReviewRequests to fetch.
     */
    orderBy?: AlarmReviewRequestOrderByWithRelationInput | AlarmReviewRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlarmReviewRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmReviewRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmReviewRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlarmReviewRequests
    **/
    _count?: true | AlarmReviewRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlarmReviewRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlarmReviewRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlarmReviewRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlarmReviewRequestMaxAggregateInputType
  }

  export type GetAlarmReviewRequestAggregateType<T extends AlarmReviewRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateAlarmReviewRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlarmReviewRequest[P]>
      : GetScalarType<T[P], AggregateAlarmReviewRequest[P]>
  }




  export type AlarmReviewRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlarmReviewRequestWhereInput
    orderBy?: AlarmReviewRequestOrderByWithAggregationInput | AlarmReviewRequestOrderByWithAggregationInput[]
    by: AlarmReviewRequestScalarFieldEnum[] | AlarmReviewRequestScalarFieldEnum
    having?: AlarmReviewRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlarmReviewRequestCountAggregateInputType | true
    _avg?: AlarmReviewRequestAvgAggregateInputType
    _sum?: AlarmReviewRequestSumAggregateInputType
    _min?: AlarmReviewRequestMinAggregateInputType
    _max?: AlarmReviewRequestMaxAggregateInputType
  }

  export type AlarmReviewRequestGroupByOutputType = {
    id: bigint
    alarmId: bigint
    title: string
    body: string
    createdAt: Date
    updatedAt: Date
    status: number
    _count: AlarmReviewRequestCountAggregateOutputType | null
    _avg: AlarmReviewRequestAvgAggregateOutputType | null
    _sum: AlarmReviewRequestSumAggregateOutputType | null
    _min: AlarmReviewRequestMinAggregateOutputType | null
    _max: AlarmReviewRequestMaxAggregateOutputType | null
  }

  type GetAlarmReviewRequestGroupByPayload<T extends AlarmReviewRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlarmReviewRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlarmReviewRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlarmReviewRequestGroupByOutputType[P]>
            : GetScalarType<T[P], AlarmReviewRequestGroupByOutputType[P]>
        }
      >
    >


  export type AlarmReviewRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alarmId?: boolean
    title?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    alarm?: boolean | AlarmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alarmReviewRequest"]>


  export type AlarmReviewRequestSelectScalar = {
    id?: boolean
    alarmId?: boolean
    title?: boolean
    body?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type AlarmReviewRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alarm?: boolean | AlarmDefaultArgs<ExtArgs>
  }

  export type $AlarmReviewRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlarmReviewRequest"
    objects: {
      alarm: Prisma.$AlarmPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      alarmId: bigint
      title: string
      body: string
      createdAt: Date
      updatedAt: Date
      status: number
    }, ExtArgs["result"]["alarmReviewRequest"]>
    composites: {}
  }

  type AlarmReviewRequestGetPayload<S extends boolean | null | undefined | AlarmReviewRequestDefaultArgs> = $Result.GetResult<Prisma.$AlarmReviewRequestPayload, S>

  type AlarmReviewRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlarmReviewRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlarmReviewRequestCountAggregateInputType | true
    }

  export interface AlarmReviewRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlarmReviewRequest'], meta: { name: 'AlarmReviewRequest' } }
    /**
     * Find zero or one AlarmReviewRequest that matches the filter.
     * @param {AlarmReviewRequestFindUniqueArgs} args - Arguments to find a AlarmReviewRequest
     * @example
     * // Get one AlarmReviewRequest
     * const alarmReviewRequest = await prisma.alarmReviewRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlarmReviewRequestFindUniqueArgs>(args: SelectSubset<T, AlarmReviewRequestFindUniqueArgs<ExtArgs>>): Prisma__AlarmReviewRequestClient<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AlarmReviewRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlarmReviewRequestFindUniqueOrThrowArgs} args - Arguments to find a AlarmReviewRequest
     * @example
     * // Get one AlarmReviewRequest
     * const alarmReviewRequest = await prisma.alarmReviewRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlarmReviewRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, AlarmReviewRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlarmReviewRequestClient<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AlarmReviewRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmReviewRequestFindFirstArgs} args - Arguments to find a AlarmReviewRequest
     * @example
     * // Get one AlarmReviewRequest
     * const alarmReviewRequest = await prisma.alarmReviewRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlarmReviewRequestFindFirstArgs>(args?: SelectSubset<T, AlarmReviewRequestFindFirstArgs<ExtArgs>>): Prisma__AlarmReviewRequestClient<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AlarmReviewRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmReviewRequestFindFirstOrThrowArgs} args - Arguments to find a AlarmReviewRequest
     * @example
     * // Get one AlarmReviewRequest
     * const alarmReviewRequest = await prisma.alarmReviewRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlarmReviewRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, AlarmReviewRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlarmReviewRequestClient<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AlarmReviewRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmReviewRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlarmReviewRequests
     * const alarmReviewRequests = await prisma.alarmReviewRequest.findMany()
     * 
     * // Get first 10 AlarmReviewRequests
     * const alarmReviewRequests = await prisma.alarmReviewRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alarmReviewRequestWithIdOnly = await prisma.alarmReviewRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlarmReviewRequestFindManyArgs>(args?: SelectSubset<T, AlarmReviewRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AlarmReviewRequest.
     * @param {AlarmReviewRequestCreateArgs} args - Arguments to create a AlarmReviewRequest.
     * @example
     * // Create one AlarmReviewRequest
     * const AlarmReviewRequest = await prisma.alarmReviewRequest.create({
     *   data: {
     *     // ... data to create a AlarmReviewRequest
     *   }
     * })
     * 
     */
    create<T extends AlarmReviewRequestCreateArgs>(args: SelectSubset<T, AlarmReviewRequestCreateArgs<ExtArgs>>): Prisma__AlarmReviewRequestClient<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AlarmReviewRequests.
     * @param {AlarmReviewRequestCreateManyArgs} args - Arguments to create many AlarmReviewRequests.
     * @example
     * // Create many AlarmReviewRequests
     * const alarmReviewRequest = await prisma.alarmReviewRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlarmReviewRequestCreateManyArgs>(args?: SelectSubset<T, AlarmReviewRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AlarmReviewRequest.
     * @param {AlarmReviewRequestDeleteArgs} args - Arguments to delete one AlarmReviewRequest.
     * @example
     * // Delete one AlarmReviewRequest
     * const AlarmReviewRequest = await prisma.alarmReviewRequest.delete({
     *   where: {
     *     // ... filter to delete one AlarmReviewRequest
     *   }
     * })
     * 
     */
    delete<T extends AlarmReviewRequestDeleteArgs>(args: SelectSubset<T, AlarmReviewRequestDeleteArgs<ExtArgs>>): Prisma__AlarmReviewRequestClient<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AlarmReviewRequest.
     * @param {AlarmReviewRequestUpdateArgs} args - Arguments to update one AlarmReviewRequest.
     * @example
     * // Update one AlarmReviewRequest
     * const alarmReviewRequest = await prisma.alarmReviewRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlarmReviewRequestUpdateArgs>(args: SelectSubset<T, AlarmReviewRequestUpdateArgs<ExtArgs>>): Prisma__AlarmReviewRequestClient<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AlarmReviewRequests.
     * @param {AlarmReviewRequestDeleteManyArgs} args - Arguments to filter AlarmReviewRequests to delete.
     * @example
     * // Delete a few AlarmReviewRequests
     * const { count } = await prisma.alarmReviewRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlarmReviewRequestDeleteManyArgs>(args?: SelectSubset<T, AlarmReviewRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlarmReviewRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmReviewRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlarmReviewRequests
     * const alarmReviewRequest = await prisma.alarmReviewRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlarmReviewRequestUpdateManyArgs>(args: SelectSubset<T, AlarmReviewRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlarmReviewRequest.
     * @param {AlarmReviewRequestUpsertArgs} args - Arguments to update or create a AlarmReviewRequest.
     * @example
     * // Update or create a AlarmReviewRequest
     * const alarmReviewRequest = await prisma.alarmReviewRequest.upsert({
     *   create: {
     *     // ... data to create a AlarmReviewRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlarmReviewRequest we want to update
     *   }
     * })
     */
    upsert<T extends AlarmReviewRequestUpsertArgs>(args: SelectSubset<T, AlarmReviewRequestUpsertArgs<ExtArgs>>): Prisma__AlarmReviewRequestClient<$Result.GetResult<Prisma.$AlarmReviewRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AlarmReviewRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmReviewRequestCountArgs} args - Arguments to filter AlarmReviewRequests to count.
     * @example
     * // Count the number of AlarmReviewRequests
     * const count = await prisma.alarmReviewRequest.count({
     *   where: {
     *     // ... the filter for the AlarmReviewRequests we want to count
     *   }
     * })
    **/
    count<T extends AlarmReviewRequestCountArgs>(
      args?: Subset<T, AlarmReviewRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlarmReviewRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlarmReviewRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmReviewRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlarmReviewRequestAggregateArgs>(args: Subset<T, AlarmReviewRequestAggregateArgs>): Prisma.PrismaPromise<GetAlarmReviewRequestAggregateType<T>>

    /**
     * Group by AlarmReviewRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmReviewRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlarmReviewRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlarmReviewRequestGroupByArgs['orderBy'] }
        : { orderBy?: AlarmReviewRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlarmReviewRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlarmReviewRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlarmReviewRequest model
   */
  readonly fields: AlarmReviewRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlarmReviewRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlarmReviewRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alarm<T extends AlarmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlarmDefaultArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlarmReviewRequest model
   */ 
  interface AlarmReviewRequestFieldRefs {
    readonly id: FieldRef<"AlarmReviewRequest", 'BigInt'>
    readonly alarmId: FieldRef<"AlarmReviewRequest", 'BigInt'>
    readonly title: FieldRef<"AlarmReviewRequest", 'String'>
    readonly body: FieldRef<"AlarmReviewRequest", 'String'>
    readonly createdAt: FieldRef<"AlarmReviewRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"AlarmReviewRequest", 'DateTime'>
    readonly status: FieldRef<"AlarmReviewRequest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AlarmReviewRequest findUnique
   */
  export type AlarmReviewRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    /**
     * Filter, which AlarmReviewRequest to fetch.
     */
    where: AlarmReviewRequestWhereUniqueInput
  }

  /**
   * AlarmReviewRequest findUniqueOrThrow
   */
  export type AlarmReviewRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    /**
     * Filter, which AlarmReviewRequest to fetch.
     */
    where: AlarmReviewRequestWhereUniqueInput
  }

  /**
   * AlarmReviewRequest findFirst
   */
  export type AlarmReviewRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    /**
     * Filter, which AlarmReviewRequest to fetch.
     */
    where?: AlarmReviewRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmReviewRequests to fetch.
     */
    orderBy?: AlarmReviewRequestOrderByWithRelationInput | AlarmReviewRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlarmReviewRequests.
     */
    cursor?: AlarmReviewRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmReviewRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmReviewRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlarmReviewRequests.
     */
    distinct?: AlarmReviewRequestScalarFieldEnum | AlarmReviewRequestScalarFieldEnum[]
  }

  /**
   * AlarmReviewRequest findFirstOrThrow
   */
  export type AlarmReviewRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    /**
     * Filter, which AlarmReviewRequest to fetch.
     */
    where?: AlarmReviewRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmReviewRequests to fetch.
     */
    orderBy?: AlarmReviewRequestOrderByWithRelationInput | AlarmReviewRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlarmReviewRequests.
     */
    cursor?: AlarmReviewRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmReviewRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmReviewRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlarmReviewRequests.
     */
    distinct?: AlarmReviewRequestScalarFieldEnum | AlarmReviewRequestScalarFieldEnum[]
  }

  /**
   * AlarmReviewRequest findMany
   */
  export type AlarmReviewRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    /**
     * Filter, which AlarmReviewRequests to fetch.
     */
    where?: AlarmReviewRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlarmReviewRequests to fetch.
     */
    orderBy?: AlarmReviewRequestOrderByWithRelationInput | AlarmReviewRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlarmReviewRequests.
     */
    cursor?: AlarmReviewRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlarmReviewRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlarmReviewRequests.
     */
    skip?: number
    distinct?: AlarmReviewRequestScalarFieldEnum | AlarmReviewRequestScalarFieldEnum[]
  }

  /**
   * AlarmReviewRequest create
   */
  export type AlarmReviewRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a AlarmReviewRequest.
     */
    data: XOR<AlarmReviewRequestCreateInput, AlarmReviewRequestUncheckedCreateInput>
  }

  /**
   * AlarmReviewRequest createMany
   */
  export type AlarmReviewRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlarmReviewRequests.
     */
    data: AlarmReviewRequestCreateManyInput | AlarmReviewRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlarmReviewRequest update
   */
  export type AlarmReviewRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a AlarmReviewRequest.
     */
    data: XOR<AlarmReviewRequestUpdateInput, AlarmReviewRequestUncheckedUpdateInput>
    /**
     * Choose, which AlarmReviewRequest to update.
     */
    where: AlarmReviewRequestWhereUniqueInput
  }

  /**
   * AlarmReviewRequest updateMany
   */
  export type AlarmReviewRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlarmReviewRequests.
     */
    data: XOR<AlarmReviewRequestUpdateManyMutationInput, AlarmReviewRequestUncheckedUpdateManyInput>
    /**
     * Filter which AlarmReviewRequests to update
     */
    where?: AlarmReviewRequestWhereInput
  }

  /**
   * AlarmReviewRequest upsert
   */
  export type AlarmReviewRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the AlarmReviewRequest to update in case it exists.
     */
    where: AlarmReviewRequestWhereUniqueInput
    /**
     * In case the AlarmReviewRequest found by the `where` argument doesn't exist, create a new AlarmReviewRequest with this data.
     */
    create: XOR<AlarmReviewRequestCreateInput, AlarmReviewRequestUncheckedCreateInput>
    /**
     * In case the AlarmReviewRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlarmReviewRequestUpdateInput, AlarmReviewRequestUncheckedUpdateInput>
  }

  /**
   * AlarmReviewRequest delete
   */
  export type AlarmReviewRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
    /**
     * Filter which AlarmReviewRequest to delete.
     */
    where: AlarmReviewRequestWhereUniqueInput
  }

  /**
   * AlarmReviewRequest deleteMany
   */
  export type AlarmReviewRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlarmReviewRequests to delete
     */
    where?: AlarmReviewRequestWhereInput
  }

  /**
   * AlarmReviewRequest without action
   */
  export type AlarmReviewRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlarmReviewRequest
     */
    select?: AlarmReviewRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlarmReviewRequestInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MemberScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    location: 'location',
    phoneNumber: 'phoneNumber',
    nickname: 'nickname',
    gender: 'gender',
    birth: 'birth',
    points: 'points',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    inactiveAt: 'inactiveAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const FoodKindScalarFieldEnum: {
    id: 'id',
    kind: 'kind',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type FoodKindScalarFieldEnum = (typeof FoodKindScalarFieldEnum)[keyof typeof FoodKindScalarFieldEnum]


  export const MemberFavoriteFoodKindScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    foodKindId: 'foodKindId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type MemberFavoriteFoodKindScalarFieldEnum = (typeof MemberFavoriteFoodKindScalarFieldEnum)[keyof typeof MemberFavoriteFoodKindScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const RestaurantScalarFieldEnum: {
    id: 'id',
    ceoId: 'ceoId',
    regionId: 'regionId',
    name: 'name',
    introduction: 'introduction',
    startTime: 'startTime',
    endTime: 'endTime',
    totalRating: 'totalRating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type RestaurantScalarFieldEnum = (typeof RestaurantScalarFieldEnum)[keyof typeof RestaurantScalarFieldEnum]


  export const MissionScalarFieldEnum: {
    id: 'id',
    restaurantId: 'restaurantId',
    name: 'name',
    introduction: 'introduction',
    deadline: 'deadline',
    points: 'points',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type MissionScalarFieldEnum = (typeof MissionScalarFieldEnum)[keyof typeof MissionScalarFieldEnum]


  export const MemberMissionScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    missionId: 'missionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type MemberMissionScalarFieldEnum = (typeof MemberMissionScalarFieldEnum)[keyof typeof MemberMissionScalarFieldEnum]


  export const FoodKindRestaurantScalarFieldEnum: {
    id: 'id',
    foodKindId: 'foodKindId',
    restaurantId: 'restaurantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type FoodKindRestaurantScalarFieldEnum = (typeof FoodKindRestaurantScalarFieldEnum)[keyof typeof FoodKindRestaurantScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    restaurantId: 'restaurantId',
    rating: 'rating',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReplyScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    reviewId: 'reviewId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type ReplyScalarFieldEnum = (typeof ReplyScalarFieldEnum)[keyof typeof ReplyScalarFieldEnum]


  export const InquiryScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    title: 'title',
    content: 'content',
    isConfirmed: 'isConfirmed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    restaurantId: 'restaurantId',
    reviewId: 'reviewId',
    inquiryId: 'inquiryId',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const AlarmScalarFieldEnum: {
    id: 'id',
    memberId: 'memberId',
    isConfirmed: 'isConfirmed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type AlarmScalarFieldEnum = (typeof AlarmScalarFieldEnum)[keyof typeof AlarmScalarFieldEnum]


  export const AlarmNewMissionScalarFieldEnum: {
    id: 'id',
    alarmId: 'alarmId',
    title: 'title',
    body: 'body',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type AlarmNewMissionScalarFieldEnum = (typeof AlarmNewMissionScalarFieldEnum)[keyof typeof AlarmNewMissionScalarFieldEnum]


  export const AlarmReviewRequestScalarFieldEnum: {
    id: 'id',
    alarmId: 'alarmId',
    title: 'title',
    body: 'body',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type AlarmReviewRequestScalarFieldEnum = (typeof AlarmReviewRequestScalarFieldEnum)[keyof typeof AlarmReviewRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: BigIntFilter<"Member"> | bigint | number
    name?: StringFilter<"Member"> | string
    email?: StringFilter<"Member"> | string
    location?: StringFilter<"Member"> | string
    phoneNumber?: StringFilter<"Member"> | string
    nickname?: StringFilter<"Member"> | string
    gender?: IntFilter<"Member"> | number
    birth?: DateTimeFilter<"Member"> | Date | string
    points?: BigIntFilter<"Member"> | bigint | number
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    status?: IntFilter<"Member"> | number
    inactiveAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindListRelationFilter
    restaurants?: RestaurantListRelationFilter
    memberMissions?: MemberMissionListRelationFilter
    reviews?: ReviewListRelationFilter
    reply?: ReplyListRelationFilter
    inquiries?: InquiryListRelationFilter
    alarms?: AlarmListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    nickname?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    inactiveAt?: SortOrderInput | SortOrder
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindOrderByRelationAggregateInput
    restaurants?: RestaurantOrderByRelationAggregateInput
    memberMissions?: MemberMissionOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    reply?: ReplyOrderByRelationAggregateInput
    inquiries?: InquiryOrderByRelationAggregateInput
    alarms?: AlarmOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    name?: StringFilter<"Member"> | string
    location?: StringFilter<"Member"> | string
    phoneNumber?: StringFilter<"Member"> | string
    nickname?: StringFilter<"Member"> | string
    gender?: IntFilter<"Member"> | number
    birth?: DateTimeFilter<"Member"> | Date | string
    points?: BigIntFilter<"Member"> | bigint | number
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    status?: IntFilter<"Member"> | number
    inactiveAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindListRelationFilter
    restaurants?: RestaurantListRelationFilter
    memberMissions?: MemberMissionListRelationFilter
    reviews?: ReviewListRelationFilter
    reply?: ReplyListRelationFilter
    inquiries?: InquiryListRelationFilter
    alarms?: AlarmListRelationFilter
  }, "id" | "email">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    nickname?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    inactiveAt?: SortOrderInput | SortOrder
    _count?: MemberCountOrderByAggregateInput
    _avg?: MemberAvgOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
    _sum?: MemberSumOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Member"> | bigint | number
    name?: StringWithAggregatesFilter<"Member"> | string
    email?: StringWithAggregatesFilter<"Member"> | string
    location?: StringWithAggregatesFilter<"Member"> | string
    phoneNumber?: StringWithAggregatesFilter<"Member"> | string
    nickname?: StringWithAggregatesFilter<"Member"> | string
    gender?: IntWithAggregatesFilter<"Member"> | number
    birth?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    points?: BigIntWithAggregatesFilter<"Member"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    status?: IntWithAggregatesFilter<"Member"> | number
    inactiveAt?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
  }

  export type FoodKindWhereInput = {
    AND?: FoodKindWhereInput | FoodKindWhereInput[]
    OR?: FoodKindWhereInput[]
    NOT?: FoodKindWhereInput | FoodKindWhereInput[]
    id?: BigIntFilter<"FoodKind"> | bigint | number
    kind?: StringFilter<"FoodKind"> | string
    createdAt?: DateTimeFilter<"FoodKind"> | Date | string
    updatedAt?: DateTimeFilter<"FoodKind"> | Date | string
    status?: IntFilter<"FoodKind"> | number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindListRelationFilter
    foodKindRestaurants?: FoodKindRestaurantListRelationFilter
  }

  export type FoodKindOrderByWithRelationInput = {
    id?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindOrderByRelationAggregateInput
    foodKindRestaurants?: FoodKindRestaurantOrderByRelationAggregateInput
  }

  export type FoodKindWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: FoodKindWhereInput | FoodKindWhereInput[]
    OR?: FoodKindWhereInput[]
    NOT?: FoodKindWhereInput | FoodKindWhereInput[]
    kind?: StringFilter<"FoodKind"> | string
    createdAt?: DateTimeFilter<"FoodKind"> | Date | string
    updatedAt?: DateTimeFilter<"FoodKind"> | Date | string
    status?: IntFilter<"FoodKind"> | number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindListRelationFilter
    foodKindRestaurants?: FoodKindRestaurantListRelationFilter
  }, "id">

  export type FoodKindOrderByWithAggregationInput = {
    id?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: FoodKindCountOrderByAggregateInput
    _avg?: FoodKindAvgOrderByAggregateInput
    _max?: FoodKindMaxOrderByAggregateInput
    _min?: FoodKindMinOrderByAggregateInput
    _sum?: FoodKindSumOrderByAggregateInput
  }

  export type FoodKindScalarWhereWithAggregatesInput = {
    AND?: FoodKindScalarWhereWithAggregatesInput | FoodKindScalarWhereWithAggregatesInput[]
    OR?: FoodKindScalarWhereWithAggregatesInput[]
    NOT?: FoodKindScalarWhereWithAggregatesInput | FoodKindScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"FoodKind"> | bigint | number
    kind?: StringWithAggregatesFilter<"FoodKind"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FoodKind"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodKind"> | Date | string
    status?: IntWithAggregatesFilter<"FoodKind"> | number
  }

  export type MemberFavoriteFoodKindWhereInput = {
    AND?: MemberFavoriteFoodKindWhereInput | MemberFavoriteFoodKindWhereInput[]
    OR?: MemberFavoriteFoodKindWhereInput[]
    NOT?: MemberFavoriteFoodKindWhereInput | MemberFavoriteFoodKindWhereInput[]
    id?: BigIntFilter<"MemberFavoriteFoodKind"> | bigint | number
    memberId?: BigIntFilter<"MemberFavoriteFoodKind"> | bigint | number
    foodKindId?: BigIntFilter<"MemberFavoriteFoodKind"> | bigint | number
    createdAt?: DateTimeFilter<"MemberFavoriteFoodKind"> | Date | string
    updatedAt?: DateTimeFilter<"MemberFavoriteFoodKind"> | Date | string
    status?: IntFilter<"MemberFavoriteFoodKind"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    foodKind?: XOR<FoodKindRelationFilter, FoodKindWhereInput>
  }

  export type MemberFavoriteFoodKindOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    foodKindId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    member?: MemberOrderByWithRelationInput
    foodKind?: FoodKindOrderByWithRelationInput
  }

  export type MemberFavoriteFoodKindWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MemberFavoriteFoodKindWhereInput | MemberFavoriteFoodKindWhereInput[]
    OR?: MemberFavoriteFoodKindWhereInput[]
    NOT?: MemberFavoriteFoodKindWhereInput | MemberFavoriteFoodKindWhereInput[]
    memberId?: BigIntFilter<"MemberFavoriteFoodKind"> | bigint | number
    foodKindId?: BigIntFilter<"MemberFavoriteFoodKind"> | bigint | number
    createdAt?: DateTimeFilter<"MemberFavoriteFoodKind"> | Date | string
    updatedAt?: DateTimeFilter<"MemberFavoriteFoodKind"> | Date | string
    status?: IntFilter<"MemberFavoriteFoodKind"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    foodKind?: XOR<FoodKindRelationFilter, FoodKindWhereInput>
  }, "id">

  export type MemberFavoriteFoodKindOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    foodKindId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: MemberFavoriteFoodKindCountOrderByAggregateInput
    _avg?: MemberFavoriteFoodKindAvgOrderByAggregateInput
    _max?: MemberFavoriteFoodKindMaxOrderByAggregateInput
    _min?: MemberFavoriteFoodKindMinOrderByAggregateInput
    _sum?: MemberFavoriteFoodKindSumOrderByAggregateInput
  }

  export type MemberFavoriteFoodKindScalarWhereWithAggregatesInput = {
    AND?: MemberFavoriteFoodKindScalarWhereWithAggregatesInput | MemberFavoriteFoodKindScalarWhereWithAggregatesInput[]
    OR?: MemberFavoriteFoodKindScalarWhereWithAggregatesInput[]
    NOT?: MemberFavoriteFoodKindScalarWhereWithAggregatesInput | MemberFavoriteFoodKindScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"MemberFavoriteFoodKind"> | bigint | number
    memberId?: BigIntWithAggregatesFilter<"MemberFavoriteFoodKind"> | bigint | number
    foodKindId?: BigIntWithAggregatesFilter<"MemberFavoriteFoodKind"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"MemberFavoriteFoodKind"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MemberFavoriteFoodKind"> | Date | string
    status?: IntWithAggregatesFilter<"MemberFavoriteFoodKind"> | number
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: BigIntFilter<"Region"> | bigint | number
    address?: StringFilter<"Region"> | string
    createdAt?: DateTimeFilter<"Region"> | Date | string
    updatedAt?: DateTimeFilter<"Region"> | Date | string
    status?: IntFilter<"Region"> | number
    restaurant?: RestaurantListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    restaurant?: RestaurantOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    address?: StringFilter<"Region"> | string
    createdAt?: DateTimeFilter<"Region"> | Date | string
    updatedAt?: DateTimeFilter<"Region"> | Date | string
    status?: IntFilter<"Region"> | number
    restaurant?: RestaurantListRelationFilter
  }, "id">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Region"> | bigint | number
    address?: StringWithAggregatesFilter<"Region"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Region"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Region"> | Date | string
    status?: IntWithAggregatesFilter<"Region"> | number
  }

  export type RestaurantWhereInput = {
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    id?: BigIntFilter<"Restaurant"> | bigint | number
    ceoId?: BigIntFilter<"Restaurant"> | bigint | number
    regionId?: BigIntFilter<"Restaurant"> | bigint | number
    name?: StringFilter<"Restaurant"> | string
    introduction?: StringFilter<"Restaurant"> | string
    startTime?: StringFilter<"Restaurant"> | string
    endTime?: StringFilter<"Restaurant"> | string
    totalRating?: DecimalFilter<"Restaurant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    status?: IntFilter<"Restaurant"> | number
    ceo?: XOR<MemberRelationFilter, MemberWhereInput>
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    missions?: MissionListRelationFilter
    foodKindRestaurants?: FoodKindRestaurantListRelationFilter
    reviews?: ReviewListRelationFilter
    images?: ImageListRelationFilter
  }

  export type RestaurantOrderByWithRelationInput = {
    id?: SortOrder
    ceoId?: SortOrder
    regionId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    totalRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    ceo?: MemberOrderByWithRelationInput
    region?: RegionOrderByWithRelationInput
    missions?: MissionOrderByRelationAggregateInput
    foodKindRestaurants?: FoodKindRestaurantOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    images?: ImageOrderByRelationAggregateInput
  }

  export type RestaurantWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    ceoId?: BigIntFilter<"Restaurant"> | bigint | number
    regionId?: BigIntFilter<"Restaurant"> | bigint | number
    name?: StringFilter<"Restaurant"> | string
    introduction?: StringFilter<"Restaurant"> | string
    startTime?: StringFilter<"Restaurant"> | string
    endTime?: StringFilter<"Restaurant"> | string
    totalRating?: DecimalFilter<"Restaurant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    status?: IntFilter<"Restaurant"> | number
    ceo?: XOR<MemberRelationFilter, MemberWhereInput>
    region?: XOR<RegionRelationFilter, RegionWhereInput>
    missions?: MissionListRelationFilter
    foodKindRestaurants?: FoodKindRestaurantListRelationFilter
    reviews?: ReviewListRelationFilter
    images?: ImageListRelationFilter
  }, "id">

  export type RestaurantOrderByWithAggregationInput = {
    id?: SortOrder
    ceoId?: SortOrder
    regionId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    totalRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: RestaurantCountOrderByAggregateInput
    _avg?: RestaurantAvgOrderByAggregateInput
    _max?: RestaurantMaxOrderByAggregateInput
    _min?: RestaurantMinOrderByAggregateInput
    _sum?: RestaurantSumOrderByAggregateInput
  }

  export type RestaurantScalarWhereWithAggregatesInput = {
    AND?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    OR?: RestaurantScalarWhereWithAggregatesInput[]
    NOT?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Restaurant"> | bigint | number
    ceoId?: BigIntWithAggregatesFilter<"Restaurant"> | bigint | number
    regionId?: BigIntWithAggregatesFilter<"Restaurant"> | bigint | number
    name?: StringWithAggregatesFilter<"Restaurant"> | string
    introduction?: StringWithAggregatesFilter<"Restaurant"> | string
    startTime?: StringWithAggregatesFilter<"Restaurant"> | string
    endTime?: StringWithAggregatesFilter<"Restaurant"> | string
    totalRating?: DecimalWithAggregatesFilter<"Restaurant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Restaurant"> | Date | string
    status?: IntWithAggregatesFilter<"Restaurant"> | number
  }

  export type MissionWhereInput = {
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    id?: BigIntFilter<"Mission"> | bigint | number
    restaurantId?: BigIntFilter<"Mission"> | bigint | number
    name?: StringFilter<"Mission"> | string
    introduction?: StringFilter<"Mission"> | string
    deadline?: DateTimeFilter<"Mission"> | Date | string
    points?: IntFilter<"Mission"> | number
    createdAt?: DateTimeFilter<"Mission"> | Date | string
    updatedAt?: DateTimeFilter<"Mission"> | Date | string
    status?: IntFilter<"Mission"> | number
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
    memberMission?: MemberMissionListRelationFilter
  }

  export type MissionOrderByWithRelationInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    deadline?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
    memberMission?: MemberMissionOrderByRelationAggregateInput
  }

  export type MissionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    restaurantId?: BigIntFilter<"Mission"> | bigint | number
    name?: StringFilter<"Mission"> | string
    introduction?: StringFilter<"Mission"> | string
    deadline?: DateTimeFilter<"Mission"> | Date | string
    points?: IntFilter<"Mission"> | number
    createdAt?: DateTimeFilter<"Mission"> | Date | string
    updatedAt?: DateTimeFilter<"Mission"> | Date | string
    status?: IntFilter<"Mission"> | number
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
    memberMission?: MemberMissionListRelationFilter
  }, "id">

  export type MissionOrderByWithAggregationInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    deadline?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: MissionCountOrderByAggregateInput
    _avg?: MissionAvgOrderByAggregateInput
    _max?: MissionMaxOrderByAggregateInput
    _min?: MissionMinOrderByAggregateInput
    _sum?: MissionSumOrderByAggregateInput
  }

  export type MissionScalarWhereWithAggregatesInput = {
    AND?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    OR?: MissionScalarWhereWithAggregatesInput[]
    NOT?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Mission"> | bigint | number
    restaurantId?: BigIntWithAggregatesFilter<"Mission"> | bigint | number
    name?: StringWithAggregatesFilter<"Mission"> | string
    introduction?: StringWithAggregatesFilter<"Mission"> | string
    deadline?: DateTimeWithAggregatesFilter<"Mission"> | Date | string
    points?: IntWithAggregatesFilter<"Mission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Mission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mission"> | Date | string
    status?: IntWithAggregatesFilter<"Mission"> | number
  }

  export type MemberMissionWhereInput = {
    AND?: MemberMissionWhereInput | MemberMissionWhereInput[]
    OR?: MemberMissionWhereInput[]
    NOT?: MemberMissionWhereInput | MemberMissionWhereInput[]
    id?: BigIntFilter<"MemberMission"> | bigint | number
    memberId?: BigIntFilter<"MemberMission"> | bigint | number
    missionId?: BigIntFilter<"MemberMission"> | bigint | number
    createdAt?: DateTimeFilter<"MemberMission"> | Date | string
    updatedAt?: DateTimeFilter<"MemberMission"> | Date | string
    status?: IntFilter<"MemberMission"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    mission?: XOR<MissionRelationFilter, MissionWhereInput>
  }

  export type MemberMissionOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    missionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    member?: MemberOrderByWithRelationInput
    mission?: MissionOrderByWithRelationInput
  }

  export type MemberMissionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    memberId_missionId_unique?: MemberMissionMemberId_missionId_uniqueCompoundUniqueInput
    AND?: MemberMissionWhereInput | MemberMissionWhereInput[]
    OR?: MemberMissionWhereInput[]
    NOT?: MemberMissionWhereInput | MemberMissionWhereInput[]
    memberId?: BigIntFilter<"MemberMission"> | bigint | number
    missionId?: BigIntFilter<"MemberMission"> | bigint | number
    createdAt?: DateTimeFilter<"MemberMission"> | Date | string
    updatedAt?: DateTimeFilter<"MemberMission"> | Date | string
    status?: IntFilter<"MemberMission"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    mission?: XOR<MissionRelationFilter, MissionWhereInput>
  }, "id" | "memberId_missionId_unique">

  export type MemberMissionOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    missionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: MemberMissionCountOrderByAggregateInput
    _avg?: MemberMissionAvgOrderByAggregateInput
    _max?: MemberMissionMaxOrderByAggregateInput
    _min?: MemberMissionMinOrderByAggregateInput
    _sum?: MemberMissionSumOrderByAggregateInput
  }

  export type MemberMissionScalarWhereWithAggregatesInput = {
    AND?: MemberMissionScalarWhereWithAggregatesInput | MemberMissionScalarWhereWithAggregatesInput[]
    OR?: MemberMissionScalarWhereWithAggregatesInput[]
    NOT?: MemberMissionScalarWhereWithAggregatesInput | MemberMissionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"MemberMission"> | bigint | number
    memberId?: BigIntWithAggregatesFilter<"MemberMission"> | bigint | number
    missionId?: BigIntWithAggregatesFilter<"MemberMission"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"MemberMission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MemberMission"> | Date | string
    status?: IntWithAggregatesFilter<"MemberMission"> | number
  }

  export type FoodKindRestaurantWhereInput = {
    AND?: FoodKindRestaurantWhereInput | FoodKindRestaurantWhereInput[]
    OR?: FoodKindRestaurantWhereInput[]
    NOT?: FoodKindRestaurantWhereInput | FoodKindRestaurantWhereInput[]
    id?: BigIntFilter<"FoodKindRestaurant"> | bigint | number
    foodKindId?: BigIntFilter<"FoodKindRestaurant"> | bigint | number
    restaurantId?: BigIntFilter<"FoodKindRestaurant"> | bigint | number
    createdAt?: DateTimeFilter<"FoodKindRestaurant"> | Date | string
    updatedAt?: DateTimeFilter<"FoodKindRestaurant"> | Date | string
    status?: IntFilter<"FoodKindRestaurant"> | number
    foodKind?: XOR<FoodKindRelationFilter, FoodKindWhereInput>
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
  }

  export type FoodKindRestaurantOrderByWithRelationInput = {
    id?: SortOrder
    foodKindId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    foodKind?: FoodKindOrderByWithRelationInput
    restaurant?: RestaurantOrderByWithRelationInput
  }

  export type FoodKindRestaurantWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: FoodKindRestaurantWhereInput | FoodKindRestaurantWhereInput[]
    OR?: FoodKindRestaurantWhereInput[]
    NOT?: FoodKindRestaurantWhereInput | FoodKindRestaurantWhereInput[]
    foodKindId?: BigIntFilter<"FoodKindRestaurant"> | bigint | number
    restaurantId?: BigIntFilter<"FoodKindRestaurant"> | bigint | number
    createdAt?: DateTimeFilter<"FoodKindRestaurant"> | Date | string
    updatedAt?: DateTimeFilter<"FoodKindRestaurant"> | Date | string
    status?: IntFilter<"FoodKindRestaurant"> | number
    foodKind?: XOR<FoodKindRelationFilter, FoodKindWhereInput>
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
  }, "id">

  export type FoodKindRestaurantOrderByWithAggregationInput = {
    id?: SortOrder
    foodKindId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: FoodKindRestaurantCountOrderByAggregateInput
    _avg?: FoodKindRestaurantAvgOrderByAggregateInput
    _max?: FoodKindRestaurantMaxOrderByAggregateInput
    _min?: FoodKindRestaurantMinOrderByAggregateInput
    _sum?: FoodKindRestaurantSumOrderByAggregateInput
  }

  export type FoodKindRestaurantScalarWhereWithAggregatesInput = {
    AND?: FoodKindRestaurantScalarWhereWithAggregatesInput | FoodKindRestaurantScalarWhereWithAggregatesInput[]
    OR?: FoodKindRestaurantScalarWhereWithAggregatesInput[]
    NOT?: FoodKindRestaurantScalarWhereWithAggregatesInput | FoodKindRestaurantScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"FoodKindRestaurant"> | bigint | number
    foodKindId?: BigIntWithAggregatesFilter<"FoodKindRestaurant"> | bigint | number
    restaurantId?: BigIntWithAggregatesFilter<"FoodKindRestaurant"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"FoodKindRestaurant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodKindRestaurant"> | Date | string
    status?: IntWithAggregatesFilter<"FoodKindRestaurant"> | number
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: BigIntFilter<"Review"> | bigint | number
    memberId?: BigIntFilter<"Review"> | bigint | number
    restaurantId?: BigIntFilter<"Review"> | bigint | number
    rating?: DecimalFilter<"Review"> | Decimal | DecimalJsLike | number | string
    content?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    status?: IntFilter<"Review"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
    replys?: ReplyListRelationFilter
    images?: ImageListRelationFilter
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    restaurantId?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    member?: MemberOrderByWithRelationInput
    restaurant?: RestaurantOrderByWithRelationInput
    replys?: ReplyOrderByRelationAggregateInput
    images?: ImageOrderByRelationAggregateInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    memberId?: BigIntFilter<"Review"> | bigint | number
    restaurantId?: BigIntFilter<"Review"> | bigint | number
    rating?: DecimalFilter<"Review"> | Decimal | DecimalJsLike | number | string
    content?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    status?: IntFilter<"Review"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    restaurant?: XOR<RestaurantRelationFilter, RestaurantWhereInput>
    replys?: ReplyListRelationFilter
    images?: ImageListRelationFilter
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    restaurantId?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Review"> | bigint | number
    memberId?: BigIntWithAggregatesFilter<"Review"> | bigint | number
    restaurantId?: BigIntWithAggregatesFilter<"Review"> | bigint | number
    rating?: DecimalWithAggregatesFilter<"Review"> | Decimal | DecimalJsLike | number | string
    content?: StringWithAggregatesFilter<"Review"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    status?: IntWithAggregatesFilter<"Review"> | number
  }

  export type ReplyWhereInput = {
    AND?: ReplyWhereInput | ReplyWhereInput[]
    OR?: ReplyWhereInput[]
    NOT?: ReplyWhereInput | ReplyWhereInput[]
    id?: BigIntFilter<"Reply"> | bigint | number
    memberId?: BigIntFilter<"Reply"> | bigint | number
    reviewId?: BigIntFilter<"Reply"> | bigint | number
    content?: StringFilter<"Reply"> | string
    createdAt?: DateTimeFilter<"Reply"> | Date | string
    updatedAt?: DateTimeFilter<"Reply"> | Date | string
    status?: IntFilter<"Reply"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    review?: XOR<ReviewRelationFilter, ReviewWhereInput>
  }

  export type ReplyOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    reviewId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    member?: MemberOrderByWithRelationInput
    review?: ReviewOrderByWithRelationInput
  }

  export type ReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ReplyWhereInput | ReplyWhereInput[]
    OR?: ReplyWhereInput[]
    NOT?: ReplyWhereInput | ReplyWhereInput[]
    memberId?: BigIntFilter<"Reply"> | bigint | number
    reviewId?: BigIntFilter<"Reply"> | bigint | number
    content?: StringFilter<"Reply"> | string
    createdAt?: DateTimeFilter<"Reply"> | Date | string
    updatedAt?: DateTimeFilter<"Reply"> | Date | string
    status?: IntFilter<"Reply"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    review?: XOR<ReviewRelationFilter, ReviewWhereInput>
  }, "id">

  export type ReplyOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    reviewId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: ReplyCountOrderByAggregateInput
    _avg?: ReplyAvgOrderByAggregateInput
    _max?: ReplyMaxOrderByAggregateInput
    _min?: ReplyMinOrderByAggregateInput
    _sum?: ReplySumOrderByAggregateInput
  }

  export type ReplyScalarWhereWithAggregatesInput = {
    AND?: ReplyScalarWhereWithAggregatesInput | ReplyScalarWhereWithAggregatesInput[]
    OR?: ReplyScalarWhereWithAggregatesInput[]
    NOT?: ReplyScalarWhereWithAggregatesInput | ReplyScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Reply"> | bigint | number
    memberId?: BigIntWithAggregatesFilter<"Reply"> | bigint | number
    reviewId?: BigIntWithAggregatesFilter<"Reply"> | bigint | number
    content?: StringWithAggregatesFilter<"Reply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Reply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reply"> | Date | string
    status?: IntWithAggregatesFilter<"Reply"> | number
  }

  export type InquiryWhereInput = {
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    id?: BigIntFilter<"Inquiry"> | bigint | number
    memberId?: BigIntFilter<"Inquiry"> | bigint | number
    title?: StringFilter<"Inquiry"> | string
    content?: StringFilter<"Inquiry"> | string
    isConfirmed?: IntFilter<"Inquiry"> | number
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
    status?: IntFilter<"Inquiry"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    images?: ImageListRelationFilter
  }

  export type InquiryOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    member?: MemberOrderByWithRelationInput
    images?: ImageOrderByRelationAggregateInput
  }

  export type InquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    memberId?: BigIntFilter<"Inquiry"> | bigint | number
    title?: StringFilter<"Inquiry"> | string
    content?: StringFilter<"Inquiry"> | string
    isConfirmed?: IntFilter<"Inquiry"> | number
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
    status?: IntFilter<"Inquiry"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    images?: ImageListRelationFilter
  }, "id">

  export type InquiryOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: InquiryCountOrderByAggregateInput
    _avg?: InquiryAvgOrderByAggregateInput
    _max?: InquiryMaxOrderByAggregateInput
    _min?: InquiryMinOrderByAggregateInput
    _sum?: InquirySumOrderByAggregateInput
  }

  export type InquiryScalarWhereWithAggregatesInput = {
    AND?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    OR?: InquiryScalarWhereWithAggregatesInput[]
    NOT?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Inquiry"> | bigint | number
    memberId?: BigIntWithAggregatesFilter<"Inquiry"> | bigint | number
    title?: StringWithAggregatesFilter<"Inquiry"> | string
    content?: StringWithAggregatesFilter<"Inquiry"> | string
    isConfirmed?: IntWithAggregatesFilter<"Inquiry"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
    status?: IntWithAggregatesFilter<"Inquiry"> | number
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: BigIntFilter<"Image"> | bigint | number
    restaurantId?: BigIntNullableFilter<"Image"> | bigint | number | null
    reviewId?: BigIntNullableFilter<"Image"> | bigint | number | null
    inquiryId?: BigIntNullableFilter<"Image"> | bigint | number | null
    imageUrl?: StringFilter<"Image"> | string
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
    status?: IntFilter<"Image"> | number
    restaurant?: XOR<RestaurantNullableRelationFilter, RestaurantWhereInput> | null
    review?: XOR<ReviewNullableRelationFilter, ReviewWhereInput> | null
    inquiry?: XOR<InquiryNullableRelationFilter, InquiryWhereInput> | null
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    restaurantId?: SortOrderInput | SortOrder
    reviewId?: SortOrderInput | SortOrder
    inquiryId?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
    review?: ReviewOrderByWithRelationInput
    inquiry?: InquiryOrderByWithRelationInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    restaurantId?: BigIntNullableFilter<"Image"> | bigint | number | null
    reviewId?: BigIntNullableFilter<"Image"> | bigint | number | null
    inquiryId?: BigIntNullableFilter<"Image"> | bigint | number | null
    imageUrl?: StringFilter<"Image"> | string
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
    status?: IntFilter<"Image"> | number
    restaurant?: XOR<RestaurantNullableRelationFilter, RestaurantWhereInput> | null
    review?: XOR<ReviewNullableRelationFilter, ReviewWhereInput> | null
    inquiry?: XOR<InquiryNullableRelationFilter, InquiryWhereInput> | null
  }, "id">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    restaurantId?: SortOrderInput | SortOrder
    reviewId?: SortOrderInput | SortOrder
    inquiryId?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Image"> | bigint | number
    restaurantId?: BigIntNullableWithAggregatesFilter<"Image"> | bigint | number | null
    reviewId?: BigIntNullableWithAggregatesFilter<"Image"> | bigint | number | null
    inquiryId?: BigIntNullableWithAggregatesFilter<"Image"> | bigint | number | null
    imageUrl?: StringWithAggregatesFilter<"Image"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    status?: IntWithAggregatesFilter<"Image"> | number
  }

  export type AlarmWhereInput = {
    AND?: AlarmWhereInput | AlarmWhereInput[]
    OR?: AlarmWhereInput[]
    NOT?: AlarmWhereInput | AlarmWhereInput[]
    id?: BigIntFilter<"Alarm"> | bigint | number
    memberId?: BigIntFilter<"Alarm"> | bigint | number
    isConfirmed?: IntFilter<"Alarm"> | number
    createdAt?: DateTimeFilter<"Alarm"> | Date | string
    updatedAt?: DateTimeFilter<"Alarm"> | Date | string
    status?: IntFilter<"Alarm"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    alarmsNewMissions?: AlarmNewMissionListRelationFilter
    alarmReviewRequest?: AlarmReviewRequestListRelationFilter
  }

  export type AlarmOrderByWithRelationInput = {
    id?: SortOrder
    memberId?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    member?: MemberOrderByWithRelationInput
    alarmsNewMissions?: AlarmNewMissionOrderByRelationAggregateInput
    alarmReviewRequest?: AlarmReviewRequestOrderByRelationAggregateInput
  }

  export type AlarmWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AlarmWhereInput | AlarmWhereInput[]
    OR?: AlarmWhereInput[]
    NOT?: AlarmWhereInput | AlarmWhereInput[]
    memberId?: BigIntFilter<"Alarm"> | bigint | number
    isConfirmed?: IntFilter<"Alarm"> | number
    createdAt?: DateTimeFilter<"Alarm"> | Date | string
    updatedAt?: DateTimeFilter<"Alarm"> | Date | string
    status?: IntFilter<"Alarm"> | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    alarmsNewMissions?: AlarmNewMissionListRelationFilter
    alarmReviewRequest?: AlarmReviewRequestListRelationFilter
  }, "id">

  export type AlarmOrderByWithAggregationInput = {
    id?: SortOrder
    memberId?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: AlarmCountOrderByAggregateInput
    _avg?: AlarmAvgOrderByAggregateInput
    _max?: AlarmMaxOrderByAggregateInput
    _min?: AlarmMinOrderByAggregateInput
    _sum?: AlarmSumOrderByAggregateInput
  }

  export type AlarmScalarWhereWithAggregatesInput = {
    AND?: AlarmScalarWhereWithAggregatesInput | AlarmScalarWhereWithAggregatesInput[]
    OR?: AlarmScalarWhereWithAggregatesInput[]
    NOT?: AlarmScalarWhereWithAggregatesInput | AlarmScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Alarm"> | bigint | number
    memberId?: BigIntWithAggregatesFilter<"Alarm"> | bigint | number
    isConfirmed?: IntWithAggregatesFilter<"Alarm"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Alarm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alarm"> | Date | string
    status?: IntWithAggregatesFilter<"Alarm"> | number
  }

  export type AlarmNewMissionWhereInput = {
    AND?: AlarmNewMissionWhereInput | AlarmNewMissionWhereInput[]
    OR?: AlarmNewMissionWhereInput[]
    NOT?: AlarmNewMissionWhereInput | AlarmNewMissionWhereInput[]
    id?: BigIntFilter<"AlarmNewMission"> | bigint | number
    alarmId?: BigIntFilter<"AlarmNewMission"> | bigint | number
    title?: StringFilter<"AlarmNewMission"> | string
    body?: StringFilter<"AlarmNewMission"> | string
    createdAt?: DateTimeFilter<"AlarmNewMission"> | Date | string
    updatedAt?: DateTimeFilter<"AlarmNewMission"> | Date | string
    status?: IntFilter<"AlarmNewMission"> | number
    alarm?: XOR<AlarmRelationFilter, AlarmWhereInput>
  }

  export type AlarmNewMissionOrderByWithRelationInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    alarm?: AlarmOrderByWithRelationInput
  }

  export type AlarmNewMissionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AlarmNewMissionWhereInput | AlarmNewMissionWhereInput[]
    OR?: AlarmNewMissionWhereInput[]
    NOT?: AlarmNewMissionWhereInput | AlarmNewMissionWhereInput[]
    alarmId?: BigIntFilter<"AlarmNewMission"> | bigint | number
    title?: StringFilter<"AlarmNewMission"> | string
    body?: StringFilter<"AlarmNewMission"> | string
    createdAt?: DateTimeFilter<"AlarmNewMission"> | Date | string
    updatedAt?: DateTimeFilter<"AlarmNewMission"> | Date | string
    status?: IntFilter<"AlarmNewMission"> | number
    alarm?: XOR<AlarmRelationFilter, AlarmWhereInput>
  }, "id">

  export type AlarmNewMissionOrderByWithAggregationInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: AlarmNewMissionCountOrderByAggregateInput
    _avg?: AlarmNewMissionAvgOrderByAggregateInput
    _max?: AlarmNewMissionMaxOrderByAggregateInput
    _min?: AlarmNewMissionMinOrderByAggregateInput
    _sum?: AlarmNewMissionSumOrderByAggregateInput
  }

  export type AlarmNewMissionScalarWhereWithAggregatesInput = {
    AND?: AlarmNewMissionScalarWhereWithAggregatesInput | AlarmNewMissionScalarWhereWithAggregatesInput[]
    OR?: AlarmNewMissionScalarWhereWithAggregatesInput[]
    NOT?: AlarmNewMissionScalarWhereWithAggregatesInput | AlarmNewMissionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"AlarmNewMission"> | bigint | number
    alarmId?: BigIntWithAggregatesFilter<"AlarmNewMission"> | bigint | number
    title?: StringWithAggregatesFilter<"AlarmNewMission"> | string
    body?: StringWithAggregatesFilter<"AlarmNewMission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AlarmNewMission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AlarmNewMission"> | Date | string
    status?: IntWithAggregatesFilter<"AlarmNewMission"> | number
  }

  export type AlarmReviewRequestWhereInput = {
    AND?: AlarmReviewRequestWhereInput | AlarmReviewRequestWhereInput[]
    OR?: AlarmReviewRequestWhereInput[]
    NOT?: AlarmReviewRequestWhereInput | AlarmReviewRequestWhereInput[]
    id?: BigIntFilter<"AlarmReviewRequest"> | bigint | number
    alarmId?: BigIntFilter<"AlarmReviewRequest"> | bigint | number
    title?: StringFilter<"AlarmReviewRequest"> | string
    body?: StringFilter<"AlarmReviewRequest"> | string
    createdAt?: DateTimeFilter<"AlarmReviewRequest"> | Date | string
    updatedAt?: DateTimeFilter<"AlarmReviewRequest"> | Date | string
    status?: IntFilter<"AlarmReviewRequest"> | number
    alarm?: XOR<AlarmRelationFilter, AlarmWhereInput>
  }

  export type AlarmReviewRequestOrderByWithRelationInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    alarm?: AlarmOrderByWithRelationInput
  }

  export type AlarmReviewRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AlarmReviewRequestWhereInput | AlarmReviewRequestWhereInput[]
    OR?: AlarmReviewRequestWhereInput[]
    NOT?: AlarmReviewRequestWhereInput | AlarmReviewRequestWhereInput[]
    alarmId?: BigIntFilter<"AlarmReviewRequest"> | bigint | number
    title?: StringFilter<"AlarmReviewRequest"> | string
    body?: StringFilter<"AlarmReviewRequest"> | string
    createdAt?: DateTimeFilter<"AlarmReviewRequest"> | Date | string
    updatedAt?: DateTimeFilter<"AlarmReviewRequest"> | Date | string
    status?: IntFilter<"AlarmReviewRequest"> | number
    alarm?: XOR<AlarmRelationFilter, AlarmWhereInput>
  }, "id">

  export type AlarmReviewRequestOrderByWithAggregationInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: AlarmReviewRequestCountOrderByAggregateInput
    _avg?: AlarmReviewRequestAvgOrderByAggregateInput
    _max?: AlarmReviewRequestMaxOrderByAggregateInput
    _min?: AlarmReviewRequestMinOrderByAggregateInput
    _sum?: AlarmReviewRequestSumOrderByAggregateInput
  }

  export type AlarmReviewRequestScalarWhereWithAggregatesInput = {
    AND?: AlarmReviewRequestScalarWhereWithAggregatesInput | AlarmReviewRequestScalarWhereWithAggregatesInput[]
    OR?: AlarmReviewRequestScalarWhereWithAggregatesInput[]
    NOT?: AlarmReviewRequestScalarWhereWithAggregatesInput | AlarmReviewRequestScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"AlarmReviewRequest"> | bigint | number
    alarmId?: BigIntWithAggregatesFilter<"AlarmReviewRequest"> | bigint | number
    title?: StringWithAggregatesFilter<"AlarmReviewRequest"> | string
    body?: StringWithAggregatesFilter<"AlarmReviewRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AlarmReviewRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AlarmReviewRequest"> | Date | string
    status?: IntWithAggregatesFilter<"AlarmReviewRequest"> | number
  }

  export type MemberCreateInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionCreateNestedManyWithoutMemberInput
    reviews?: ReviewCreateNestedManyWithoutMemberInput
    reply?: ReplyCreateNestedManyWithoutMemberInput
    inquiries?: InquiryCreateNestedManyWithoutMemberInput
    alarms?: AlarmCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionUncheckedCreateNestedManyWithoutMemberInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMemberInput
    reply?: ReplyUncheckedCreateNestedManyWithoutMemberInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutMemberInput
    alarms?: AlarmUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUpdateManyWithoutMemberNestedInput
    reply?: ReplyUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUncheckedUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMemberNestedInput
    reply?: ReplyUncheckedUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateManyInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
  }

  export type MemberUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FoodKindCreateInput = {
    id?: bigint | number
    kind: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindCreateNestedManyWithoutFoodKindInput
    foodKindRestaurants?: FoodKindRestaurantCreateNestedManyWithoutFoodKindInput
  }

  export type FoodKindUncheckedCreateInput = {
    id?: bigint | number
    kind: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutFoodKindInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedCreateNestedManyWithoutFoodKindInput
  }

  export type FoodKindUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    kind?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUpdateManyWithoutFoodKindNestedInput
    foodKindRestaurants?: FoodKindRestaurantUpdateManyWithoutFoodKindNestedInput
  }

  export type FoodKindUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    kind?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedUpdateManyWithoutFoodKindNestedInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedUpdateManyWithoutFoodKindNestedInput
  }

  export type FoodKindCreateManyInput = {
    id?: bigint | number
    kind: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type FoodKindUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    kind?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type FoodKindUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    kind?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberFavoriteFoodKindCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutMemberfavoriteFoodKindsInput
    foodKind: FoodKindCreateNestedOneWithoutMemberfavoriteFoodKindsInput
  }

  export type MemberFavoriteFoodKindUncheckedCreateInput = {
    id?: bigint | number
    memberId: bigint | number
    foodKindId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberFavoriteFoodKindUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutMemberfavoriteFoodKindsNestedInput
    foodKind?: FoodKindUpdateOneRequiredWithoutMemberfavoriteFoodKindsNestedInput
  }

  export type MemberFavoriteFoodKindUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    foodKindId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberFavoriteFoodKindCreateManyInput = {
    id?: bigint | number
    memberId: bigint | number
    foodKindId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberFavoriteFoodKindUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberFavoriteFoodKindUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    foodKindId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type RegionCreateInput = {
    id?: bigint | number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    restaurant?: RestaurantCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: bigint | number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    restaurant?: RestaurantUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: bigint | number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type RegionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantCreateInput = {
    id?: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    ceo: MemberCreateNestedOneWithoutRestaurantsInput
    region: RegionCreateNestedOneWithoutRestaurantInput
    missions?: MissionCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewCreateNestedManyWithoutRestaurantInput
    images?: ImageCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateInput = {
    id?: bigint | number
    ceoId: bigint | number
    regionId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    missions?: MissionUncheckedCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRestaurantInput
    images?: ImageUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    ceo?: MemberUpdateOneRequiredWithoutRestaurantsNestedInput
    region?: RegionUpdateOneRequiredWithoutRestaurantNestedInput
    missions?: MissionUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUpdateManyWithoutRestaurantNestedInput
    images?: ImageUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ceoId?: BigIntFieldUpdateOperationsInput | bigint | number
    regionId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    missions?: MissionUncheckedUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRestaurantNestedInput
    images?: ImageUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantCreateManyInput = {
    id?: bigint | number
    ceoId: bigint | number
    regionId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type RestaurantUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ceoId?: BigIntFieldUpdateOperationsInput | bigint | number
    regionId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MissionCreateInput = {
    id?: bigint | number
    name: string
    introduction: string
    deadline: Date | string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    restaurant: RestaurantCreateNestedOneWithoutMissionsInput
    memberMission?: MemberMissionCreateNestedManyWithoutMissionInput
  }

  export type MissionUncheckedCreateInput = {
    id?: bigint | number
    restaurantId: bigint | number
    name: string
    introduction: string
    deadline: Date | string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    memberMission?: MemberMissionUncheckedCreateNestedManyWithoutMissionInput
  }

  export type MissionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutMissionsNestedInput
    memberMission?: MemberMissionUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    memberMission?: MemberMissionUncheckedUpdateManyWithoutMissionNestedInput
  }

  export type MissionCreateManyInput = {
    id?: bigint | number
    restaurantId: bigint | number
    name: string
    introduction: string
    deadline: Date | string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MissionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MissionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberMissionCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutMemberMissionsInput
    mission: MissionCreateNestedOneWithoutMemberMissionInput
  }

  export type MemberMissionUncheckedCreateInput = {
    id?: bigint | number
    memberId: bigint | number
    missionId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberMissionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutMemberMissionsNestedInput
    mission?: MissionUpdateOneRequiredWithoutMemberMissionNestedInput
  }

  export type MemberMissionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    missionId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberMissionCreateManyInput = {
    id?: bigint | number
    memberId: bigint | number
    missionId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberMissionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberMissionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    missionId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type FoodKindRestaurantCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    foodKind: FoodKindCreateNestedOneWithoutFoodKindRestaurantsInput
    restaurant: RestaurantCreateNestedOneWithoutFoodKindRestaurantsInput
  }

  export type FoodKindRestaurantUncheckedCreateInput = {
    id?: bigint | number
    foodKindId: bigint | number
    restaurantId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type FoodKindRestaurantUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    foodKind?: FoodKindUpdateOneRequiredWithoutFoodKindRestaurantsNestedInput
    restaurant?: RestaurantUpdateOneRequiredWithoutFoodKindRestaurantsNestedInput
  }

  export type FoodKindRestaurantUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    foodKindId?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type FoodKindRestaurantCreateManyInput = {
    id?: bigint | number
    foodKindId: bigint | number
    restaurantId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type FoodKindRestaurantUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type FoodKindRestaurantUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    foodKindId?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateInput = {
    id?: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutReviewsInput
    restaurant: RestaurantCreateNestedOneWithoutReviewsInput
    replys?: ReplyCreateNestedManyWithoutReviewInput
    images?: ImageCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: bigint | number
    memberId: bigint | number
    restaurantId: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    replys?: ReplyUncheckedCreateNestedManyWithoutReviewInput
    images?: ImageUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutReviewsNestedInput
    restaurant?: RestaurantUpdateOneRequiredWithoutReviewsNestedInput
    replys?: ReplyUpdateManyWithoutReviewNestedInput
    images?: ImageUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    replys?: ReplyUncheckedUpdateManyWithoutReviewNestedInput
    images?: ImageUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateManyInput = {
    id?: bigint | number
    memberId: bigint | number
    restaurantId: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ReviewUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReplyCreateInput = {
    id?: bigint | number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutReplyInput
    review: ReviewCreateNestedOneWithoutReplysInput
  }

  export type ReplyUncheckedCreateInput = {
    id?: bigint | number
    memberId: bigint | number
    reviewId: bigint | number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ReplyUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutReplyNestedInput
    review?: ReviewUpdateOneRequiredWithoutReplysNestedInput
  }

  export type ReplyUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReplyCreateManyInput = {
    id?: bigint | number
    memberId: bigint | number
    reviewId: bigint | number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ReplyUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReplyUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type InquiryCreateInput = {
    id?: bigint | number
    title: string
    content: string
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutInquiriesInput
    images?: ImageCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUncheckedCreateInput = {
    id?: bigint | number
    memberId: bigint | number
    title: string
    content: string
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    images?: ImageUncheckedCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutInquiriesNestedInput
    images?: ImageUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    images?: ImageUncheckedUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryCreateManyInput = {
    id?: bigint | number
    memberId: bigint | number
    title: string
    content: string
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type InquiryUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type InquiryUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ImageCreateInput = {
    id?: bigint | number
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    restaurant?: RestaurantCreateNestedOneWithoutImagesInput
    review?: ReviewCreateNestedOneWithoutImagesInput
    inquiry?: InquiryCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateInput = {
    id?: bigint | number
    restaurantId?: bigint | number | null
    reviewId?: bigint | number | null
    inquiryId?: bigint | number | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ImageUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneWithoutImagesNestedInput
    review?: ReviewUpdateOneWithoutImagesNestedInput
    inquiry?: InquiryUpdateOneWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reviewId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    inquiryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ImageCreateManyInput = {
    id?: bigint | number
    restaurantId?: bigint | number | null
    reviewId?: bigint | number | null
    inquiryId?: bigint | number | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ImageUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reviewId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    inquiryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmCreateInput = {
    id?: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutAlarmsInput
    alarmsNewMissions?: AlarmNewMissionCreateNestedManyWithoutAlarmInput
    alarmReviewRequest?: AlarmReviewRequestCreateNestedManyWithoutAlarmInput
  }

  export type AlarmUncheckedCreateInput = {
    id?: bigint | number
    memberId: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    alarmsNewMissions?: AlarmNewMissionUncheckedCreateNestedManyWithoutAlarmInput
    alarmReviewRequest?: AlarmReviewRequestUncheckedCreateNestedManyWithoutAlarmInput
  }

  export type AlarmUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutAlarmsNestedInput
    alarmsNewMissions?: AlarmNewMissionUpdateManyWithoutAlarmNestedInput
    alarmReviewRequest?: AlarmReviewRequestUpdateManyWithoutAlarmNestedInput
  }

  export type AlarmUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    alarmsNewMissions?: AlarmNewMissionUncheckedUpdateManyWithoutAlarmNestedInput
    alarmReviewRequest?: AlarmReviewRequestUncheckedUpdateManyWithoutAlarmNestedInput
  }

  export type AlarmCreateManyInput = {
    id?: bigint | number
    memberId: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmNewMissionCreateInput = {
    id?: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    alarm: AlarmCreateNestedOneWithoutAlarmsNewMissionsInput
  }

  export type AlarmNewMissionUncheckedCreateInput = {
    id?: bigint | number
    alarmId: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmNewMissionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    alarm?: AlarmUpdateOneRequiredWithoutAlarmsNewMissionsNestedInput
  }

  export type AlarmNewMissionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    alarmId?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmNewMissionCreateManyInput = {
    id?: bigint | number
    alarmId: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmNewMissionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmNewMissionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    alarmId?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmReviewRequestCreateInput = {
    id?: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    alarm: AlarmCreateNestedOneWithoutAlarmReviewRequestInput
  }

  export type AlarmReviewRequestUncheckedCreateInput = {
    id?: bigint | number
    alarmId: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmReviewRequestUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    alarm?: AlarmUpdateOneRequiredWithoutAlarmReviewRequestNestedInput
  }

  export type AlarmReviewRequestUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    alarmId?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmReviewRequestCreateManyInput = {
    id?: bigint | number
    alarmId: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmReviewRequestUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmReviewRequestUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    alarmId?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MemberFavoriteFoodKindListRelationFilter = {
    every?: MemberFavoriteFoodKindWhereInput
    some?: MemberFavoriteFoodKindWhereInput
    none?: MemberFavoriteFoodKindWhereInput
  }

  export type RestaurantListRelationFilter = {
    every?: RestaurantWhereInput
    some?: RestaurantWhereInput
    none?: RestaurantWhereInput
  }

  export type MemberMissionListRelationFilter = {
    every?: MemberMissionWhereInput
    some?: MemberMissionWhereInput
    none?: MemberMissionWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ReplyListRelationFilter = {
    every?: ReplyWhereInput
    some?: ReplyWhereInput
    none?: ReplyWhereInput
  }

  export type InquiryListRelationFilter = {
    every?: InquiryWhereInput
    some?: InquiryWhereInput
    none?: InquiryWhereInput
  }

  export type AlarmListRelationFilter = {
    every?: AlarmWhereInput
    some?: AlarmWhereInput
    none?: AlarmWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MemberFavoriteFoodKindOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberMissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlarmOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    nickname?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    inactiveAt?: SortOrder
  }

  export type MemberAvgOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    points?: SortOrder
    status?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    nickname?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    inactiveAt?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    location?: SortOrder
    phoneNumber?: SortOrder
    nickname?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    inactiveAt?: SortOrder
  }

  export type MemberSumOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    points?: SortOrder
    status?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FoodKindRestaurantListRelationFilter = {
    every?: FoodKindRestaurantWhereInput
    some?: FoodKindRestaurantWhereInput
    none?: FoodKindRestaurantWhereInput
  }

  export type FoodKindRestaurantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodKindCountOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type FoodKindAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type FoodKindMaxOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type FoodKindMinOrderByAggregateInput = {
    id?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type FoodKindSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type MemberRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type FoodKindRelationFilter = {
    is?: FoodKindWhereInput
    isNot?: FoodKindWhereInput
  }

  export type MemberFavoriteFoodKindCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    foodKindId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type MemberFavoriteFoodKindAvgOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    foodKindId?: SortOrder
    status?: SortOrder
  }

  export type MemberFavoriteFoodKindMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    foodKindId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type MemberFavoriteFoodKindMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    foodKindId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type MemberFavoriteFoodKindSumOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    foodKindId?: SortOrder
    status?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type RegionRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type MissionListRelationFilter = {
    every?: MissionWhereInput
    some?: MissionWhereInput
    none?: MissionWhereInput
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type MissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantCountOrderByAggregateInput = {
    id?: SortOrder
    ceoId?: SortOrder
    regionId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    totalRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type RestaurantAvgOrderByAggregateInput = {
    id?: SortOrder
    ceoId?: SortOrder
    regionId?: SortOrder
    totalRating?: SortOrder
    status?: SortOrder
  }

  export type RestaurantMaxOrderByAggregateInput = {
    id?: SortOrder
    ceoId?: SortOrder
    regionId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    totalRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type RestaurantMinOrderByAggregateInput = {
    id?: SortOrder
    ceoId?: SortOrder
    regionId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    totalRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type RestaurantSumOrderByAggregateInput = {
    id?: SortOrder
    ceoId?: SortOrder
    regionId?: SortOrder
    totalRating?: SortOrder
    status?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type RestaurantRelationFilter = {
    is?: RestaurantWhereInput
    isNot?: RestaurantWhereInput
  }

  export type MissionCountOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    deadline?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type MissionAvgOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    points?: SortOrder
    status?: SortOrder
  }

  export type MissionMaxOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    deadline?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type MissionMinOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    deadline?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type MissionSumOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    points?: SortOrder
    status?: SortOrder
  }

  export type MissionRelationFilter = {
    is?: MissionWhereInput
    isNot?: MissionWhereInput
  }

  export type MemberMissionMemberId_missionId_uniqueCompoundUniqueInput = {
    memberId: bigint | number
    missionId: bigint | number
  }

  export type MemberMissionCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    missionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type MemberMissionAvgOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    missionId?: SortOrder
    status?: SortOrder
  }

  export type MemberMissionMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    missionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type MemberMissionMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    missionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type MemberMissionSumOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    missionId?: SortOrder
    status?: SortOrder
  }

  export type FoodKindRestaurantCountOrderByAggregateInput = {
    id?: SortOrder
    foodKindId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type FoodKindRestaurantAvgOrderByAggregateInput = {
    id?: SortOrder
    foodKindId?: SortOrder
    restaurantId?: SortOrder
    status?: SortOrder
  }

  export type FoodKindRestaurantMaxOrderByAggregateInput = {
    id?: SortOrder
    foodKindId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type FoodKindRestaurantMinOrderByAggregateInput = {
    id?: SortOrder
    foodKindId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type FoodKindRestaurantSumOrderByAggregateInput = {
    id?: SortOrder
    foodKindId?: SortOrder
    restaurantId?: SortOrder
    status?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    restaurantId?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    restaurantId?: SortOrder
    rating?: SortOrder
    status?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    restaurantId?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    restaurantId?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    restaurantId?: SortOrder
    rating?: SortOrder
    status?: SortOrder
  }

  export type ReviewRelationFilter = {
    is?: ReviewWhereInput
    isNot?: ReviewWhereInput
  }

  export type ReplyCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    reviewId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ReplyAvgOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    reviewId?: SortOrder
    status?: SortOrder
  }

  export type ReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    reviewId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ReplyMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    reviewId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ReplySumOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    reviewId?: SortOrder
    status?: SortOrder
  }

  export type InquiryCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type InquiryAvgOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    isConfirmed?: SortOrder
    status?: SortOrder
  }

  export type InquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type InquiryMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type InquirySumOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    isConfirmed?: SortOrder
    status?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type RestaurantNullableRelationFilter = {
    is?: RestaurantWhereInput | null
    isNot?: RestaurantWhereInput | null
  }

  export type ReviewNullableRelationFilter = {
    is?: ReviewWhereInput | null
    isNot?: ReviewWhereInput | null
  }

  export type InquiryNullableRelationFilter = {
    is?: InquiryWhereInput | null
    isNot?: InquiryWhereInput | null
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    reviewId?: SortOrder
    inquiryId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    reviewId?: SortOrder
    inquiryId?: SortOrder
    status?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    reviewId?: SortOrder
    inquiryId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    reviewId?: SortOrder
    inquiryId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    id?: SortOrder
    restaurantId?: SortOrder
    reviewId?: SortOrder
    inquiryId?: SortOrder
    status?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type AlarmNewMissionListRelationFilter = {
    every?: AlarmNewMissionWhereInput
    some?: AlarmNewMissionWhereInput
    none?: AlarmNewMissionWhereInput
  }

  export type AlarmReviewRequestListRelationFilter = {
    every?: AlarmReviewRequestWhereInput
    some?: AlarmReviewRequestWhereInput
    none?: AlarmReviewRequestWhereInput
  }

  export type AlarmNewMissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlarmReviewRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlarmCountOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AlarmAvgOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    isConfirmed?: SortOrder
    status?: SortOrder
  }

  export type AlarmMaxOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AlarmMinOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    isConfirmed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AlarmSumOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    isConfirmed?: SortOrder
    status?: SortOrder
  }

  export type AlarmRelationFilter = {
    is?: AlarmWhereInput
    isNot?: AlarmWhereInput
  }

  export type AlarmNewMissionCountOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AlarmNewMissionAvgOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    status?: SortOrder
  }

  export type AlarmNewMissionMaxOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AlarmNewMissionMinOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AlarmNewMissionSumOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    status?: SortOrder
  }

  export type AlarmReviewRequestCountOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AlarmReviewRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    status?: SortOrder
  }

  export type AlarmReviewRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AlarmReviewRequestMinOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type AlarmReviewRequestSumOrderByAggregateInput = {
    id?: SortOrder
    alarmId?: SortOrder
    status?: SortOrder
  }

  export type MemberFavoriteFoodKindCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberFavoriteFoodKindCreateWithoutMemberInput, MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput> | MemberFavoriteFoodKindCreateWithoutMemberInput[] | MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberFavoriteFoodKindCreateOrConnectWithoutMemberInput | MemberFavoriteFoodKindCreateOrConnectWithoutMemberInput[]
    createMany?: MemberFavoriteFoodKindCreateManyMemberInputEnvelope
    connect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
  }

  export type RestaurantCreateNestedManyWithoutCeoInput = {
    create?: XOR<RestaurantCreateWithoutCeoInput, RestaurantUncheckedCreateWithoutCeoInput> | RestaurantCreateWithoutCeoInput[] | RestaurantUncheckedCreateWithoutCeoInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutCeoInput | RestaurantCreateOrConnectWithoutCeoInput[]
    createMany?: RestaurantCreateManyCeoInputEnvelope
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
  }

  export type MemberMissionCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberMissionCreateWithoutMemberInput, MemberMissionUncheckedCreateWithoutMemberInput> | MemberMissionCreateWithoutMemberInput[] | MemberMissionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberMissionCreateOrConnectWithoutMemberInput | MemberMissionCreateOrConnectWithoutMemberInput[]
    createMany?: MemberMissionCreateManyMemberInputEnvelope
    connect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutMemberInput = {
    create?: XOR<ReviewCreateWithoutMemberInput, ReviewUncheckedCreateWithoutMemberInput> | ReviewCreateWithoutMemberInput[] | ReviewUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMemberInput | ReviewCreateOrConnectWithoutMemberInput[]
    createMany?: ReviewCreateManyMemberInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReplyCreateNestedManyWithoutMemberInput = {
    create?: XOR<ReplyCreateWithoutMemberInput, ReplyUncheckedCreateWithoutMemberInput> | ReplyCreateWithoutMemberInput[] | ReplyUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutMemberInput | ReplyCreateOrConnectWithoutMemberInput[]
    createMany?: ReplyCreateManyMemberInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type InquiryCreateNestedManyWithoutMemberInput = {
    create?: XOR<InquiryCreateWithoutMemberInput, InquiryUncheckedCreateWithoutMemberInput> | InquiryCreateWithoutMemberInput[] | InquiryUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutMemberInput | InquiryCreateOrConnectWithoutMemberInput[]
    createMany?: InquiryCreateManyMemberInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type AlarmCreateNestedManyWithoutMemberInput = {
    create?: XOR<AlarmCreateWithoutMemberInput, AlarmUncheckedCreateWithoutMemberInput> | AlarmCreateWithoutMemberInput[] | AlarmUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: AlarmCreateOrConnectWithoutMemberInput | AlarmCreateOrConnectWithoutMemberInput[]
    createMany?: AlarmCreateManyMemberInputEnvelope
    connect?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
  }

  export type MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberFavoriteFoodKindCreateWithoutMemberInput, MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput> | MemberFavoriteFoodKindCreateWithoutMemberInput[] | MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberFavoriteFoodKindCreateOrConnectWithoutMemberInput | MemberFavoriteFoodKindCreateOrConnectWithoutMemberInput[]
    createMany?: MemberFavoriteFoodKindCreateManyMemberInputEnvelope
    connect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
  }

  export type RestaurantUncheckedCreateNestedManyWithoutCeoInput = {
    create?: XOR<RestaurantCreateWithoutCeoInput, RestaurantUncheckedCreateWithoutCeoInput> | RestaurantCreateWithoutCeoInput[] | RestaurantUncheckedCreateWithoutCeoInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutCeoInput | RestaurantCreateOrConnectWithoutCeoInput[]
    createMany?: RestaurantCreateManyCeoInputEnvelope
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
  }

  export type MemberMissionUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberMissionCreateWithoutMemberInput, MemberMissionUncheckedCreateWithoutMemberInput> | MemberMissionCreateWithoutMemberInput[] | MemberMissionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberMissionCreateOrConnectWithoutMemberInput | MemberMissionCreateOrConnectWithoutMemberInput[]
    createMany?: MemberMissionCreateManyMemberInputEnvelope
    connect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<ReviewCreateWithoutMemberInput, ReviewUncheckedCreateWithoutMemberInput> | ReviewCreateWithoutMemberInput[] | ReviewUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMemberInput | ReviewCreateOrConnectWithoutMemberInput[]
    createMany?: ReviewCreateManyMemberInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReplyUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<ReplyCreateWithoutMemberInput, ReplyUncheckedCreateWithoutMemberInput> | ReplyCreateWithoutMemberInput[] | ReplyUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutMemberInput | ReplyCreateOrConnectWithoutMemberInput[]
    createMany?: ReplyCreateManyMemberInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<InquiryCreateWithoutMemberInput, InquiryUncheckedCreateWithoutMemberInput> | InquiryCreateWithoutMemberInput[] | InquiryUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutMemberInput | InquiryCreateOrConnectWithoutMemberInput[]
    createMany?: InquiryCreateManyMemberInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type AlarmUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<AlarmCreateWithoutMemberInput, AlarmUncheckedCreateWithoutMemberInput> | AlarmCreateWithoutMemberInput[] | AlarmUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: AlarmCreateOrConnectWithoutMemberInput | AlarmCreateOrConnectWithoutMemberInput[]
    createMany?: AlarmCreateManyMemberInputEnvelope
    connect?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MemberFavoriteFoodKindUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberFavoriteFoodKindCreateWithoutMemberInput, MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput> | MemberFavoriteFoodKindCreateWithoutMemberInput[] | MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberFavoriteFoodKindCreateOrConnectWithoutMemberInput | MemberFavoriteFoodKindCreateOrConnectWithoutMemberInput[]
    upsert?: MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutMemberInput | MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberFavoriteFoodKindCreateManyMemberInputEnvelope
    set?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    disconnect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    delete?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    connect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    update?: MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutMemberInput | MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberFavoriteFoodKindUpdateManyWithWhereWithoutMemberInput | MemberFavoriteFoodKindUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberFavoriteFoodKindScalarWhereInput | MemberFavoriteFoodKindScalarWhereInput[]
  }

  export type RestaurantUpdateManyWithoutCeoNestedInput = {
    create?: XOR<RestaurantCreateWithoutCeoInput, RestaurantUncheckedCreateWithoutCeoInput> | RestaurantCreateWithoutCeoInput[] | RestaurantUncheckedCreateWithoutCeoInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutCeoInput | RestaurantCreateOrConnectWithoutCeoInput[]
    upsert?: RestaurantUpsertWithWhereUniqueWithoutCeoInput | RestaurantUpsertWithWhereUniqueWithoutCeoInput[]
    createMany?: RestaurantCreateManyCeoInputEnvelope
    set?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    disconnect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    delete?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    update?: RestaurantUpdateWithWhereUniqueWithoutCeoInput | RestaurantUpdateWithWhereUniqueWithoutCeoInput[]
    updateMany?: RestaurantUpdateManyWithWhereWithoutCeoInput | RestaurantUpdateManyWithWhereWithoutCeoInput[]
    deleteMany?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
  }

  export type MemberMissionUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberMissionCreateWithoutMemberInput, MemberMissionUncheckedCreateWithoutMemberInput> | MemberMissionCreateWithoutMemberInput[] | MemberMissionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberMissionCreateOrConnectWithoutMemberInput | MemberMissionCreateOrConnectWithoutMemberInput[]
    upsert?: MemberMissionUpsertWithWhereUniqueWithoutMemberInput | MemberMissionUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberMissionCreateManyMemberInputEnvelope
    set?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    disconnect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    delete?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    connect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    update?: MemberMissionUpdateWithWhereUniqueWithoutMemberInput | MemberMissionUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberMissionUpdateManyWithWhereWithoutMemberInput | MemberMissionUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberMissionScalarWhereInput | MemberMissionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ReviewCreateWithoutMemberInput, ReviewUncheckedCreateWithoutMemberInput> | ReviewCreateWithoutMemberInput[] | ReviewUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMemberInput | ReviewCreateOrConnectWithoutMemberInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutMemberInput | ReviewUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ReviewCreateManyMemberInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutMemberInput | ReviewUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutMemberInput | ReviewUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReplyUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ReplyCreateWithoutMemberInput, ReplyUncheckedCreateWithoutMemberInput> | ReplyCreateWithoutMemberInput[] | ReplyUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutMemberInput | ReplyCreateOrConnectWithoutMemberInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutMemberInput | ReplyUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ReplyCreateManyMemberInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutMemberInput | ReplyUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutMemberInput | ReplyUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type InquiryUpdateManyWithoutMemberNestedInput = {
    create?: XOR<InquiryCreateWithoutMemberInput, InquiryUncheckedCreateWithoutMemberInput> | InquiryCreateWithoutMemberInput[] | InquiryUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutMemberInput | InquiryCreateOrConnectWithoutMemberInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutMemberInput | InquiryUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: InquiryCreateManyMemberInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutMemberInput | InquiryUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutMemberInput | InquiryUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type AlarmUpdateManyWithoutMemberNestedInput = {
    create?: XOR<AlarmCreateWithoutMemberInput, AlarmUncheckedCreateWithoutMemberInput> | AlarmCreateWithoutMemberInput[] | AlarmUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: AlarmCreateOrConnectWithoutMemberInput | AlarmCreateOrConnectWithoutMemberInput[]
    upsert?: AlarmUpsertWithWhereUniqueWithoutMemberInput | AlarmUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: AlarmCreateManyMemberInputEnvelope
    set?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
    disconnect?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
    delete?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
    connect?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
    update?: AlarmUpdateWithWhereUniqueWithoutMemberInput | AlarmUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: AlarmUpdateManyWithWhereWithoutMemberInput | AlarmUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: AlarmScalarWhereInput | AlarmScalarWhereInput[]
  }

  export type MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberFavoriteFoodKindCreateWithoutMemberInput, MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput> | MemberFavoriteFoodKindCreateWithoutMemberInput[] | MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberFavoriteFoodKindCreateOrConnectWithoutMemberInput | MemberFavoriteFoodKindCreateOrConnectWithoutMemberInput[]
    upsert?: MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutMemberInput | MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberFavoriteFoodKindCreateManyMemberInputEnvelope
    set?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    disconnect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    delete?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    connect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    update?: MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutMemberInput | MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberFavoriteFoodKindUpdateManyWithWhereWithoutMemberInput | MemberFavoriteFoodKindUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberFavoriteFoodKindScalarWhereInput | MemberFavoriteFoodKindScalarWhereInput[]
  }

  export type RestaurantUncheckedUpdateManyWithoutCeoNestedInput = {
    create?: XOR<RestaurantCreateWithoutCeoInput, RestaurantUncheckedCreateWithoutCeoInput> | RestaurantCreateWithoutCeoInput[] | RestaurantUncheckedCreateWithoutCeoInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutCeoInput | RestaurantCreateOrConnectWithoutCeoInput[]
    upsert?: RestaurantUpsertWithWhereUniqueWithoutCeoInput | RestaurantUpsertWithWhereUniqueWithoutCeoInput[]
    createMany?: RestaurantCreateManyCeoInputEnvelope
    set?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    disconnect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    delete?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    update?: RestaurantUpdateWithWhereUniqueWithoutCeoInput | RestaurantUpdateWithWhereUniqueWithoutCeoInput[]
    updateMany?: RestaurantUpdateManyWithWhereWithoutCeoInput | RestaurantUpdateManyWithWhereWithoutCeoInput[]
    deleteMany?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
  }

  export type MemberMissionUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberMissionCreateWithoutMemberInput, MemberMissionUncheckedCreateWithoutMemberInput> | MemberMissionCreateWithoutMemberInput[] | MemberMissionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberMissionCreateOrConnectWithoutMemberInput | MemberMissionCreateOrConnectWithoutMemberInput[]
    upsert?: MemberMissionUpsertWithWhereUniqueWithoutMemberInput | MemberMissionUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberMissionCreateManyMemberInputEnvelope
    set?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    disconnect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    delete?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    connect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    update?: MemberMissionUpdateWithWhereUniqueWithoutMemberInput | MemberMissionUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberMissionUpdateManyWithWhereWithoutMemberInput | MemberMissionUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberMissionScalarWhereInput | MemberMissionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ReviewCreateWithoutMemberInput, ReviewUncheckedCreateWithoutMemberInput> | ReviewCreateWithoutMemberInput[] | ReviewUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMemberInput | ReviewCreateOrConnectWithoutMemberInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutMemberInput | ReviewUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ReviewCreateManyMemberInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutMemberInput | ReviewUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutMemberInput | ReviewUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReplyUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ReplyCreateWithoutMemberInput, ReplyUncheckedCreateWithoutMemberInput> | ReplyCreateWithoutMemberInput[] | ReplyUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutMemberInput | ReplyCreateOrConnectWithoutMemberInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutMemberInput | ReplyUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ReplyCreateManyMemberInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutMemberInput | ReplyUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutMemberInput | ReplyUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<InquiryCreateWithoutMemberInput, InquiryUncheckedCreateWithoutMemberInput> | InquiryCreateWithoutMemberInput[] | InquiryUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutMemberInput | InquiryCreateOrConnectWithoutMemberInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutMemberInput | InquiryUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: InquiryCreateManyMemberInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutMemberInput | InquiryUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutMemberInput | InquiryUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type AlarmUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<AlarmCreateWithoutMemberInput, AlarmUncheckedCreateWithoutMemberInput> | AlarmCreateWithoutMemberInput[] | AlarmUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: AlarmCreateOrConnectWithoutMemberInput | AlarmCreateOrConnectWithoutMemberInput[]
    upsert?: AlarmUpsertWithWhereUniqueWithoutMemberInput | AlarmUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: AlarmCreateManyMemberInputEnvelope
    set?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
    disconnect?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
    delete?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
    connect?: AlarmWhereUniqueInput | AlarmWhereUniqueInput[]
    update?: AlarmUpdateWithWhereUniqueWithoutMemberInput | AlarmUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: AlarmUpdateManyWithWhereWithoutMemberInput | AlarmUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: AlarmScalarWhereInput | AlarmScalarWhereInput[]
  }

  export type MemberFavoriteFoodKindCreateNestedManyWithoutFoodKindInput = {
    create?: XOR<MemberFavoriteFoodKindCreateWithoutFoodKindInput, MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput> | MemberFavoriteFoodKindCreateWithoutFoodKindInput[] | MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput[]
    connectOrCreate?: MemberFavoriteFoodKindCreateOrConnectWithoutFoodKindInput | MemberFavoriteFoodKindCreateOrConnectWithoutFoodKindInput[]
    createMany?: MemberFavoriteFoodKindCreateManyFoodKindInputEnvelope
    connect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
  }

  export type FoodKindRestaurantCreateNestedManyWithoutFoodKindInput = {
    create?: XOR<FoodKindRestaurantCreateWithoutFoodKindInput, FoodKindRestaurantUncheckedCreateWithoutFoodKindInput> | FoodKindRestaurantCreateWithoutFoodKindInput[] | FoodKindRestaurantUncheckedCreateWithoutFoodKindInput[]
    connectOrCreate?: FoodKindRestaurantCreateOrConnectWithoutFoodKindInput | FoodKindRestaurantCreateOrConnectWithoutFoodKindInput[]
    createMany?: FoodKindRestaurantCreateManyFoodKindInputEnvelope
    connect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
  }

  export type MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutFoodKindInput = {
    create?: XOR<MemberFavoriteFoodKindCreateWithoutFoodKindInput, MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput> | MemberFavoriteFoodKindCreateWithoutFoodKindInput[] | MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput[]
    connectOrCreate?: MemberFavoriteFoodKindCreateOrConnectWithoutFoodKindInput | MemberFavoriteFoodKindCreateOrConnectWithoutFoodKindInput[]
    createMany?: MemberFavoriteFoodKindCreateManyFoodKindInputEnvelope
    connect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
  }

  export type FoodKindRestaurantUncheckedCreateNestedManyWithoutFoodKindInput = {
    create?: XOR<FoodKindRestaurantCreateWithoutFoodKindInput, FoodKindRestaurantUncheckedCreateWithoutFoodKindInput> | FoodKindRestaurantCreateWithoutFoodKindInput[] | FoodKindRestaurantUncheckedCreateWithoutFoodKindInput[]
    connectOrCreate?: FoodKindRestaurantCreateOrConnectWithoutFoodKindInput | FoodKindRestaurantCreateOrConnectWithoutFoodKindInput[]
    createMany?: FoodKindRestaurantCreateManyFoodKindInputEnvelope
    connect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
  }

  export type MemberFavoriteFoodKindUpdateManyWithoutFoodKindNestedInput = {
    create?: XOR<MemberFavoriteFoodKindCreateWithoutFoodKindInput, MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput> | MemberFavoriteFoodKindCreateWithoutFoodKindInput[] | MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput[]
    connectOrCreate?: MemberFavoriteFoodKindCreateOrConnectWithoutFoodKindInput | MemberFavoriteFoodKindCreateOrConnectWithoutFoodKindInput[]
    upsert?: MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutFoodKindInput | MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutFoodKindInput[]
    createMany?: MemberFavoriteFoodKindCreateManyFoodKindInputEnvelope
    set?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    disconnect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    delete?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    connect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    update?: MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutFoodKindInput | MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutFoodKindInput[]
    updateMany?: MemberFavoriteFoodKindUpdateManyWithWhereWithoutFoodKindInput | MemberFavoriteFoodKindUpdateManyWithWhereWithoutFoodKindInput[]
    deleteMany?: MemberFavoriteFoodKindScalarWhereInput | MemberFavoriteFoodKindScalarWhereInput[]
  }

  export type FoodKindRestaurantUpdateManyWithoutFoodKindNestedInput = {
    create?: XOR<FoodKindRestaurantCreateWithoutFoodKindInput, FoodKindRestaurantUncheckedCreateWithoutFoodKindInput> | FoodKindRestaurantCreateWithoutFoodKindInput[] | FoodKindRestaurantUncheckedCreateWithoutFoodKindInput[]
    connectOrCreate?: FoodKindRestaurantCreateOrConnectWithoutFoodKindInput | FoodKindRestaurantCreateOrConnectWithoutFoodKindInput[]
    upsert?: FoodKindRestaurantUpsertWithWhereUniqueWithoutFoodKindInput | FoodKindRestaurantUpsertWithWhereUniqueWithoutFoodKindInput[]
    createMany?: FoodKindRestaurantCreateManyFoodKindInputEnvelope
    set?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    disconnect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    delete?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    connect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    update?: FoodKindRestaurantUpdateWithWhereUniqueWithoutFoodKindInput | FoodKindRestaurantUpdateWithWhereUniqueWithoutFoodKindInput[]
    updateMany?: FoodKindRestaurantUpdateManyWithWhereWithoutFoodKindInput | FoodKindRestaurantUpdateManyWithWhereWithoutFoodKindInput[]
    deleteMany?: FoodKindRestaurantScalarWhereInput | FoodKindRestaurantScalarWhereInput[]
  }

  export type MemberFavoriteFoodKindUncheckedUpdateManyWithoutFoodKindNestedInput = {
    create?: XOR<MemberFavoriteFoodKindCreateWithoutFoodKindInput, MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput> | MemberFavoriteFoodKindCreateWithoutFoodKindInput[] | MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput[]
    connectOrCreate?: MemberFavoriteFoodKindCreateOrConnectWithoutFoodKindInput | MemberFavoriteFoodKindCreateOrConnectWithoutFoodKindInput[]
    upsert?: MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutFoodKindInput | MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutFoodKindInput[]
    createMany?: MemberFavoriteFoodKindCreateManyFoodKindInputEnvelope
    set?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    disconnect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    delete?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    connect?: MemberFavoriteFoodKindWhereUniqueInput | MemberFavoriteFoodKindWhereUniqueInput[]
    update?: MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutFoodKindInput | MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutFoodKindInput[]
    updateMany?: MemberFavoriteFoodKindUpdateManyWithWhereWithoutFoodKindInput | MemberFavoriteFoodKindUpdateManyWithWhereWithoutFoodKindInput[]
    deleteMany?: MemberFavoriteFoodKindScalarWhereInput | MemberFavoriteFoodKindScalarWhereInput[]
  }

  export type FoodKindRestaurantUncheckedUpdateManyWithoutFoodKindNestedInput = {
    create?: XOR<FoodKindRestaurantCreateWithoutFoodKindInput, FoodKindRestaurantUncheckedCreateWithoutFoodKindInput> | FoodKindRestaurantCreateWithoutFoodKindInput[] | FoodKindRestaurantUncheckedCreateWithoutFoodKindInput[]
    connectOrCreate?: FoodKindRestaurantCreateOrConnectWithoutFoodKindInput | FoodKindRestaurantCreateOrConnectWithoutFoodKindInput[]
    upsert?: FoodKindRestaurantUpsertWithWhereUniqueWithoutFoodKindInput | FoodKindRestaurantUpsertWithWhereUniqueWithoutFoodKindInput[]
    createMany?: FoodKindRestaurantCreateManyFoodKindInputEnvelope
    set?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    disconnect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    delete?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    connect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    update?: FoodKindRestaurantUpdateWithWhereUniqueWithoutFoodKindInput | FoodKindRestaurantUpdateWithWhereUniqueWithoutFoodKindInput[]
    updateMany?: FoodKindRestaurantUpdateManyWithWhereWithoutFoodKindInput | FoodKindRestaurantUpdateManyWithWhereWithoutFoodKindInput[]
    deleteMany?: FoodKindRestaurantScalarWhereInput | FoodKindRestaurantScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutMemberfavoriteFoodKindsInput = {
    create?: XOR<MemberCreateWithoutMemberfavoriteFoodKindsInput, MemberUncheckedCreateWithoutMemberfavoriteFoodKindsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberfavoriteFoodKindsInput
    connect?: MemberWhereUniqueInput
  }

  export type FoodKindCreateNestedOneWithoutMemberfavoriteFoodKindsInput = {
    create?: XOR<FoodKindCreateWithoutMemberfavoriteFoodKindsInput, FoodKindUncheckedCreateWithoutMemberfavoriteFoodKindsInput>
    connectOrCreate?: FoodKindCreateOrConnectWithoutMemberfavoriteFoodKindsInput
    connect?: FoodKindWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutMemberfavoriteFoodKindsNestedInput = {
    create?: XOR<MemberCreateWithoutMemberfavoriteFoodKindsInput, MemberUncheckedCreateWithoutMemberfavoriteFoodKindsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberfavoriteFoodKindsInput
    upsert?: MemberUpsertWithoutMemberfavoriteFoodKindsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMemberfavoriteFoodKindsInput, MemberUpdateWithoutMemberfavoriteFoodKindsInput>, MemberUncheckedUpdateWithoutMemberfavoriteFoodKindsInput>
  }

  export type FoodKindUpdateOneRequiredWithoutMemberfavoriteFoodKindsNestedInput = {
    create?: XOR<FoodKindCreateWithoutMemberfavoriteFoodKindsInput, FoodKindUncheckedCreateWithoutMemberfavoriteFoodKindsInput>
    connectOrCreate?: FoodKindCreateOrConnectWithoutMemberfavoriteFoodKindsInput
    upsert?: FoodKindUpsertWithoutMemberfavoriteFoodKindsInput
    connect?: FoodKindWhereUniqueInput
    update?: XOR<XOR<FoodKindUpdateToOneWithWhereWithoutMemberfavoriteFoodKindsInput, FoodKindUpdateWithoutMemberfavoriteFoodKindsInput>, FoodKindUncheckedUpdateWithoutMemberfavoriteFoodKindsInput>
  }

  export type RestaurantCreateNestedManyWithoutRegionInput = {
    create?: XOR<RestaurantCreateWithoutRegionInput, RestaurantUncheckedCreateWithoutRegionInput> | RestaurantCreateWithoutRegionInput[] | RestaurantUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutRegionInput | RestaurantCreateOrConnectWithoutRegionInput[]
    createMany?: RestaurantCreateManyRegionInputEnvelope
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
  }

  export type RestaurantUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<RestaurantCreateWithoutRegionInput, RestaurantUncheckedCreateWithoutRegionInput> | RestaurantCreateWithoutRegionInput[] | RestaurantUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutRegionInput | RestaurantCreateOrConnectWithoutRegionInput[]
    createMany?: RestaurantCreateManyRegionInputEnvelope
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
  }

  export type RestaurantUpdateManyWithoutRegionNestedInput = {
    create?: XOR<RestaurantCreateWithoutRegionInput, RestaurantUncheckedCreateWithoutRegionInput> | RestaurantCreateWithoutRegionInput[] | RestaurantUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutRegionInput | RestaurantCreateOrConnectWithoutRegionInput[]
    upsert?: RestaurantUpsertWithWhereUniqueWithoutRegionInput | RestaurantUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: RestaurantCreateManyRegionInputEnvelope
    set?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    disconnect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    delete?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    update?: RestaurantUpdateWithWhereUniqueWithoutRegionInput | RestaurantUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: RestaurantUpdateManyWithWhereWithoutRegionInput | RestaurantUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
  }

  export type RestaurantUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<RestaurantCreateWithoutRegionInput, RestaurantUncheckedCreateWithoutRegionInput> | RestaurantCreateWithoutRegionInput[] | RestaurantUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RestaurantCreateOrConnectWithoutRegionInput | RestaurantCreateOrConnectWithoutRegionInput[]
    upsert?: RestaurantUpsertWithWhereUniqueWithoutRegionInput | RestaurantUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: RestaurantCreateManyRegionInputEnvelope
    set?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    disconnect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    delete?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    connect?: RestaurantWhereUniqueInput | RestaurantWhereUniqueInput[]
    update?: RestaurantUpdateWithWhereUniqueWithoutRegionInput | RestaurantUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: RestaurantUpdateManyWithWhereWithoutRegionInput | RestaurantUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutRestaurantsInput = {
    create?: XOR<MemberCreateWithoutRestaurantsInput, MemberUncheckedCreateWithoutRestaurantsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutRestaurantsInput
    connect?: MemberWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutRestaurantInput = {
    create?: XOR<RegionCreateWithoutRestaurantInput, RegionUncheckedCreateWithoutRestaurantInput>
    connectOrCreate?: RegionCreateOrConnectWithoutRestaurantInput
    connect?: RegionWhereUniqueInput
  }

  export type MissionCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<MissionCreateWithoutRestaurantInput, MissionUncheckedCreateWithoutRestaurantInput> | MissionCreateWithoutRestaurantInput[] | MissionUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutRestaurantInput | MissionCreateOrConnectWithoutRestaurantInput[]
    createMany?: MissionCreateManyRestaurantInputEnvelope
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type FoodKindRestaurantCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<FoodKindRestaurantCreateWithoutRestaurantInput, FoodKindRestaurantUncheckedCreateWithoutRestaurantInput> | FoodKindRestaurantCreateWithoutRestaurantInput[] | FoodKindRestaurantUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: FoodKindRestaurantCreateOrConnectWithoutRestaurantInput | FoodKindRestaurantCreateOrConnectWithoutRestaurantInput[]
    createMany?: FoodKindRestaurantCreateManyRestaurantInputEnvelope
    connect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ReviewCreateWithoutRestaurantInput, ReviewUncheckedCreateWithoutRestaurantInput> | ReviewCreateWithoutRestaurantInput[] | ReviewUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRestaurantInput | ReviewCreateOrConnectWithoutRestaurantInput[]
    createMany?: ReviewCreateManyRestaurantInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ImageCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ImageCreateWithoutRestaurantInput, ImageUncheckedCreateWithoutRestaurantInput> | ImageCreateWithoutRestaurantInput[] | ImageUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutRestaurantInput | ImageCreateOrConnectWithoutRestaurantInput[]
    createMany?: ImageCreateManyRestaurantInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type MissionUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<MissionCreateWithoutRestaurantInput, MissionUncheckedCreateWithoutRestaurantInput> | MissionCreateWithoutRestaurantInput[] | MissionUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutRestaurantInput | MissionCreateOrConnectWithoutRestaurantInput[]
    createMany?: MissionCreateManyRestaurantInputEnvelope
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type FoodKindRestaurantUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<FoodKindRestaurantCreateWithoutRestaurantInput, FoodKindRestaurantUncheckedCreateWithoutRestaurantInput> | FoodKindRestaurantCreateWithoutRestaurantInput[] | FoodKindRestaurantUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: FoodKindRestaurantCreateOrConnectWithoutRestaurantInput | FoodKindRestaurantCreateOrConnectWithoutRestaurantInput[]
    createMany?: FoodKindRestaurantCreateManyRestaurantInputEnvelope
    connect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ReviewCreateWithoutRestaurantInput, ReviewUncheckedCreateWithoutRestaurantInput> | ReviewCreateWithoutRestaurantInput[] | ReviewUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRestaurantInput | ReviewCreateOrConnectWithoutRestaurantInput[]
    createMany?: ReviewCreateManyRestaurantInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ImageCreateWithoutRestaurantInput, ImageUncheckedCreateWithoutRestaurantInput> | ImageCreateWithoutRestaurantInput[] | ImageUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutRestaurantInput | ImageCreateOrConnectWithoutRestaurantInput[]
    createMany?: ImageCreateManyRestaurantInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MemberUpdateOneRequiredWithoutRestaurantsNestedInput = {
    create?: XOR<MemberCreateWithoutRestaurantsInput, MemberUncheckedCreateWithoutRestaurantsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutRestaurantsInput
    upsert?: MemberUpsertWithoutRestaurantsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutRestaurantsInput, MemberUpdateWithoutRestaurantsInput>, MemberUncheckedUpdateWithoutRestaurantsInput>
  }

  export type RegionUpdateOneRequiredWithoutRestaurantNestedInput = {
    create?: XOR<RegionCreateWithoutRestaurantInput, RegionUncheckedCreateWithoutRestaurantInput>
    connectOrCreate?: RegionCreateOrConnectWithoutRestaurantInput
    upsert?: RegionUpsertWithoutRestaurantInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutRestaurantInput, RegionUpdateWithoutRestaurantInput>, RegionUncheckedUpdateWithoutRestaurantInput>
  }

  export type MissionUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<MissionCreateWithoutRestaurantInput, MissionUncheckedCreateWithoutRestaurantInput> | MissionCreateWithoutRestaurantInput[] | MissionUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutRestaurantInput | MissionCreateOrConnectWithoutRestaurantInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutRestaurantInput | MissionUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: MissionCreateManyRestaurantInputEnvelope
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutRestaurantInput | MissionUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutRestaurantInput | MissionUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type FoodKindRestaurantUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<FoodKindRestaurantCreateWithoutRestaurantInput, FoodKindRestaurantUncheckedCreateWithoutRestaurantInput> | FoodKindRestaurantCreateWithoutRestaurantInput[] | FoodKindRestaurantUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: FoodKindRestaurantCreateOrConnectWithoutRestaurantInput | FoodKindRestaurantCreateOrConnectWithoutRestaurantInput[]
    upsert?: FoodKindRestaurantUpsertWithWhereUniqueWithoutRestaurantInput | FoodKindRestaurantUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: FoodKindRestaurantCreateManyRestaurantInputEnvelope
    set?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    disconnect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    delete?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    connect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    update?: FoodKindRestaurantUpdateWithWhereUniqueWithoutRestaurantInput | FoodKindRestaurantUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: FoodKindRestaurantUpdateManyWithWhereWithoutRestaurantInput | FoodKindRestaurantUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: FoodKindRestaurantScalarWhereInput | FoodKindRestaurantScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ReviewCreateWithoutRestaurantInput, ReviewUncheckedCreateWithoutRestaurantInput> | ReviewCreateWithoutRestaurantInput[] | ReviewUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRestaurantInput | ReviewCreateOrConnectWithoutRestaurantInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutRestaurantInput | ReviewUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ReviewCreateManyRestaurantInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutRestaurantInput | ReviewUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutRestaurantInput | ReviewUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ImageUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ImageCreateWithoutRestaurantInput, ImageUncheckedCreateWithoutRestaurantInput> | ImageCreateWithoutRestaurantInput[] | ImageUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutRestaurantInput | ImageCreateOrConnectWithoutRestaurantInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutRestaurantInput | ImageUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ImageCreateManyRestaurantInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutRestaurantInput | ImageUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutRestaurantInput | ImageUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type MissionUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<MissionCreateWithoutRestaurantInput, MissionUncheckedCreateWithoutRestaurantInput> | MissionCreateWithoutRestaurantInput[] | MissionUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutRestaurantInput | MissionCreateOrConnectWithoutRestaurantInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutRestaurantInput | MissionUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: MissionCreateManyRestaurantInputEnvelope
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutRestaurantInput | MissionUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutRestaurantInput | MissionUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type FoodKindRestaurantUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<FoodKindRestaurantCreateWithoutRestaurantInput, FoodKindRestaurantUncheckedCreateWithoutRestaurantInput> | FoodKindRestaurantCreateWithoutRestaurantInput[] | FoodKindRestaurantUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: FoodKindRestaurantCreateOrConnectWithoutRestaurantInput | FoodKindRestaurantCreateOrConnectWithoutRestaurantInput[]
    upsert?: FoodKindRestaurantUpsertWithWhereUniqueWithoutRestaurantInput | FoodKindRestaurantUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: FoodKindRestaurantCreateManyRestaurantInputEnvelope
    set?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    disconnect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    delete?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    connect?: FoodKindRestaurantWhereUniqueInput | FoodKindRestaurantWhereUniqueInput[]
    update?: FoodKindRestaurantUpdateWithWhereUniqueWithoutRestaurantInput | FoodKindRestaurantUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: FoodKindRestaurantUpdateManyWithWhereWithoutRestaurantInput | FoodKindRestaurantUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: FoodKindRestaurantScalarWhereInput | FoodKindRestaurantScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ReviewCreateWithoutRestaurantInput, ReviewUncheckedCreateWithoutRestaurantInput> | ReviewCreateWithoutRestaurantInput[] | ReviewUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRestaurantInput | ReviewCreateOrConnectWithoutRestaurantInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutRestaurantInput | ReviewUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ReviewCreateManyRestaurantInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutRestaurantInput | ReviewUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutRestaurantInput | ReviewUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ImageCreateWithoutRestaurantInput, ImageUncheckedCreateWithoutRestaurantInput> | ImageCreateWithoutRestaurantInput[] | ImageUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutRestaurantInput | ImageCreateOrConnectWithoutRestaurantInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutRestaurantInput | ImageUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ImageCreateManyRestaurantInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutRestaurantInput | ImageUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutRestaurantInput | ImageUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type RestaurantCreateNestedOneWithoutMissionsInput = {
    create?: XOR<RestaurantCreateWithoutMissionsInput, RestaurantUncheckedCreateWithoutMissionsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutMissionsInput
    connect?: RestaurantWhereUniqueInput
  }

  export type MemberMissionCreateNestedManyWithoutMissionInput = {
    create?: XOR<MemberMissionCreateWithoutMissionInput, MemberMissionUncheckedCreateWithoutMissionInput> | MemberMissionCreateWithoutMissionInput[] | MemberMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: MemberMissionCreateOrConnectWithoutMissionInput | MemberMissionCreateOrConnectWithoutMissionInput[]
    createMany?: MemberMissionCreateManyMissionInputEnvelope
    connect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
  }

  export type MemberMissionUncheckedCreateNestedManyWithoutMissionInput = {
    create?: XOR<MemberMissionCreateWithoutMissionInput, MemberMissionUncheckedCreateWithoutMissionInput> | MemberMissionCreateWithoutMissionInput[] | MemberMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: MemberMissionCreateOrConnectWithoutMissionInput | MemberMissionCreateOrConnectWithoutMissionInput[]
    createMany?: MemberMissionCreateManyMissionInputEnvelope
    connect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
  }

  export type RestaurantUpdateOneRequiredWithoutMissionsNestedInput = {
    create?: XOR<RestaurantCreateWithoutMissionsInput, RestaurantUncheckedCreateWithoutMissionsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutMissionsInput
    upsert?: RestaurantUpsertWithoutMissionsInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutMissionsInput, RestaurantUpdateWithoutMissionsInput>, RestaurantUncheckedUpdateWithoutMissionsInput>
  }

  export type MemberMissionUpdateManyWithoutMissionNestedInput = {
    create?: XOR<MemberMissionCreateWithoutMissionInput, MemberMissionUncheckedCreateWithoutMissionInput> | MemberMissionCreateWithoutMissionInput[] | MemberMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: MemberMissionCreateOrConnectWithoutMissionInput | MemberMissionCreateOrConnectWithoutMissionInput[]
    upsert?: MemberMissionUpsertWithWhereUniqueWithoutMissionInput | MemberMissionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: MemberMissionCreateManyMissionInputEnvelope
    set?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    disconnect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    delete?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    connect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    update?: MemberMissionUpdateWithWhereUniqueWithoutMissionInput | MemberMissionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: MemberMissionUpdateManyWithWhereWithoutMissionInput | MemberMissionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: MemberMissionScalarWhereInput | MemberMissionScalarWhereInput[]
  }

  export type MemberMissionUncheckedUpdateManyWithoutMissionNestedInput = {
    create?: XOR<MemberMissionCreateWithoutMissionInput, MemberMissionUncheckedCreateWithoutMissionInput> | MemberMissionCreateWithoutMissionInput[] | MemberMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: MemberMissionCreateOrConnectWithoutMissionInput | MemberMissionCreateOrConnectWithoutMissionInput[]
    upsert?: MemberMissionUpsertWithWhereUniqueWithoutMissionInput | MemberMissionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: MemberMissionCreateManyMissionInputEnvelope
    set?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    disconnect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    delete?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    connect?: MemberMissionWhereUniqueInput | MemberMissionWhereUniqueInput[]
    update?: MemberMissionUpdateWithWhereUniqueWithoutMissionInput | MemberMissionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: MemberMissionUpdateManyWithWhereWithoutMissionInput | MemberMissionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: MemberMissionScalarWhereInput | MemberMissionScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutMemberMissionsInput = {
    create?: XOR<MemberCreateWithoutMemberMissionsInput, MemberUncheckedCreateWithoutMemberMissionsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberMissionsInput
    connect?: MemberWhereUniqueInput
  }

  export type MissionCreateNestedOneWithoutMemberMissionInput = {
    create?: XOR<MissionCreateWithoutMemberMissionInput, MissionUncheckedCreateWithoutMemberMissionInput>
    connectOrCreate?: MissionCreateOrConnectWithoutMemberMissionInput
    connect?: MissionWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutMemberMissionsNestedInput = {
    create?: XOR<MemberCreateWithoutMemberMissionsInput, MemberUncheckedCreateWithoutMemberMissionsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberMissionsInput
    upsert?: MemberUpsertWithoutMemberMissionsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMemberMissionsInput, MemberUpdateWithoutMemberMissionsInput>, MemberUncheckedUpdateWithoutMemberMissionsInput>
  }

  export type MissionUpdateOneRequiredWithoutMemberMissionNestedInput = {
    create?: XOR<MissionCreateWithoutMemberMissionInput, MissionUncheckedCreateWithoutMemberMissionInput>
    connectOrCreate?: MissionCreateOrConnectWithoutMemberMissionInput
    upsert?: MissionUpsertWithoutMemberMissionInput
    connect?: MissionWhereUniqueInput
    update?: XOR<XOR<MissionUpdateToOneWithWhereWithoutMemberMissionInput, MissionUpdateWithoutMemberMissionInput>, MissionUncheckedUpdateWithoutMemberMissionInput>
  }

  export type FoodKindCreateNestedOneWithoutFoodKindRestaurantsInput = {
    create?: XOR<FoodKindCreateWithoutFoodKindRestaurantsInput, FoodKindUncheckedCreateWithoutFoodKindRestaurantsInput>
    connectOrCreate?: FoodKindCreateOrConnectWithoutFoodKindRestaurantsInput
    connect?: FoodKindWhereUniqueInput
  }

  export type RestaurantCreateNestedOneWithoutFoodKindRestaurantsInput = {
    create?: XOR<RestaurantCreateWithoutFoodKindRestaurantsInput, RestaurantUncheckedCreateWithoutFoodKindRestaurantsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutFoodKindRestaurantsInput
    connect?: RestaurantWhereUniqueInput
  }

  export type FoodKindUpdateOneRequiredWithoutFoodKindRestaurantsNestedInput = {
    create?: XOR<FoodKindCreateWithoutFoodKindRestaurantsInput, FoodKindUncheckedCreateWithoutFoodKindRestaurantsInput>
    connectOrCreate?: FoodKindCreateOrConnectWithoutFoodKindRestaurantsInput
    upsert?: FoodKindUpsertWithoutFoodKindRestaurantsInput
    connect?: FoodKindWhereUniqueInput
    update?: XOR<XOR<FoodKindUpdateToOneWithWhereWithoutFoodKindRestaurantsInput, FoodKindUpdateWithoutFoodKindRestaurantsInput>, FoodKindUncheckedUpdateWithoutFoodKindRestaurantsInput>
  }

  export type RestaurantUpdateOneRequiredWithoutFoodKindRestaurantsNestedInput = {
    create?: XOR<RestaurantCreateWithoutFoodKindRestaurantsInput, RestaurantUncheckedCreateWithoutFoodKindRestaurantsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutFoodKindRestaurantsInput
    upsert?: RestaurantUpsertWithoutFoodKindRestaurantsInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutFoodKindRestaurantsInput, RestaurantUpdateWithoutFoodKindRestaurantsInput>, RestaurantUncheckedUpdateWithoutFoodKindRestaurantsInput>
  }

  export type MemberCreateNestedOneWithoutReviewsInput = {
    create?: XOR<MemberCreateWithoutReviewsInput, MemberUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReviewsInput
    connect?: MemberWhereUniqueInput
  }

  export type RestaurantCreateNestedOneWithoutReviewsInput = {
    create?: XOR<RestaurantCreateWithoutReviewsInput, RestaurantUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutReviewsInput
    connect?: RestaurantWhereUniqueInput
  }

  export type ReplyCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReplyCreateWithoutReviewInput, ReplyUncheckedCreateWithoutReviewInput> | ReplyCreateWithoutReviewInput[] | ReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutReviewInput | ReplyCreateOrConnectWithoutReviewInput[]
    createMany?: ReplyCreateManyReviewInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type ImageCreateNestedManyWithoutReviewInput = {
    create?: XOR<ImageCreateWithoutReviewInput, ImageUncheckedCreateWithoutReviewInput> | ImageCreateWithoutReviewInput[] | ImageUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutReviewInput | ImageCreateOrConnectWithoutReviewInput[]
    createMany?: ImageCreateManyReviewInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ReplyUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReplyCreateWithoutReviewInput, ReplyUncheckedCreateWithoutReviewInput> | ReplyCreateWithoutReviewInput[] | ReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutReviewInput | ReplyCreateOrConnectWithoutReviewInput[]
    createMany?: ReplyCreateManyReviewInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ImageCreateWithoutReviewInput, ImageUncheckedCreateWithoutReviewInput> | ImageCreateWithoutReviewInput[] | ImageUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutReviewInput | ImageCreateOrConnectWithoutReviewInput[]
    createMany?: ImageCreateManyReviewInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type MemberUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<MemberCreateWithoutReviewsInput, MemberUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReviewsInput
    upsert?: MemberUpsertWithoutReviewsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutReviewsInput, MemberUpdateWithoutReviewsInput>, MemberUncheckedUpdateWithoutReviewsInput>
  }

  export type RestaurantUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<RestaurantCreateWithoutReviewsInput, RestaurantUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutReviewsInput
    upsert?: RestaurantUpsertWithoutReviewsInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutReviewsInput, RestaurantUpdateWithoutReviewsInput>, RestaurantUncheckedUpdateWithoutReviewsInput>
  }

  export type ReplyUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReplyCreateWithoutReviewInput, ReplyUncheckedCreateWithoutReviewInput> | ReplyCreateWithoutReviewInput[] | ReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutReviewInput | ReplyCreateOrConnectWithoutReviewInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutReviewInput | ReplyUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReplyCreateManyReviewInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutReviewInput | ReplyUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutReviewInput | ReplyUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type ImageUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ImageCreateWithoutReviewInput, ImageUncheckedCreateWithoutReviewInput> | ImageCreateWithoutReviewInput[] | ImageUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutReviewInput | ImageCreateOrConnectWithoutReviewInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutReviewInput | ImageUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ImageCreateManyReviewInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutReviewInput | ImageUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutReviewInput | ImageUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ReplyUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReplyCreateWithoutReviewInput, ReplyUncheckedCreateWithoutReviewInput> | ReplyCreateWithoutReviewInput[] | ReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutReviewInput | ReplyCreateOrConnectWithoutReviewInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutReviewInput | ReplyUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReplyCreateManyReviewInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutReviewInput | ReplyUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutReviewInput | ReplyUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ImageCreateWithoutReviewInput, ImageUncheckedCreateWithoutReviewInput> | ImageCreateWithoutReviewInput[] | ImageUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutReviewInput | ImageCreateOrConnectWithoutReviewInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutReviewInput | ImageUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ImageCreateManyReviewInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutReviewInput | ImageUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutReviewInput | ImageUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutReplyInput = {
    create?: XOR<MemberCreateWithoutReplyInput, MemberUncheckedCreateWithoutReplyInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReplyInput
    connect?: MemberWhereUniqueInput
  }

  export type ReviewCreateNestedOneWithoutReplysInput = {
    create?: XOR<ReviewCreateWithoutReplysInput, ReviewUncheckedCreateWithoutReplysInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutReplysInput
    connect?: ReviewWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutReplyNestedInput = {
    create?: XOR<MemberCreateWithoutReplyInput, MemberUncheckedCreateWithoutReplyInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReplyInput
    upsert?: MemberUpsertWithoutReplyInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutReplyInput, MemberUpdateWithoutReplyInput>, MemberUncheckedUpdateWithoutReplyInput>
  }

  export type ReviewUpdateOneRequiredWithoutReplysNestedInput = {
    create?: XOR<ReviewCreateWithoutReplysInput, ReviewUncheckedCreateWithoutReplysInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutReplysInput
    upsert?: ReviewUpsertWithoutReplysInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutReplysInput, ReviewUpdateWithoutReplysInput>, ReviewUncheckedUpdateWithoutReplysInput>
  }

  export type MemberCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<MemberCreateWithoutInquiriesInput, MemberUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutInquiriesInput
    connect?: MemberWhereUniqueInput
  }

  export type ImageCreateNestedManyWithoutInquiryInput = {
    create?: XOR<ImageCreateWithoutInquiryInput, ImageUncheckedCreateWithoutInquiryInput> | ImageCreateWithoutInquiryInput[] | ImageUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutInquiryInput | ImageCreateOrConnectWithoutInquiryInput[]
    createMany?: ImageCreateManyInquiryInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutInquiryInput = {
    create?: XOR<ImageCreateWithoutInquiryInput, ImageUncheckedCreateWithoutInquiryInput> | ImageCreateWithoutInquiryInput[] | ImageUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutInquiryInput | ImageCreateOrConnectWithoutInquiryInput[]
    createMany?: ImageCreateManyInquiryInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type MemberUpdateOneRequiredWithoutInquiriesNestedInput = {
    create?: XOR<MemberCreateWithoutInquiriesInput, MemberUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutInquiriesInput
    upsert?: MemberUpsertWithoutInquiriesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutInquiriesInput, MemberUpdateWithoutInquiriesInput>, MemberUncheckedUpdateWithoutInquiriesInput>
  }

  export type ImageUpdateManyWithoutInquiryNestedInput = {
    create?: XOR<ImageCreateWithoutInquiryInput, ImageUncheckedCreateWithoutInquiryInput> | ImageCreateWithoutInquiryInput[] | ImageUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutInquiryInput | ImageCreateOrConnectWithoutInquiryInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutInquiryInput | ImageUpsertWithWhereUniqueWithoutInquiryInput[]
    createMany?: ImageCreateManyInquiryInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutInquiryInput | ImageUpdateWithWhereUniqueWithoutInquiryInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutInquiryInput | ImageUpdateManyWithWhereWithoutInquiryInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutInquiryNestedInput = {
    create?: XOR<ImageCreateWithoutInquiryInput, ImageUncheckedCreateWithoutInquiryInput> | ImageCreateWithoutInquiryInput[] | ImageUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutInquiryInput | ImageCreateOrConnectWithoutInquiryInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutInquiryInput | ImageUpsertWithWhereUniqueWithoutInquiryInput[]
    createMany?: ImageCreateManyInquiryInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutInquiryInput | ImageUpdateWithWhereUniqueWithoutInquiryInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutInquiryInput | ImageUpdateManyWithWhereWithoutInquiryInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type RestaurantCreateNestedOneWithoutImagesInput = {
    create?: XOR<RestaurantCreateWithoutImagesInput, RestaurantUncheckedCreateWithoutImagesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutImagesInput
    connect?: RestaurantWhereUniqueInput
  }

  export type ReviewCreateNestedOneWithoutImagesInput = {
    create?: XOR<ReviewCreateWithoutImagesInput, ReviewUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutImagesInput
    connect?: ReviewWhereUniqueInput
  }

  export type InquiryCreateNestedOneWithoutImagesInput = {
    create?: XOR<InquiryCreateWithoutImagesInput, InquiryUncheckedCreateWithoutImagesInput>
    connectOrCreate?: InquiryCreateOrConnectWithoutImagesInput
    connect?: InquiryWhereUniqueInput
  }

  export type RestaurantUpdateOneWithoutImagesNestedInput = {
    create?: XOR<RestaurantCreateWithoutImagesInput, RestaurantUncheckedCreateWithoutImagesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutImagesInput
    upsert?: RestaurantUpsertWithoutImagesInput
    disconnect?: RestaurantWhereInput | boolean
    delete?: RestaurantWhereInput | boolean
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutImagesInput, RestaurantUpdateWithoutImagesInput>, RestaurantUncheckedUpdateWithoutImagesInput>
  }

  export type ReviewUpdateOneWithoutImagesNestedInput = {
    create?: XOR<ReviewCreateWithoutImagesInput, ReviewUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutImagesInput
    upsert?: ReviewUpsertWithoutImagesInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutImagesInput, ReviewUpdateWithoutImagesInput>, ReviewUncheckedUpdateWithoutImagesInput>
  }

  export type InquiryUpdateOneWithoutImagesNestedInput = {
    create?: XOR<InquiryCreateWithoutImagesInput, InquiryUncheckedCreateWithoutImagesInput>
    connectOrCreate?: InquiryCreateOrConnectWithoutImagesInput
    upsert?: InquiryUpsertWithoutImagesInput
    disconnect?: InquiryWhereInput | boolean
    delete?: InquiryWhereInput | boolean
    connect?: InquiryWhereUniqueInput
    update?: XOR<XOR<InquiryUpdateToOneWithWhereWithoutImagesInput, InquiryUpdateWithoutImagesInput>, InquiryUncheckedUpdateWithoutImagesInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type MemberCreateNestedOneWithoutAlarmsInput = {
    create?: XOR<MemberCreateWithoutAlarmsInput, MemberUncheckedCreateWithoutAlarmsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAlarmsInput
    connect?: MemberWhereUniqueInput
  }

  export type AlarmNewMissionCreateNestedManyWithoutAlarmInput = {
    create?: XOR<AlarmNewMissionCreateWithoutAlarmInput, AlarmNewMissionUncheckedCreateWithoutAlarmInput> | AlarmNewMissionCreateWithoutAlarmInput[] | AlarmNewMissionUncheckedCreateWithoutAlarmInput[]
    connectOrCreate?: AlarmNewMissionCreateOrConnectWithoutAlarmInput | AlarmNewMissionCreateOrConnectWithoutAlarmInput[]
    createMany?: AlarmNewMissionCreateManyAlarmInputEnvelope
    connect?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
  }

  export type AlarmReviewRequestCreateNestedManyWithoutAlarmInput = {
    create?: XOR<AlarmReviewRequestCreateWithoutAlarmInput, AlarmReviewRequestUncheckedCreateWithoutAlarmInput> | AlarmReviewRequestCreateWithoutAlarmInput[] | AlarmReviewRequestUncheckedCreateWithoutAlarmInput[]
    connectOrCreate?: AlarmReviewRequestCreateOrConnectWithoutAlarmInput | AlarmReviewRequestCreateOrConnectWithoutAlarmInput[]
    createMany?: AlarmReviewRequestCreateManyAlarmInputEnvelope
    connect?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
  }

  export type AlarmNewMissionUncheckedCreateNestedManyWithoutAlarmInput = {
    create?: XOR<AlarmNewMissionCreateWithoutAlarmInput, AlarmNewMissionUncheckedCreateWithoutAlarmInput> | AlarmNewMissionCreateWithoutAlarmInput[] | AlarmNewMissionUncheckedCreateWithoutAlarmInput[]
    connectOrCreate?: AlarmNewMissionCreateOrConnectWithoutAlarmInput | AlarmNewMissionCreateOrConnectWithoutAlarmInput[]
    createMany?: AlarmNewMissionCreateManyAlarmInputEnvelope
    connect?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
  }

  export type AlarmReviewRequestUncheckedCreateNestedManyWithoutAlarmInput = {
    create?: XOR<AlarmReviewRequestCreateWithoutAlarmInput, AlarmReviewRequestUncheckedCreateWithoutAlarmInput> | AlarmReviewRequestCreateWithoutAlarmInput[] | AlarmReviewRequestUncheckedCreateWithoutAlarmInput[]
    connectOrCreate?: AlarmReviewRequestCreateOrConnectWithoutAlarmInput | AlarmReviewRequestCreateOrConnectWithoutAlarmInput[]
    createMany?: AlarmReviewRequestCreateManyAlarmInputEnvelope
    connect?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
  }

  export type MemberUpdateOneRequiredWithoutAlarmsNestedInput = {
    create?: XOR<MemberCreateWithoutAlarmsInput, MemberUncheckedCreateWithoutAlarmsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutAlarmsInput
    upsert?: MemberUpsertWithoutAlarmsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutAlarmsInput, MemberUpdateWithoutAlarmsInput>, MemberUncheckedUpdateWithoutAlarmsInput>
  }

  export type AlarmNewMissionUpdateManyWithoutAlarmNestedInput = {
    create?: XOR<AlarmNewMissionCreateWithoutAlarmInput, AlarmNewMissionUncheckedCreateWithoutAlarmInput> | AlarmNewMissionCreateWithoutAlarmInput[] | AlarmNewMissionUncheckedCreateWithoutAlarmInput[]
    connectOrCreate?: AlarmNewMissionCreateOrConnectWithoutAlarmInput | AlarmNewMissionCreateOrConnectWithoutAlarmInput[]
    upsert?: AlarmNewMissionUpsertWithWhereUniqueWithoutAlarmInput | AlarmNewMissionUpsertWithWhereUniqueWithoutAlarmInput[]
    createMany?: AlarmNewMissionCreateManyAlarmInputEnvelope
    set?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
    disconnect?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
    delete?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
    connect?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
    update?: AlarmNewMissionUpdateWithWhereUniqueWithoutAlarmInput | AlarmNewMissionUpdateWithWhereUniqueWithoutAlarmInput[]
    updateMany?: AlarmNewMissionUpdateManyWithWhereWithoutAlarmInput | AlarmNewMissionUpdateManyWithWhereWithoutAlarmInput[]
    deleteMany?: AlarmNewMissionScalarWhereInput | AlarmNewMissionScalarWhereInput[]
  }

  export type AlarmReviewRequestUpdateManyWithoutAlarmNestedInput = {
    create?: XOR<AlarmReviewRequestCreateWithoutAlarmInput, AlarmReviewRequestUncheckedCreateWithoutAlarmInput> | AlarmReviewRequestCreateWithoutAlarmInput[] | AlarmReviewRequestUncheckedCreateWithoutAlarmInput[]
    connectOrCreate?: AlarmReviewRequestCreateOrConnectWithoutAlarmInput | AlarmReviewRequestCreateOrConnectWithoutAlarmInput[]
    upsert?: AlarmReviewRequestUpsertWithWhereUniqueWithoutAlarmInput | AlarmReviewRequestUpsertWithWhereUniqueWithoutAlarmInput[]
    createMany?: AlarmReviewRequestCreateManyAlarmInputEnvelope
    set?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
    disconnect?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
    delete?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
    connect?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
    update?: AlarmReviewRequestUpdateWithWhereUniqueWithoutAlarmInput | AlarmReviewRequestUpdateWithWhereUniqueWithoutAlarmInput[]
    updateMany?: AlarmReviewRequestUpdateManyWithWhereWithoutAlarmInput | AlarmReviewRequestUpdateManyWithWhereWithoutAlarmInput[]
    deleteMany?: AlarmReviewRequestScalarWhereInput | AlarmReviewRequestScalarWhereInput[]
  }

  export type AlarmNewMissionUncheckedUpdateManyWithoutAlarmNestedInput = {
    create?: XOR<AlarmNewMissionCreateWithoutAlarmInput, AlarmNewMissionUncheckedCreateWithoutAlarmInput> | AlarmNewMissionCreateWithoutAlarmInput[] | AlarmNewMissionUncheckedCreateWithoutAlarmInput[]
    connectOrCreate?: AlarmNewMissionCreateOrConnectWithoutAlarmInput | AlarmNewMissionCreateOrConnectWithoutAlarmInput[]
    upsert?: AlarmNewMissionUpsertWithWhereUniqueWithoutAlarmInput | AlarmNewMissionUpsertWithWhereUniqueWithoutAlarmInput[]
    createMany?: AlarmNewMissionCreateManyAlarmInputEnvelope
    set?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
    disconnect?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
    delete?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
    connect?: AlarmNewMissionWhereUniqueInput | AlarmNewMissionWhereUniqueInput[]
    update?: AlarmNewMissionUpdateWithWhereUniqueWithoutAlarmInput | AlarmNewMissionUpdateWithWhereUniqueWithoutAlarmInput[]
    updateMany?: AlarmNewMissionUpdateManyWithWhereWithoutAlarmInput | AlarmNewMissionUpdateManyWithWhereWithoutAlarmInput[]
    deleteMany?: AlarmNewMissionScalarWhereInput | AlarmNewMissionScalarWhereInput[]
  }

  export type AlarmReviewRequestUncheckedUpdateManyWithoutAlarmNestedInput = {
    create?: XOR<AlarmReviewRequestCreateWithoutAlarmInput, AlarmReviewRequestUncheckedCreateWithoutAlarmInput> | AlarmReviewRequestCreateWithoutAlarmInput[] | AlarmReviewRequestUncheckedCreateWithoutAlarmInput[]
    connectOrCreate?: AlarmReviewRequestCreateOrConnectWithoutAlarmInput | AlarmReviewRequestCreateOrConnectWithoutAlarmInput[]
    upsert?: AlarmReviewRequestUpsertWithWhereUniqueWithoutAlarmInput | AlarmReviewRequestUpsertWithWhereUniqueWithoutAlarmInput[]
    createMany?: AlarmReviewRequestCreateManyAlarmInputEnvelope
    set?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
    disconnect?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
    delete?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
    connect?: AlarmReviewRequestWhereUniqueInput | AlarmReviewRequestWhereUniqueInput[]
    update?: AlarmReviewRequestUpdateWithWhereUniqueWithoutAlarmInput | AlarmReviewRequestUpdateWithWhereUniqueWithoutAlarmInput[]
    updateMany?: AlarmReviewRequestUpdateManyWithWhereWithoutAlarmInput | AlarmReviewRequestUpdateManyWithWhereWithoutAlarmInput[]
    deleteMany?: AlarmReviewRequestScalarWhereInput | AlarmReviewRequestScalarWhereInput[]
  }

  export type AlarmCreateNestedOneWithoutAlarmsNewMissionsInput = {
    create?: XOR<AlarmCreateWithoutAlarmsNewMissionsInput, AlarmUncheckedCreateWithoutAlarmsNewMissionsInput>
    connectOrCreate?: AlarmCreateOrConnectWithoutAlarmsNewMissionsInput
    connect?: AlarmWhereUniqueInput
  }

  export type AlarmUpdateOneRequiredWithoutAlarmsNewMissionsNestedInput = {
    create?: XOR<AlarmCreateWithoutAlarmsNewMissionsInput, AlarmUncheckedCreateWithoutAlarmsNewMissionsInput>
    connectOrCreate?: AlarmCreateOrConnectWithoutAlarmsNewMissionsInput
    upsert?: AlarmUpsertWithoutAlarmsNewMissionsInput
    connect?: AlarmWhereUniqueInput
    update?: XOR<XOR<AlarmUpdateToOneWithWhereWithoutAlarmsNewMissionsInput, AlarmUpdateWithoutAlarmsNewMissionsInput>, AlarmUncheckedUpdateWithoutAlarmsNewMissionsInput>
  }

  export type AlarmCreateNestedOneWithoutAlarmReviewRequestInput = {
    create?: XOR<AlarmCreateWithoutAlarmReviewRequestInput, AlarmUncheckedCreateWithoutAlarmReviewRequestInput>
    connectOrCreate?: AlarmCreateOrConnectWithoutAlarmReviewRequestInput
    connect?: AlarmWhereUniqueInput
  }

  export type AlarmUpdateOneRequiredWithoutAlarmReviewRequestNestedInput = {
    create?: XOR<AlarmCreateWithoutAlarmReviewRequestInput, AlarmUncheckedCreateWithoutAlarmReviewRequestInput>
    connectOrCreate?: AlarmCreateOrConnectWithoutAlarmReviewRequestInput
    upsert?: AlarmUpsertWithoutAlarmReviewRequestInput
    connect?: AlarmWhereUniqueInput
    update?: XOR<XOR<AlarmUpdateToOneWithWhereWithoutAlarmReviewRequestInput, AlarmUpdateWithoutAlarmReviewRequestInput>, AlarmUncheckedUpdateWithoutAlarmReviewRequestInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MemberFavoriteFoodKindCreateWithoutMemberInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    foodKind: FoodKindCreateNestedOneWithoutMemberfavoriteFoodKindsInput
  }

  export type MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    foodKindId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberFavoriteFoodKindCreateOrConnectWithoutMemberInput = {
    where: MemberFavoriteFoodKindWhereUniqueInput
    create: XOR<MemberFavoriteFoodKindCreateWithoutMemberInput, MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput>
  }

  export type MemberFavoriteFoodKindCreateManyMemberInputEnvelope = {
    data: MemberFavoriteFoodKindCreateManyMemberInput | MemberFavoriteFoodKindCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type RestaurantCreateWithoutCeoInput = {
    id?: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    region: RegionCreateNestedOneWithoutRestaurantInput
    missions?: MissionCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewCreateNestedManyWithoutRestaurantInput
    images?: ImageCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutCeoInput = {
    id?: bigint | number
    regionId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    missions?: MissionUncheckedCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRestaurantInput
    images?: ImageUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutCeoInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutCeoInput, RestaurantUncheckedCreateWithoutCeoInput>
  }

  export type RestaurantCreateManyCeoInputEnvelope = {
    data: RestaurantCreateManyCeoInput | RestaurantCreateManyCeoInput[]
    skipDuplicates?: boolean
  }

  export type MemberMissionCreateWithoutMemberInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    mission: MissionCreateNestedOneWithoutMemberMissionInput
  }

  export type MemberMissionUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    missionId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberMissionCreateOrConnectWithoutMemberInput = {
    where: MemberMissionWhereUniqueInput
    create: XOR<MemberMissionCreateWithoutMemberInput, MemberMissionUncheckedCreateWithoutMemberInput>
  }

  export type MemberMissionCreateManyMemberInputEnvelope = {
    data: MemberMissionCreateManyMemberInput | MemberMissionCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutMemberInput = {
    id?: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    restaurant: RestaurantCreateNestedOneWithoutReviewsInput
    replys?: ReplyCreateNestedManyWithoutReviewInput
    images?: ImageCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    restaurantId: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    replys?: ReplyUncheckedCreateNestedManyWithoutReviewInput
    images?: ImageUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutMemberInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutMemberInput, ReviewUncheckedCreateWithoutMemberInput>
  }

  export type ReviewCreateManyMemberInputEnvelope = {
    data: ReviewCreateManyMemberInput | ReviewCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type ReplyCreateWithoutMemberInput = {
    id?: bigint | number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    review: ReviewCreateNestedOneWithoutReplysInput
  }

  export type ReplyUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    reviewId: bigint | number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ReplyCreateOrConnectWithoutMemberInput = {
    where: ReplyWhereUniqueInput
    create: XOR<ReplyCreateWithoutMemberInput, ReplyUncheckedCreateWithoutMemberInput>
  }

  export type ReplyCreateManyMemberInputEnvelope = {
    data: ReplyCreateManyMemberInput | ReplyCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutMemberInput = {
    id?: bigint | number
    title: string
    content: string
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    images?: ImageCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    title: string
    content: string
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    images?: ImageUncheckedCreateNestedManyWithoutInquiryInput
  }

  export type InquiryCreateOrConnectWithoutMemberInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutMemberInput, InquiryUncheckedCreateWithoutMemberInput>
  }

  export type InquiryCreateManyMemberInputEnvelope = {
    data: InquiryCreateManyMemberInput | InquiryCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type AlarmCreateWithoutMemberInput = {
    id?: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    alarmsNewMissions?: AlarmNewMissionCreateNestedManyWithoutAlarmInput
    alarmReviewRequest?: AlarmReviewRequestCreateNestedManyWithoutAlarmInput
  }

  export type AlarmUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    alarmsNewMissions?: AlarmNewMissionUncheckedCreateNestedManyWithoutAlarmInput
    alarmReviewRequest?: AlarmReviewRequestUncheckedCreateNestedManyWithoutAlarmInput
  }

  export type AlarmCreateOrConnectWithoutMemberInput = {
    where: AlarmWhereUniqueInput
    create: XOR<AlarmCreateWithoutMemberInput, AlarmUncheckedCreateWithoutMemberInput>
  }

  export type AlarmCreateManyMemberInputEnvelope = {
    data: AlarmCreateManyMemberInput | AlarmCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberFavoriteFoodKindWhereUniqueInput
    update: XOR<MemberFavoriteFoodKindUpdateWithoutMemberInput, MemberFavoriteFoodKindUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberFavoriteFoodKindCreateWithoutMemberInput, MemberFavoriteFoodKindUncheckedCreateWithoutMemberInput>
  }

  export type MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberFavoriteFoodKindWhereUniqueInput
    data: XOR<MemberFavoriteFoodKindUpdateWithoutMemberInput, MemberFavoriteFoodKindUncheckedUpdateWithoutMemberInput>
  }

  export type MemberFavoriteFoodKindUpdateManyWithWhereWithoutMemberInput = {
    where: MemberFavoriteFoodKindScalarWhereInput
    data: XOR<MemberFavoriteFoodKindUpdateManyMutationInput, MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberFavoriteFoodKindScalarWhereInput = {
    AND?: MemberFavoriteFoodKindScalarWhereInput | MemberFavoriteFoodKindScalarWhereInput[]
    OR?: MemberFavoriteFoodKindScalarWhereInput[]
    NOT?: MemberFavoriteFoodKindScalarWhereInput | MemberFavoriteFoodKindScalarWhereInput[]
    id?: BigIntFilter<"MemberFavoriteFoodKind"> | bigint | number
    memberId?: BigIntFilter<"MemberFavoriteFoodKind"> | bigint | number
    foodKindId?: BigIntFilter<"MemberFavoriteFoodKind"> | bigint | number
    createdAt?: DateTimeFilter<"MemberFavoriteFoodKind"> | Date | string
    updatedAt?: DateTimeFilter<"MemberFavoriteFoodKind"> | Date | string
    status?: IntFilter<"MemberFavoriteFoodKind"> | number
  }

  export type RestaurantUpsertWithWhereUniqueWithoutCeoInput = {
    where: RestaurantWhereUniqueInput
    update: XOR<RestaurantUpdateWithoutCeoInput, RestaurantUncheckedUpdateWithoutCeoInput>
    create: XOR<RestaurantCreateWithoutCeoInput, RestaurantUncheckedCreateWithoutCeoInput>
  }

  export type RestaurantUpdateWithWhereUniqueWithoutCeoInput = {
    where: RestaurantWhereUniqueInput
    data: XOR<RestaurantUpdateWithoutCeoInput, RestaurantUncheckedUpdateWithoutCeoInput>
  }

  export type RestaurantUpdateManyWithWhereWithoutCeoInput = {
    where: RestaurantScalarWhereInput
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyWithoutCeoInput>
  }

  export type RestaurantScalarWhereInput = {
    AND?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
    OR?: RestaurantScalarWhereInput[]
    NOT?: RestaurantScalarWhereInput | RestaurantScalarWhereInput[]
    id?: BigIntFilter<"Restaurant"> | bigint | number
    ceoId?: BigIntFilter<"Restaurant"> | bigint | number
    regionId?: BigIntFilter<"Restaurant"> | bigint | number
    name?: StringFilter<"Restaurant"> | string
    introduction?: StringFilter<"Restaurant"> | string
    startTime?: StringFilter<"Restaurant"> | string
    endTime?: StringFilter<"Restaurant"> | string
    totalRating?: DecimalFilter<"Restaurant"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    status?: IntFilter<"Restaurant"> | number
  }

  export type MemberMissionUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberMissionWhereUniqueInput
    update: XOR<MemberMissionUpdateWithoutMemberInput, MemberMissionUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberMissionCreateWithoutMemberInput, MemberMissionUncheckedCreateWithoutMemberInput>
  }

  export type MemberMissionUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberMissionWhereUniqueInput
    data: XOR<MemberMissionUpdateWithoutMemberInput, MemberMissionUncheckedUpdateWithoutMemberInput>
  }

  export type MemberMissionUpdateManyWithWhereWithoutMemberInput = {
    where: MemberMissionScalarWhereInput
    data: XOR<MemberMissionUpdateManyMutationInput, MemberMissionUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberMissionScalarWhereInput = {
    AND?: MemberMissionScalarWhereInput | MemberMissionScalarWhereInput[]
    OR?: MemberMissionScalarWhereInput[]
    NOT?: MemberMissionScalarWhereInput | MemberMissionScalarWhereInput[]
    id?: BigIntFilter<"MemberMission"> | bigint | number
    memberId?: BigIntFilter<"MemberMission"> | bigint | number
    missionId?: BigIntFilter<"MemberMission"> | bigint | number
    createdAt?: DateTimeFilter<"MemberMission"> | Date | string
    updatedAt?: DateTimeFilter<"MemberMission"> | Date | string
    status?: IntFilter<"MemberMission"> | number
  }

  export type ReviewUpsertWithWhereUniqueWithoutMemberInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutMemberInput, ReviewUncheckedUpdateWithoutMemberInput>
    create: XOR<ReviewCreateWithoutMemberInput, ReviewUncheckedCreateWithoutMemberInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutMemberInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutMemberInput, ReviewUncheckedUpdateWithoutMemberInput>
  }

  export type ReviewUpdateManyWithWhereWithoutMemberInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutMemberInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: BigIntFilter<"Review"> | bigint | number
    memberId?: BigIntFilter<"Review"> | bigint | number
    restaurantId?: BigIntFilter<"Review"> | bigint | number
    rating?: DecimalFilter<"Review"> | Decimal | DecimalJsLike | number | string
    content?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    status?: IntFilter<"Review"> | number
  }

  export type ReplyUpsertWithWhereUniqueWithoutMemberInput = {
    where: ReplyWhereUniqueInput
    update: XOR<ReplyUpdateWithoutMemberInput, ReplyUncheckedUpdateWithoutMemberInput>
    create: XOR<ReplyCreateWithoutMemberInput, ReplyUncheckedCreateWithoutMemberInput>
  }

  export type ReplyUpdateWithWhereUniqueWithoutMemberInput = {
    where: ReplyWhereUniqueInput
    data: XOR<ReplyUpdateWithoutMemberInput, ReplyUncheckedUpdateWithoutMemberInput>
  }

  export type ReplyUpdateManyWithWhereWithoutMemberInput = {
    where: ReplyScalarWhereInput
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyWithoutMemberInput>
  }

  export type ReplyScalarWhereInput = {
    AND?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
    OR?: ReplyScalarWhereInput[]
    NOT?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
    id?: BigIntFilter<"Reply"> | bigint | number
    memberId?: BigIntFilter<"Reply"> | bigint | number
    reviewId?: BigIntFilter<"Reply"> | bigint | number
    content?: StringFilter<"Reply"> | string
    createdAt?: DateTimeFilter<"Reply"> | Date | string
    updatedAt?: DateTimeFilter<"Reply"> | Date | string
    status?: IntFilter<"Reply"> | number
  }

  export type InquiryUpsertWithWhereUniqueWithoutMemberInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutMemberInput, InquiryUncheckedUpdateWithoutMemberInput>
    create: XOR<InquiryCreateWithoutMemberInput, InquiryUncheckedCreateWithoutMemberInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutMemberInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutMemberInput, InquiryUncheckedUpdateWithoutMemberInput>
  }

  export type InquiryUpdateManyWithWhereWithoutMemberInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutMemberInput>
  }

  export type InquiryScalarWhereInput = {
    AND?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    OR?: InquiryScalarWhereInput[]
    NOT?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    id?: BigIntFilter<"Inquiry"> | bigint | number
    memberId?: BigIntFilter<"Inquiry"> | bigint | number
    title?: StringFilter<"Inquiry"> | string
    content?: StringFilter<"Inquiry"> | string
    isConfirmed?: IntFilter<"Inquiry"> | number
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
    status?: IntFilter<"Inquiry"> | number
  }

  export type AlarmUpsertWithWhereUniqueWithoutMemberInput = {
    where: AlarmWhereUniqueInput
    update: XOR<AlarmUpdateWithoutMemberInput, AlarmUncheckedUpdateWithoutMemberInput>
    create: XOR<AlarmCreateWithoutMemberInput, AlarmUncheckedCreateWithoutMemberInput>
  }

  export type AlarmUpdateWithWhereUniqueWithoutMemberInput = {
    where: AlarmWhereUniqueInput
    data: XOR<AlarmUpdateWithoutMemberInput, AlarmUncheckedUpdateWithoutMemberInput>
  }

  export type AlarmUpdateManyWithWhereWithoutMemberInput = {
    where: AlarmScalarWhereInput
    data: XOR<AlarmUpdateManyMutationInput, AlarmUncheckedUpdateManyWithoutMemberInput>
  }

  export type AlarmScalarWhereInput = {
    AND?: AlarmScalarWhereInput | AlarmScalarWhereInput[]
    OR?: AlarmScalarWhereInput[]
    NOT?: AlarmScalarWhereInput | AlarmScalarWhereInput[]
    id?: BigIntFilter<"Alarm"> | bigint | number
    memberId?: BigIntFilter<"Alarm"> | bigint | number
    isConfirmed?: IntFilter<"Alarm"> | number
    createdAt?: DateTimeFilter<"Alarm"> | Date | string
    updatedAt?: DateTimeFilter<"Alarm"> | Date | string
    status?: IntFilter<"Alarm"> | number
  }

  export type MemberFavoriteFoodKindCreateWithoutFoodKindInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutMemberfavoriteFoodKindsInput
  }

  export type MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput = {
    id?: bigint | number
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberFavoriteFoodKindCreateOrConnectWithoutFoodKindInput = {
    where: MemberFavoriteFoodKindWhereUniqueInput
    create: XOR<MemberFavoriteFoodKindCreateWithoutFoodKindInput, MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput>
  }

  export type MemberFavoriteFoodKindCreateManyFoodKindInputEnvelope = {
    data: MemberFavoriteFoodKindCreateManyFoodKindInput | MemberFavoriteFoodKindCreateManyFoodKindInput[]
    skipDuplicates?: boolean
  }

  export type FoodKindRestaurantCreateWithoutFoodKindInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    restaurant: RestaurantCreateNestedOneWithoutFoodKindRestaurantsInput
  }

  export type FoodKindRestaurantUncheckedCreateWithoutFoodKindInput = {
    id?: bigint | number
    restaurantId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type FoodKindRestaurantCreateOrConnectWithoutFoodKindInput = {
    where: FoodKindRestaurantWhereUniqueInput
    create: XOR<FoodKindRestaurantCreateWithoutFoodKindInput, FoodKindRestaurantUncheckedCreateWithoutFoodKindInput>
  }

  export type FoodKindRestaurantCreateManyFoodKindInputEnvelope = {
    data: FoodKindRestaurantCreateManyFoodKindInput | FoodKindRestaurantCreateManyFoodKindInput[]
    skipDuplicates?: boolean
  }

  export type MemberFavoriteFoodKindUpsertWithWhereUniqueWithoutFoodKindInput = {
    where: MemberFavoriteFoodKindWhereUniqueInput
    update: XOR<MemberFavoriteFoodKindUpdateWithoutFoodKindInput, MemberFavoriteFoodKindUncheckedUpdateWithoutFoodKindInput>
    create: XOR<MemberFavoriteFoodKindCreateWithoutFoodKindInput, MemberFavoriteFoodKindUncheckedCreateWithoutFoodKindInput>
  }

  export type MemberFavoriteFoodKindUpdateWithWhereUniqueWithoutFoodKindInput = {
    where: MemberFavoriteFoodKindWhereUniqueInput
    data: XOR<MemberFavoriteFoodKindUpdateWithoutFoodKindInput, MemberFavoriteFoodKindUncheckedUpdateWithoutFoodKindInput>
  }

  export type MemberFavoriteFoodKindUpdateManyWithWhereWithoutFoodKindInput = {
    where: MemberFavoriteFoodKindScalarWhereInput
    data: XOR<MemberFavoriteFoodKindUpdateManyMutationInput, MemberFavoriteFoodKindUncheckedUpdateManyWithoutFoodKindInput>
  }

  export type FoodKindRestaurantUpsertWithWhereUniqueWithoutFoodKindInput = {
    where: FoodKindRestaurantWhereUniqueInput
    update: XOR<FoodKindRestaurantUpdateWithoutFoodKindInput, FoodKindRestaurantUncheckedUpdateWithoutFoodKindInput>
    create: XOR<FoodKindRestaurantCreateWithoutFoodKindInput, FoodKindRestaurantUncheckedCreateWithoutFoodKindInput>
  }

  export type FoodKindRestaurantUpdateWithWhereUniqueWithoutFoodKindInput = {
    where: FoodKindRestaurantWhereUniqueInput
    data: XOR<FoodKindRestaurantUpdateWithoutFoodKindInput, FoodKindRestaurantUncheckedUpdateWithoutFoodKindInput>
  }

  export type FoodKindRestaurantUpdateManyWithWhereWithoutFoodKindInput = {
    where: FoodKindRestaurantScalarWhereInput
    data: XOR<FoodKindRestaurantUpdateManyMutationInput, FoodKindRestaurantUncheckedUpdateManyWithoutFoodKindInput>
  }

  export type FoodKindRestaurantScalarWhereInput = {
    AND?: FoodKindRestaurantScalarWhereInput | FoodKindRestaurantScalarWhereInput[]
    OR?: FoodKindRestaurantScalarWhereInput[]
    NOT?: FoodKindRestaurantScalarWhereInput | FoodKindRestaurantScalarWhereInput[]
    id?: BigIntFilter<"FoodKindRestaurant"> | bigint | number
    foodKindId?: BigIntFilter<"FoodKindRestaurant"> | bigint | number
    restaurantId?: BigIntFilter<"FoodKindRestaurant"> | bigint | number
    createdAt?: DateTimeFilter<"FoodKindRestaurant"> | Date | string
    updatedAt?: DateTimeFilter<"FoodKindRestaurant"> | Date | string
    status?: IntFilter<"FoodKindRestaurant"> | number
  }

  export type MemberCreateWithoutMemberfavoriteFoodKindsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    restaurants?: RestaurantCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionCreateNestedManyWithoutMemberInput
    reviews?: ReviewCreateNestedManyWithoutMemberInput
    reply?: ReplyCreateNestedManyWithoutMemberInput
    inquiries?: InquiryCreateNestedManyWithoutMemberInput
    alarms?: AlarmCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberfavoriteFoodKindsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionUncheckedCreateNestedManyWithoutMemberInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMemberInput
    reply?: ReplyUncheckedCreateNestedManyWithoutMemberInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutMemberInput
    alarms?: AlarmUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberfavoriteFoodKindsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberfavoriteFoodKindsInput, MemberUncheckedCreateWithoutMemberfavoriteFoodKindsInput>
  }

  export type FoodKindCreateWithoutMemberfavoriteFoodKindsInput = {
    id?: bigint | number
    kind: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    foodKindRestaurants?: FoodKindRestaurantCreateNestedManyWithoutFoodKindInput
  }

  export type FoodKindUncheckedCreateWithoutMemberfavoriteFoodKindsInput = {
    id?: bigint | number
    kind: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    foodKindRestaurants?: FoodKindRestaurantUncheckedCreateNestedManyWithoutFoodKindInput
  }

  export type FoodKindCreateOrConnectWithoutMemberfavoriteFoodKindsInput = {
    where: FoodKindWhereUniqueInput
    create: XOR<FoodKindCreateWithoutMemberfavoriteFoodKindsInput, FoodKindUncheckedCreateWithoutMemberfavoriteFoodKindsInput>
  }

  export type MemberUpsertWithoutMemberfavoriteFoodKindsInput = {
    update: XOR<MemberUpdateWithoutMemberfavoriteFoodKindsInput, MemberUncheckedUpdateWithoutMemberfavoriteFoodKindsInput>
    create: XOR<MemberCreateWithoutMemberfavoriteFoodKindsInput, MemberUncheckedCreateWithoutMemberfavoriteFoodKindsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMemberfavoriteFoodKindsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMemberfavoriteFoodKindsInput, MemberUncheckedUpdateWithoutMemberfavoriteFoodKindsInput>
  }

  export type MemberUpdateWithoutMemberfavoriteFoodKindsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restaurants?: RestaurantUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUpdateManyWithoutMemberNestedInput
    reply?: ReplyUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberfavoriteFoodKindsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restaurants?: RestaurantUncheckedUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUncheckedUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMemberNestedInput
    reply?: ReplyUncheckedUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type FoodKindUpsertWithoutMemberfavoriteFoodKindsInput = {
    update: XOR<FoodKindUpdateWithoutMemberfavoriteFoodKindsInput, FoodKindUncheckedUpdateWithoutMemberfavoriteFoodKindsInput>
    create: XOR<FoodKindCreateWithoutMemberfavoriteFoodKindsInput, FoodKindUncheckedCreateWithoutMemberfavoriteFoodKindsInput>
    where?: FoodKindWhereInput
  }

  export type FoodKindUpdateToOneWithWhereWithoutMemberfavoriteFoodKindsInput = {
    where?: FoodKindWhereInput
    data: XOR<FoodKindUpdateWithoutMemberfavoriteFoodKindsInput, FoodKindUncheckedUpdateWithoutMemberfavoriteFoodKindsInput>
  }

  export type FoodKindUpdateWithoutMemberfavoriteFoodKindsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    kind?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    foodKindRestaurants?: FoodKindRestaurantUpdateManyWithoutFoodKindNestedInput
  }

  export type FoodKindUncheckedUpdateWithoutMemberfavoriteFoodKindsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    kind?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    foodKindRestaurants?: FoodKindRestaurantUncheckedUpdateManyWithoutFoodKindNestedInput
  }

  export type RestaurantCreateWithoutRegionInput = {
    id?: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    ceo: MemberCreateNestedOneWithoutRestaurantsInput
    missions?: MissionCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewCreateNestedManyWithoutRestaurantInput
    images?: ImageCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutRegionInput = {
    id?: bigint | number
    ceoId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    missions?: MissionUncheckedCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRestaurantInput
    images?: ImageUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutRegionInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutRegionInput, RestaurantUncheckedCreateWithoutRegionInput>
  }

  export type RestaurantCreateManyRegionInputEnvelope = {
    data: RestaurantCreateManyRegionInput | RestaurantCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type RestaurantUpsertWithWhereUniqueWithoutRegionInput = {
    where: RestaurantWhereUniqueInput
    update: XOR<RestaurantUpdateWithoutRegionInput, RestaurantUncheckedUpdateWithoutRegionInput>
    create: XOR<RestaurantCreateWithoutRegionInput, RestaurantUncheckedCreateWithoutRegionInput>
  }

  export type RestaurantUpdateWithWhereUniqueWithoutRegionInput = {
    where: RestaurantWhereUniqueInput
    data: XOR<RestaurantUpdateWithoutRegionInput, RestaurantUncheckedUpdateWithoutRegionInput>
  }

  export type RestaurantUpdateManyWithWhereWithoutRegionInput = {
    where: RestaurantScalarWhereInput
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyWithoutRegionInput>
  }

  export type MemberCreateWithoutRestaurantsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindCreateNestedManyWithoutMemberInput
    memberMissions?: MemberMissionCreateNestedManyWithoutMemberInput
    reviews?: ReviewCreateNestedManyWithoutMemberInput
    reply?: ReplyCreateNestedManyWithoutMemberInput
    inquiries?: InquiryCreateNestedManyWithoutMemberInput
    alarms?: AlarmCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutRestaurantsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutMemberInput
    memberMissions?: MemberMissionUncheckedCreateNestedManyWithoutMemberInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMemberInput
    reply?: ReplyUncheckedCreateNestedManyWithoutMemberInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutMemberInput
    alarms?: AlarmUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutRestaurantsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutRestaurantsInput, MemberUncheckedCreateWithoutRestaurantsInput>
  }

  export type RegionCreateWithoutRestaurantInput = {
    id?: bigint | number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type RegionUncheckedCreateWithoutRestaurantInput = {
    id?: bigint | number
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type RegionCreateOrConnectWithoutRestaurantInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutRestaurantInput, RegionUncheckedCreateWithoutRestaurantInput>
  }

  export type MissionCreateWithoutRestaurantInput = {
    id?: bigint | number
    name: string
    introduction: string
    deadline: Date | string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    memberMission?: MemberMissionCreateNestedManyWithoutMissionInput
  }

  export type MissionUncheckedCreateWithoutRestaurantInput = {
    id?: bigint | number
    name: string
    introduction: string
    deadline: Date | string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    memberMission?: MemberMissionUncheckedCreateNestedManyWithoutMissionInput
  }

  export type MissionCreateOrConnectWithoutRestaurantInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutRestaurantInput, MissionUncheckedCreateWithoutRestaurantInput>
  }

  export type MissionCreateManyRestaurantInputEnvelope = {
    data: MissionCreateManyRestaurantInput | MissionCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type FoodKindRestaurantCreateWithoutRestaurantInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    foodKind: FoodKindCreateNestedOneWithoutFoodKindRestaurantsInput
  }

  export type FoodKindRestaurantUncheckedCreateWithoutRestaurantInput = {
    id?: bigint | number
    foodKindId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type FoodKindRestaurantCreateOrConnectWithoutRestaurantInput = {
    where: FoodKindRestaurantWhereUniqueInput
    create: XOR<FoodKindRestaurantCreateWithoutRestaurantInput, FoodKindRestaurantUncheckedCreateWithoutRestaurantInput>
  }

  export type FoodKindRestaurantCreateManyRestaurantInputEnvelope = {
    data: FoodKindRestaurantCreateManyRestaurantInput | FoodKindRestaurantCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutRestaurantInput = {
    id?: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutReviewsInput
    replys?: ReplyCreateNestedManyWithoutReviewInput
    images?: ImageCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutRestaurantInput = {
    id?: bigint | number
    memberId: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    replys?: ReplyUncheckedCreateNestedManyWithoutReviewInput
    images?: ImageUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutRestaurantInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutRestaurantInput, ReviewUncheckedCreateWithoutRestaurantInput>
  }

  export type ReviewCreateManyRestaurantInputEnvelope = {
    data: ReviewCreateManyRestaurantInput | ReviewCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type ImageCreateWithoutRestaurantInput = {
    id?: bigint | number
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    review?: ReviewCreateNestedOneWithoutImagesInput
    inquiry?: InquiryCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutRestaurantInput = {
    id?: bigint | number
    reviewId?: bigint | number | null
    inquiryId?: bigint | number | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ImageCreateOrConnectWithoutRestaurantInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutRestaurantInput, ImageUncheckedCreateWithoutRestaurantInput>
  }

  export type ImageCreateManyRestaurantInputEnvelope = {
    data: ImageCreateManyRestaurantInput | ImageCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutRestaurantsInput = {
    update: XOR<MemberUpdateWithoutRestaurantsInput, MemberUncheckedUpdateWithoutRestaurantsInput>
    create: XOR<MemberCreateWithoutRestaurantsInput, MemberUncheckedCreateWithoutRestaurantsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutRestaurantsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutRestaurantsInput, MemberUncheckedUpdateWithoutRestaurantsInput>
  }

  export type MemberUpdateWithoutRestaurantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUpdateManyWithoutMemberNestedInput
    memberMissions?: MemberMissionUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUpdateManyWithoutMemberNestedInput
    reply?: ReplyUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutRestaurantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberNestedInput
    memberMissions?: MemberMissionUncheckedUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMemberNestedInput
    reply?: ReplyUncheckedUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type RegionUpsertWithoutRestaurantInput = {
    update: XOR<RegionUpdateWithoutRestaurantInput, RegionUncheckedUpdateWithoutRestaurantInput>
    create: XOR<RegionCreateWithoutRestaurantInput, RegionUncheckedCreateWithoutRestaurantInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutRestaurantInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutRestaurantInput, RegionUncheckedUpdateWithoutRestaurantInput>
  }

  export type RegionUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type RegionUncheckedUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MissionUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: MissionWhereUniqueInput
    update: XOR<MissionUpdateWithoutRestaurantInput, MissionUncheckedUpdateWithoutRestaurantInput>
    create: XOR<MissionCreateWithoutRestaurantInput, MissionUncheckedCreateWithoutRestaurantInput>
  }

  export type MissionUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: MissionWhereUniqueInput
    data: XOR<MissionUpdateWithoutRestaurantInput, MissionUncheckedUpdateWithoutRestaurantInput>
  }

  export type MissionUpdateManyWithWhereWithoutRestaurantInput = {
    where: MissionScalarWhereInput
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type MissionScalarWhereInput = {
    AND?: MissionScalarWhereInput | MissionScalarWhereInput[]
    OR?: MissionScalarWhereInput[]
    NOT?: MissionScalarWhereInput | MissionScalarWhereInput[]
    id?: BigIntFilter<"Mission"> | bigint | number
    restaurantId?: BigIntFilter<"Mission"> | bigint | number
    name?: StringFilter<"Mission"> | string
    introduction?: StringFilter<"Mission"> | string
    deadline?: DateTimeFilter<"Mission"> | Date | string
    points?: IntFilter<"Mission"> | number
    createdAt?: DateTimeFilter<"Mission"> | Date | string
    updatedAt?: DateTimeFilter<"Mission"> | Date | string
    status?: IntFilter<"Mission"> | number
  }

  export type FoodKindRestaurantUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: FoodKindRestaurantWhereUniqueInput
    update: XOR<FoodKindRestaurantUpdateWithoutRestaurantInput, FoodKindRestaurantUncheckedUpdateWithoutRestaurantInput>
    create: XOR<FoodKindRestaurantCreateWithoutRestaurantInput, FoodKindRestaurantUncheckedCreateWithoutRestaurantInput>
  }

  export type FoodKindRestaurantUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: FoodKindRestaurantWhereUniqueInput
    data: XOR<FoodKindRestaurantUpdateWithoutRestaurantInput, FoodKindRestaurantUncheckedUpdateWithoutRestaurantInput>
  }

  export type FoodKindRestaurantUpdateManyWithWhereWithoutRestaurantInput = {
    where: FoodKindRestaurantScalarWhereInput
    data: XOR<FoodKindRestaurantUpdateManyMutationInput, FoodKindRestaurantUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutRestaurantInput, ReviewUncheckedUpdateWithoutRestaurantInput>
    create: XOR<ReviewCreateWithoutRestaurantInput, ReviewUncheckedCreateWithoutRestaurantInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutRestaurantInput, ReviewUncheckedUpdateWithoutRestaurantInput>
  }

  export type ReviewUpdateManyWithWhereWithoutRestaurantInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type ImageUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutRestaurantInput, ImageUncheckedUpdateWithoutRestaurantInput>
    create: XOR<ImageCreateWithoutRestaurantInput, ImageUncheckedCreateWithoutRestaurantInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutRestaurantInput, ImageUncheckedUpdateWithoutRestaurantInput>
  }

  export type ImageUpdateManyWithWhereWithoutRestaurantInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    id?: BigIntFilter<"Image"> | bigint | number
    restaurantId?: BigIntNullableFilter<"Image"> | bigint | number | null
    reviewId?: BigIntNullableFilter<"Image"> | bigint | number | null
    inquiryId?: BigIntNullableFilter<"Image"> | bigint | number | null
    imageUrl?: StringFilter<"Image"> | string
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
    status?: IntFilter<"Image"> | number
  }

  export type RestaurantCreateWithoutMissionsInput = {
    id?: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    ceo: MemberCreateNestedOneWithoutRestaurantsInput
    region: RegionCreateNestedOneWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewCreateNestedManyWithoutRestaurantInput
    images?: ImageCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutMissionsInput = {
    id?: bigint | number
    ceoId: bigint | number
    regionId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    foodKindRestaurants?: FoodKindRestaurantUncheckedCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRestaurantInput
    images?: ImageUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutMissionsInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutMissionsInput, RestaurantUncheckedCreateWithoutMissionsInput>
  }

  export type MemberMissionCreateWithoutMissionInput = {
    id?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutMemberMissionsInput
  }

  export type MemberMissionUncheckedCreateWithoutMissionInput = {
    id?: bigint | number
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberMissionCreateOrConnectWithoutMissionInput = {
    where: MemberMissionWhereUniqueInput
    create: XOR<MemberMissionCreateWithoutMissionInput, MemberMissionUncheckedCreateWithoutMissionInput>
  }

  export type MemberMissionCreateManyMissionInputEnvelope = {
    data: MemberMissionCreateManyMissionInput | MemberMissionCreateManyMissionInput[]
    skipDuplicates?: boolean
  }

  export type RestaurantUpsertWithoutMissionsInput = {
    update: XOR<RestaurantUpdateWithoutMissionsInput, RestaurantUncheckedUpdateWithoutMissionsInput>
    create: XOR<RestaurantCreateWithoutMissionsInput, RestaurantUncheckedCreateWithoutMissionsInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutMissionsInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutMissionsInput, RestaurantUncheckedUpdateWithoutMissionsInput>
  }

  export type RestaurantUpdateWithoutMissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    ceo?: MemberUpdateOneRequiredWithoutRestaurantsNestedInput
    region?: RegionUpdateOneRequiredWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUpdateManyWithoutRestaurantNestedInput
    images?: ImageUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutMissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ceoId?: BigIntFieldUpdateOperationsInput | bigint | number
    regionId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    foodKindRestaurants?: FoodKindRestaurantUncheckedUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRestaurantNestedInput
    images?: ImageUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type MemberMissionUpsertWithWhereUniqueWithoutMissionInput = {
    where: MemberMissionWhereUniqueInput
    update: XOR<MemberMissionUpdateWithoutMissionInput, MemberMissionUncheckedUpdateWithoutMissionInput>
    create: XOR<MemberMissionCreateWithoutMissionInput, MemberMissionUncheckedCreateWithoutMissionInput>
  }

  export type MemberMissionUpdateWithWhereUniqueWithoutMissionInput = {
    where: MemberMissionWhereUniqueInput
    data: XOR<MemberMissionUpdateWithoutMissionInput, MemberMissionUncheckedUpdateWithoutMissionInput>
  }

  export type MemberMissionUpdateManyWithWhereWithoutMissionInput = {
    where: MemberMissionScalarWhereInput
    data: XOR<MemberMissionUpdateManyMutationInput, MemberMissionUncheckedUpdateManyWithoutMissionInput>
  }

  export type MemberCreateWithoutMemberMissionsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantCreateNestedManyWithoutCeoInput
    reviews?: ReviewCreateNestedManyWithoutMemberInput
    reply?: ReplyCreateNestedManyWithoutMemberInput
    inquiries?: InquiryCreateNestedManyWithoutMemberInput
    alarms?: AlarmCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberMissionsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCeoInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMemberInput
    reply?: ReplyUncheckedCreateNestedManyWithoutMemberInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutMemberInput
    alarms?: AlarmUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberMissionsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberMissionsInput, MemberUncheckedCreateWithoutMemberMissionsInput>
  }

  export type MissionCreateWithoutMemberMissionInput = {
    id?: bigint | number
    name: string
    introduction: string
    deadline: Date | string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    restaurant: RestaurantCreateNestedOneWithoutMissionsInput
  }

  export type MissionUncheckedCreateWithoutMemberMissionInput = {
    id?: bigint | number
    restaurantId: bigint | number
    name: string
    introduction: string
    deadline: Date | string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MissionCreateOrConnectWithoutMemberMissionInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutMemberMissionInput, MissionUncheckedCreateWithoutMemberMissionInput>
  }

  export type MemberUpsertWithoutMemberMissionsInput = {
    update: XOR<MemberUpdateWithoutMemberMissionsInput, MemberUncheckedUpdateWithoutMemberMissionsInput>
    create: XOR<MemberCreateWithoutMemberMissionsInput, MemberUncheckedCreateWithoutMemberMissionsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMemberMissionsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMemberMissionsInput, MemberUncheckedUpdateWithoutMemberMissionsInput>
  }

  export type MemberUpdateWithoutMemberMissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUpdateManyWithoutCeoNestedInput
    reviews?: ReviewUpdateManyWithoutMemberNestedInput
    reply?: ReplyUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberMissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCeoNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMemberNestedInput
    reply?: ReplyUncheckedUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MissionUpsertWithoutMemberMissionInput = {
    update: XOR<MissionUpdateWithoutMemberMissionInput, MissionUncheckedUpdateWithoutMemberMissionInput>
    create: XOR<MissionCreateWithoutMemberMissionInput, MissionUncheckedCreateWithoutMemberMissionInput>
    where?: MissionWhereInput
  }

  export type MissionUpdateToOneWithWhereWithoutMemberMissionInput = {
    where?: MissionWhereInput
    data: XOR<MissionUpdateWithoutMemberMissionInput, MissionUncheckedUpdateWithoutMemberMissionInput>
  }

  export type MissionUpdateWithoutMemberMissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutMissionsNestedInput
  }

  export type MissionUncheckedUpdateWithoutMemberMissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type FoodKindCreateWithoutFoodKindRestaurantsInput = {
    id?: bigint | number
    kind: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindCreateNestedManyWithoutFoodKindInput
  }

  export type FoodKindUncheckedCreateWithoutFoodKindRestaurantsInput = {
    id?: bigint | number
    kind: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutFoodKindInput
  }

  export type FoodKindCreateOrConnectWithoutFoodKindRestaurantsInput = {
    where: FoodKindWhereUniqueInput
    create: XOR<FoodKindCreateWithoutFoodKindRestaurantsInput, FoodKindUncheckedCreateWithoutFoodKindRestaurantsInput>
  }

  export type RestaurantCreateWithoutFoodKindRestaurantsInput = {
    id?: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    ceo: MemberCreateNestedOneWithoutRestaurantsInput
    region: RegionCreateNestedOneWithoutRestaurantInput
    missions?: MissionCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewCreateNestedManyWithoutRestaurantInput
    images?: ImageCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutFoodKindRestaurantsInput = {
    id?: bigint | number
    ceoId: bigint | number
    regionId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    missions?: MissionUncheckedCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRestaurantInput
    images?: ImageUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutFoodKindRestaurantsInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutFoodKindRestaurantsInput, RestaurantUncheckedCreateWithoutFoodKindRestaurantsInput>
  }

  export type FoodKindUpsertWithoutFoodKindRestaurantsInput = {
    update: XOR<FoodKindUpdateWithoutFoodKindRestaurantsInput, FoodKindUncheckedUpdateWithoutFoodKindRestaurantsInput>
    create: XOR<FoodKindCreateWithoutFoodKindRestaurantsInput, FoodKindUncheckedCreateWithoutFoodKindRestaurantsInput>
    where?: FoodKindWhereInput
  }

  export type FoodKindUpdateToOneWithWhereWithoutFoodKindRestaurantsInput = {
    where?: FoodKindWhereInput
    data: XOR<FoodKindUpdateWithoutFoodKindRestaurantsInput, FoodKindUncheckedUpdateWithoutFoodKindRestaurantsInput>
  }

  export type FoodKindUpdateWithoutFoodKindRestaurantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    kind?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUpdateManyWithoutFoodKindNestedInput
  }

  export type FoodKindUncheckedUpdateWithoutFoodKindRestaurantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    kind?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedUpdateManyWithoutFoodKindNestedInput
  }

  export type RestaurantUpsertWithoutFoodKindRestaurantsInput = {
    update: XOR<RestaurantUpdateWithoutFoodKindRestaurantsInput, RestaurantUncheckedUpdateWithoutFoodKindRestaurantsInput>
    create: XOR<RestaurantCreateWithoutFoodKindRestaurantsInput, RestaurantUncheckedCreateWithoutFoodKindRestaurantsInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutFoodKindRestaurantsInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutFoodKindRestaurantsInput, RestaurantUncheckedUpdateWithoutFoodKindRestaurantsInput>
  }

  export type RestaurantUpdateWithoutFoodKindRestaurantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    ceo?: MemberUpdateOneRequiredWithoutRestaurantsNestedInput
    region?: RegionUpdateOneRequiredWithoutRestaurantNestedInput
    missions?: MissionUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUpdateManyWithoutRestaurantNestedInput
    images?: ImageUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutFoodKindRestaurantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ceoId?: BigIntFieldUpdateOperationsInput | bigint | number
    regionId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    missions?: MissionUncheckedUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRestaurantNestedInput
    images?: ImageUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type MemberCreateWithoutReviewsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionCreateNestedManyWithoutMemberInput
    reply?: ReplyCreateNestedManyWithoutMemberInput
    inquiries?: InquiryCreateNestedManyWithoutMemberInput
    alarms?: AlarmCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutReviewsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionUncheckedCreateNestedManyWithoutMemberInput
    reply?: ReplyUncheckedCreateNestedManyWithoutMemberInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutMemberInput
    alarms?: AlarmUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutReviewsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutReviewsInput, MemberUncheckedCreateWithoutReviewsInput>
  }

  export type RestaurantCreateWithoutReviewsInput = {
    id?: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    ceo: MemberCreateNestedOneWithoutRestaurantsInput
    region: RegionCreateNestedOneWithoutRestaurantInput
    missions?: MissionCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantCreateNestedManyWithoutRestaurantInput
    images?: ImageCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutReviewsInput = {
    id?: bigint | number
    ceoId: bigint | number
    regionId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    missions?: MissionUncheckedCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedCreateNestedManyWithoutRestaurantInput
    images?: ImageUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutReviewsInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutReviewsInput, RestaurantUncheckedCreateWithoutReviewsInput>
  }

  export type ReplyCreateWithoutReviewInput = {
    id?: bigint | number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutReplyInput
  }

  export type ReplyUncheckedCreateWithoutReviewInput = {
    id?: bigint | number
    memberId: bigint | number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ReplyCreateOrConnectWithoutReviewInput = {
    where: ReplyWhereUniqueInput
    create: XOR<ReplyCreateWithoutReviewInput, ReplyUncheckedCreateWithoutReviewInput>
  }

  export type ReplyCreateManyReviewInputEnvelope = {
    data: ReplyCreateManyReviewInput | ReplyCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ImageCreateWithoutReviewInput = {
    id?: bigint | number
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    restaurant?: RestaurantCreateNestedOneWithoutImagesInput
    inquiry?: InquiryCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutReviewInput = {
    id?: bigint | number
    restaurantId?: bigint | number | null
    inquiryId?: bigint | number | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ImageCreateOrConnectWithoutReviewInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutReviewInput, ImageUncheckedCreateWithoutReviewInput>
  }

  export type ImageCreateManyReviewInputEnvelope = {
    data: ImageCreateManyReviewInput | ImageCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutReviewsInput = {
    update: XOR<MemberUpdateWithoutReviewsInput, MemberUncheckedUpdateWithoutReviewsInput>
    create: XOR<MemberCreateWithoutReviewsInput, MemberUncheckedCreateWithoutReviewsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutReviewsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutReviewsInput, MemberUncheckedUpdateWithoutReviewsInput>
  }

  export type MemberUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUpdateManyWithoutMemberNestedInput
    reply?: ReplyUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUncheckedUpdateManyWithoutMemberNestedInput
    reply?: ReplyUncheckedUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type RestaurantUpsertWithoutReviewsInput = {
    update: XOR<RestaurantUpdateWithoutReviewsInput, RestaurantUncheckedUpdateWithoutReviewsInput>
    create: XOR<RestaurantCreateWithoutReviewsInput, RestaurantUncheckedCreateWithoutReviewsInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutReviewsInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutReviewsInput, RestaurantUncheckedUpdateWithoutReviewsInput>
  }

  export type RestaurantUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    ceo?: MemberUpdateOneRequiredWithoutRestaurantsNestedInput
    region?: RegionUpdateOneRequiredWithoutRestaurantNestedInput
    missions?: MissionUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUpdateManyWithoutRestaurantNestedInput
    images?: ImageUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ceoId?: BigIntFieldUpdateOperationsInput | bigint | number
    regionId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    missions?: MissionUncheckedUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedUpdateManyWithoutRestaurantNestedInput
    images?: ImageUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type ReplyUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReplyWhereUniqueInput
    update: XOR<ReplyUpdateWithoutReviewInput, ReplyUncheckedUpdateWithoutReviewInput>
    create: XOR<ReplyCreateWithoutReviewInput, ReplyUncheckedCreateWithoutReviewInput>
  }

  export type ReplyUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReplyWhereUniqueInput
    data: XOR<ReplyUpdateWithoutReviewInput, ReplyUncheckedUpdateWithoutReviewInput>
  }

  export type ReplyUpdateManyWithWhereWithoutReviewInput = {
    where: ReplyScalarWhereInput
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyWithoutReviewInput>
  }

  export type ImageUpsertWithWhereUniqueWithoutReviewInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutReviewInput, ImageUncheckedUpdateWithoutReviewInput>
    create: XOR<ImageCreateWithoutReviewInput, ImageUncheckedCreateWithoutReviewInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutReviewInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutReviewInput, ImageUncheckedUpdateWithoutReviewInput>
  }

  export type ImageUpdateManyWithWhereWithoutReviewInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutReviewInput>
  }

  export type MemberCreateWithoutReplyInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionCreateNestedManyWithoutMemberInput
    reviews?: ReviewCreateNestedManyWithoutMemberInput
    inquiries?: InquiryCreateNestedManyWithoutMemberInput
    alarms?: AlarmCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutReplyInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionUncheckedCreateNestedManyWithoutMemberInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMemberInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutMemberInput
    alarms?: AlarmUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutReplyInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutReplyInput, MemberUncheckedCreateWithoutReplyInput>
  }

  export type ReviewCreateWithoutReplysInput = {
    id?: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutReviewsInput
    restaurant: RestaurantCreateNestedOneWithoutReviewsInput
    images?: ImageCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutReplysInput = {
    id?: bigint | number
    memberId: bigint | number
    restaurantId: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    images?: ImageUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutReplysInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutReplysInput, ReviewUncheckedCreateWithoutReplysInput>
  }

  export type MemberUpsertWithoutReplyInput = {
    update: XOR<MemberUpdateWithoutReplyInput, MemberUncheckedUpdateWithoutReplyInput>
    create: XOR<MemberCreateWithoutReplyInput, MemberUncheckedCreateWithoutReplyInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutReplyInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutReplyInput, MemberUncheckedUpdateWithoutReplyInput>
  }

  export type MemberUpdateWithoutReplyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutReplyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUncheckedUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type ReviewUpsertWithoutReplysInput = {
    update: XOR<ReviewUpdateWithoutReplysInput, ReviewUncheckedUpdateWithoutReplysInput>
    create: XOR<ReviewCreateWithoutReplysInput, ReviewUncheckedCreateWithoutReplysInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutReplysInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutReplysInput, ReviewUncheckedUpdateWithoutReplysInput>
  }

  export type ReviewUpdateWithoutReplysInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutReviewsNestedInput
    restaurant?: RestaurantUpdateOneRequiredWithoutReviewsNestedInput
    images?: ImageUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutReplysInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    images?: ImageUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type MemberCreateWithoutInquiriesInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionCreateNestedManyWithoutMemberInput
    reviews?: ReviewCreateNestedManyWithoutMemberInput
    reply?: ReplyCreateNestedManyWithoutMemberInput
    alarms?: AlarmCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutInquiriesInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionUncheckedCreateNestedManyWithoutMemberInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMemberInput
    reply?: ReplyUncheckedCreateNestedManyWithoutMemberInput
    alarms?: AlarmUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutInquiriesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutInquiriesInput, MemberUncheckedCreateWithoutInquiriesInput>
  }

  export type ImageCreateWithoutInquiryInput = {
    id?: bigint | number
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    restaurant?: RestaurantCreateNestedOneWithoutImagesInput
    review?: ReviewCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutInquiryInput = {
    id?: bigint | number
    restaurantId?: bigint | number | null
    reviewId?: bigint | number | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ImageCreateOrConnectWithoutInquiryInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutInquiryInput, ImageUncheckedCreateWithoutInquiryInput>
  }

  export type ImageCreateManyInquiryInputEnvelope = {
    data: ImageCreateManyInquiryInput | ImageCreateManyInquiryInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutInquiriesInput = {
    update: XOR<MemberUpdateWithoutInquiriesInput, MemberUncheckedUpdateWithoutInquiriesInput>
    create: XOR<MemberCreateWithoutInquiriesInput, MemberUncheckedCreateWithoutInquiriesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutInquiriesInput, MemberUncheckedUpdateWithoutInquiriesInput>
  }

  export type MemberUpdateWithoutInquiriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUpdateManyWithoutMemberNestedInput
    reply?: ReplyUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutInquiriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUncheckedUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMemberNestedInput
    reply?: ReplyUncheckedUpdateManyWithoutMemberNestedInput
    alarms?: AlarmUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type ImageUpsertWithWhereUniqueWithoutInquiryInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutInquiryInput, ImageUncheckedUpdateWithoutInquiryInput>
    create: XOR<ImageCreateWithoutInquiryInput, ImageUncheckedCreateWithoutInquiryInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutInquiryInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutInquiryInput, ImageUncheckedUpdateWithoutInquiryInput>
  }

  export type ImageUpdateManyWithWhereWithoutInquiryInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutInquiryInput>
  }

  export type RestaurantCreateWithoutImagesInput = {
    id?: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    ceo: MemberCreateNestedOneWithoutRestaurantsInput
    region: RegionCreateNestedOneWithoutRestaurantInput
    missions?: MissionCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutImagesInput = {
    id?: bigint | number
    ceoId: bigint | number
    regionId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    missions?: MissionUncheckedCreateNestedManyWithoutRestaurantInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedCreateNestedManyWithoutRestaurantInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutImagesInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutImagesInput, RestaurantUncheckedCreateWithoutImagesInput>
  }

  export type ReviewCreateWithoutImagesInput = {
    id?: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutReviewsInput
    restaurant: RestaurantCreateNestedOneWithoutReviewsInput
    replys?: ReplyCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutImagesInput = {
    id?: bigint | number
    memberId: bigint | number
    restaurantId: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    replys?: ReplyUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutImagesInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutImagesInput, ReviewUncheckedCreateWithoutImagesInput>
  }

  export type InquiryCreateWithoutImagesInput = {
    id?: bigint | number
    title: string
    content: string
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateWithoutImagesInput = {
    id?: bigint | number
    memberId: bigint | number
    title: string
    content: string
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type InquiryCreateOrConnectWithoutImagesInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutImagesInput, InquiryUncheckedCreateWithoutImagesInput>
  }

  export type RestaurantUpsertWithoutImagesInput = {
    update: XOR<RestaurantUpdateWithoutImagesInput, RestaurantUncheckedUpdateWithoutImagesInput>
    create: XOR<RestaurantCreateWithoutImagesInput, RestaurantUncheckedCreateWithoutImagesInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutImagesInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutImagesInput, RestaurantUncheckedUpdateWithoutImagesInput>
  }

  export type RestaurantUpdateWithoutImagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    ceo?: MemberUpdateOneRequiredWithoutRestaurantsNestedInput
    region?: RegionUpdateOneRequiredWithoutRestaurantNestedInput
    missions?: MissionUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutImagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ceoId?: BigIntFieldUpdateOperationsInput | bigint | number
    regionId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    missions?: MissionUncheckedUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type ReviewUpsertWithoutImagesInput = {
    update: XOR<ReviewUpdateWithoutImagesInput, ReviewUncheckedUpdateWithoutImagesInput>
    create: XOR<ReviewCreateWithoutImagesInput, ReviewUncheckedCreateWithoutImagesInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutImagesInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutImagesInput, ReviewUncheckedUpdateWithoutImagesInput>
  }

  export type ReviewUpdateWithoutImagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutReviewsNestedInput
    restaurant?: RestaurantUpdateOneRequiredWithoutReviewsNestedInput
    replys?: ReplyUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutImagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    replys?: ReplyUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type InquiryUpsertWithoutImagesInput = {
    update: XOR<InquiryUpdateWithoutImagesInput, InquiryUncheckedUpdateWithoutImagesInput>
    create: XOR<InquiryCreateWithoutImagesInput, InquiryUncheckedCreateWithoutImagesInput>
    where?: InquiryWhereInput
  }

  export type InquiryUpdateToOneWithWhereWithoutImagesInput = {
    where?: InquiryWhereInput
    data: XOR<InquiryUpdateWithoutImagesInput, InquiryUncheckedUpdateWithoutImagesInput>
  }

  export type InquiryUpdateWithoutImagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateWithoutImagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberCreateWithoutAlarmsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionCreateNestedManyWithoutMemberInput
    reviews?: ReviewCreateNestedManyWithoutMemberInput
    reply?: ReplyCreateNestedManyWithoutMemberInput
    inquiries?: InquiryCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutAlarmsInput = {
    id?: bigint | number
    name: string
    email: string
    location: string
    phoneNumber: string
    nickname: string
    gender: number
    birth: Date | string
    points?: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    inactiveAt?: Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedCreateNestedManyWithoutMemberInput
    restaurants?: RestaurantUncheckedCreateNestedManyWithoutCeoInput
    memberMissions?: MemberMissionUncheckedCreateNestedManyWithoutMemberInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutMemberInput
    reply?: ReplyUncheckedCreateNestedManyWithoutMemberInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutAlarmsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutAlarmsInput, MemberUncheckedCreateWithoutAlarmsInput>
  }

  export type AlarmNewMissionCreateWithoutAlarmInput = {
    id?: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmNewMissionUncheckedCreateWithoutAlarmInput = {
    id?: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmNewMissionCreateOrConnectWithoutAlarmInput = {
    where: AlarmNewMissionWhereUniqueInput
    create: XOR<AlarmNewMissionCreateWithoutAlarmInput, AlarmNewMissionUncheckedCreateWithoutAlarmInput>
  }

  export type AlarmNewMissionCreateManyAlarmInputEnvelope = {
    data: AlarmNewMissionCreateManyAlarmInput | AlarmNewMissionCreateManyAlarmInput[]
    skipDuplicates?: boolean
  }

  export type AlarmReviewRequestCreateWithoutAlarmInput = {
    id?: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmReviewRequestUncheckedCreateWithoutAlarmInput = {
    id?: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmReviewRequestCreateOrConnectWithoutAlarmInput = {
    where: AlarmReviewRequestWhereUniqueInput
    create: XOR<AlarmReviewRequestCreateWithoutAlarmInput, AlarmReviewRequestUncheckedCreateWithoutAlarmInput>
  }

  export type AlarmReviewRequestCreateManyAlarmInputEnvelope = {
    data: AlarmReviewRequestCreateManyAlarmInput | AlarmReviewRequestCreateManyAlarmInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithoutAlarmsInput = {
    update: XOR<MemberUpdateWithoutAlarmsInput, MemberUncheckedUpdateWithoutAlarmsInput>
    create: XOR<MemberCreateWithoutAlarmsInput, MemberUncheckedCreateWithoutAlarmsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutAlarmsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutAlarmsInput, MemberUncheckedUpdateWithoutAlarmsInput>
  }

  export type MemberUpdateWithoutAlarmsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUpdateManyWithoutMemberNestedInput
    reply?: ReplyUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutAlarmsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    gender?: IntFieldUpdateOperationsInput | number
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    inactiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberfavoriteFoodKinds?: MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberNestedInput
    restaurants?: RestaurantUncheckedUpdateManyWithoutCeoNestedInput
    memberMissions?: MemberMissionUncheckedUpdateManyWithoutMemberNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutMemberNestedInput
    reply?: ReplyUncheckedUpdateManyWithoutMemberNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type AlarmNewMissionUpsertWithWhereUniqueWithoutAlarmInput = {
    where: AlarmNewMissionWhereUniqueInput
    update: XOR<AlarmNewMissionUpdateWithoutAlarmInput, AlarmNewMissionUncheckedUpdateWithoutAlarmInput>
    create: XOR<AlarmNewMissionCreateWithoutAlarmInput, AlarmNewMissionUncheckedCreateWithoutAlarmInput>
  }

  export type AlarmNewMissionUpdateWithWhereUniqueWithoutAlarmInput = {
    where: AlarmNewMissionWhereUniqueInput
    data: XOR<AlarmNewMissionUpdateWithoutAlarmInput, AlarmNewMissionUncheckedUpdateWithoutAlarmInput>
  }

  export type AlarmNewMissionUpdateManyWithWhereWithoutAlarmInput = {
    where: AlarmNewMissionScalarWhereInput
    data: XOR<AlarmNewMissionUpdateManyMutationInput, AlarmNewMissionUncheckedUpdateManyWithoutAlarmInput>
  }

  export type AlarmNewMissionScalarWhereInput = {
    AND?: AlarmNewMissionScalarWhereInput | AlarmNewMissionScalarWhereInput[]
    OR?: AlarmNewMissionScalarWhereInput[]
    NOT?: AlarmNewMissionScalarWhereInput | AlarmNewMissionScalarWhereInput[]
    id?: BigIntFilter<"AlarmNewMission"> | bigint | number
    alarmId?: BigIntFilter<"AlarmNewMission"> | bigint | number
    title?: StringFilter<"AlarmNewMission"> | string
    body?: StringFilter<"AlarmNewMission"> | string
    createdAt?: DateTimeFilter<"AlarmNewMission"> | Date | string
    updatedAt?: DateTimeFilter<"AlarmNewMission"> | Date | string
    status?: IntFilter<"AlarmNewMission"> | number
  }

  export type AlarmReviewRequestUpsertWithWhereUniqueWithoutAlarmInput = {
    where: AlarmReviewRequestWhereUniqueInput
    update: XOR<AlarmReviewRequestUpdateWithoutAlarmInput, AlarmReviewRequestUncheckedUpdateWithoutAlarmInput>
    create: XOR<AlarmReviewRequestCreateWithoutAlarmInput, AlarmReviewRequestUncheckedCreateWithoutAlarmInput>
  }

  export type AlarmReviewRequestUpdateWithWhereUniqueWithoutAlarmInput = {
    where: AlarmReviewRequestWhereUniqueInput
    data: XOR<AlarmReviewRequestUpdateWithoutAlarmInput, AlarmReviewRequestUncheckedUpdateWithoutAlarmInput>
  }

  export type AlarmReviewRequestUpdateManyWithWhereWithoutAlarmInput = {
    where: AlarmReviewRequestScalarWhereInput
    data: XOR<AlarmReviewRequestUpdateManyMutationInput, AlarmReviewRequestUncheckedUpdateManyWithoutAlarmInput>
  }

  export type AlarmReviewRequestScalarWhereInput = {
    AND?: AlarmReviewRequestScalarWhereInput | AlarmReviewRequestScalarWhereInput[]
    OR?: AlarmReviewRequestScalarWhereInput[]
    NOT?: AlarmReviewRequestScalarWhereInput | AlarmReviewRequestScalarWhereInput[]
    id?: BigIntFilter<"AlarmReviewRequest"> | bigint | number
    alarmId?: BigIntFilter<"AlarmReviewRequest"> | bigint | number
    title?: StringFilter<"AlarmReviewRequest"> | string
    body?: StringFilter<"AlarmReviewRequest"> | string
    createdAt?: DateTimeFilter<"AlarmReviewRequest"> | Date | string
    updatedAt?: DateTimeFilter<"AlarmReviewRequest"> | Date | string
    status?: IntFilter<"AlarmReviewRequest"> | number
  }

  export type AlarmCreateWithoutAlarmsNewMissionsInput = {
    id?: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutAlarmsInput
    alarmReviewRequest?: AlarmReviewRequestCreateNestedManyWithoutAlarmInput
  }

  export type AlarmUncheckedCreateWithoutAlarmsNewMissionsInput = {
    id?: bigint | number
    memberId: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    alarmReviewRequest?: AlarmReviewRequestUncheckedCreateNestedManyWithoutAlarmInput
  }

  export type AlarmCreateOrConnectWithoutAlarmsNewMissionsInput = {
    where: AlarmWhereUniqueInput
    create: XOR<AlarmCreateWithoutAlarmsNewMissionsInput, AlarmUncheckedCreateWithoutAlarmsNewMissionsInput>
  }

  export type AlarmUpsertWithoutAlarmsNewMissionsInput = {
    update: XOR<AlarmUpdateWithoutAlarmsNewMissionsInput, AlarmUncheckedUpdateWithoutAlarmsNewMissionsInput>
    create: XOR<AlarmCreateWithoutAlarmsNewMissionsInput, AlarmUncheckedCreateWithoutAlarmsNewMissionsInput>
    where?: AlarmWhereInput
  }

  export type AlarmUpdateToOneWithWhereWithoutAlarmsNewMissionsInput = {
    where?: AlarmWhereInput
    data: XOR<AlarmUpdateWithoutAlarmsNewMissionsInput, AlarmUncheckedUpdateWithoutAlarmsNewMissionsInput>
  }

  export type AlarmUpdateWithoutAlarmsNewMissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutAlarmsNestedInput
    alarmReviewRequest?: AlarmReviewRequestUpdateManyWithoutAlarmNestedInput
  }

  export type AlarmUncheckedUpdateWithoutAlarmsNewMissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    alarmReviewRequest?: AlarmReviewRequestUncheckedUpdateManyWithoutAlarmNestedInput
  }

  export type AlarmCreateWithoutAlarmReviewRequestInput = {
    id?: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    member: MemberCreateNestedOneWithoutAlarmsInput
    alarmsNewMissions?: AlarmNewMissionCreateNestedManyWithoutAlarmInput
  }

  export type AlarmUncheckedCreateWithoutAlarmReviewRequestInput = {
    id?: bigint | number
    memberId: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
    alarmsNewMissions?: AlarmNewMissionUncheckedCreateNestedManyWithoutAlarmInput
  }

  export type AlarmCreateOrConnectWithoutAlarmReviewRequestInput = {
    where: AlarmWhereUniqueInput
    create: XOR<AlarmCreateWithoutAlarmReviewRequestInput, AlarmUncheckedCreateWithoutAlarmReviewRequestInput>
  }

  export type AlarmUpsertWithoutAlarmReviewRequestInput = {
    update: XOR<AlarmUpdateWithoutAlarmReviewRequestInput, AlarmUncheckedUpdateWithoutAlarmReviewRequestInput>
    create: XOR<AlarmCreateWithoutAlarmReviewRequestInput, AlarmUncheckedCreateWithoutAlarmReviewRequestInput>
    where?: AlarmWhereInput
  }

  export type AlarmUpdateToOneWithWhereWithoutAlarmReviewRequestInput = {
    where?: AlarmWhereInput
    data: XOR<AlarmUpdateWithoutAlarmReviewRequestInput, AlarmUncheckedUpdateWithoutAlarmReviewRequestInput>
  }

  export type AlarmUpdateWithoutAlarmReviewRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutAlarmsNestedInput
    alarmsNewMissions?: AlarmNewMissionUpdateManyWithoutAlarmNestedInput
  }

  export type AlarmUncheckedUpdateWithoutAlarmReviewRequestInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    alarmsNewMissions?: AlarmNewMissionUncheckedUpdateManyWithoutAlarmNestedInput
  }

  export type MemberFavoriteFoodKindCreateManyMemberInput = {
    id?: bigint | number
    foodKindId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type RestaurantCreateManyCeoInput = {
    id?: bigint | number
    regionId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberMissionCreateManyMemberInput = {
    id?: bigint | number
    missionId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ReviewCreateManyMemberInput = {
    id?: bigint | number
    restaurantId: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ReplyCreateManyMemberInput = {
    id?: bigint | number
    reviewId: bigint | number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type InquiryCreateManyMemberInput = {
    id?: bigint | number
    title: string
    content: string
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmCreateManyMemberInput = {
    id?: bigint | number
    isConfirmed?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberFavoriteFoodKindUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    foodKind?: FoodKindUpdateOneRequiredWithoutMemberfavoriteFoodKindsNestedInput
  }

  export type MemberFavoriteFoodKindUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    foodKindId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberFavoriteFoodKindUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    foodKindId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantUpdateWithoutCeoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    region?: RegionUpdateOneRequiredWithoutRestaurantNestedInput
    missions?: MissionUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUpdateManyWithoutRestaurantNestedInput
    images?: ImageUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutCeoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    regionId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    missions?: MissionUncheckedUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRestaurantNestedInput
    images?: ImageUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateManyWithoutCeoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    regionId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberMissionUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    mission?: MissionUpdateOneRequiredWithoutMemberMissionNestedInput
  }

  export type MemberMissionUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    missionId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberMissionUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    missionId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutReviewsNestedInput
    replys?: ReplyUpdateManyWithoutReviewNestedInput
    images?: ImageUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    replys?: ReplyUncheckedUpdateManyWithoutReviewNestedInput
    images?: ImageUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReplyUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    review?: ReviewUpdateOneRequiredWithoutReplysNestedInput
  }

  export type ReplyUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReplyUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type InquiryUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    images?: ImageUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    images?: ImageUncheckedUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    alarmsNewMissions?: AlarmNewMissionUpdateManyWithoutAlarmNestedInput
    alarmReviewRequest?: AlarmReviewRequestUpdateManyWithoutAlarmNestedInput
  }

  export type AlarmUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    alarmsNewMissions?: AlarmNewMissionUncheckedUpdateManyWithoutAlarmNestedInput
    alarmReviewRequest?: AlarmReviewRequestUncheckedUpdateManyWithoutAlarmNestedInput
  }

  export type AlarmUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    isConfirmed?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberFavoriteFoodKindCreateManyFoodKindInput = {
    id?: bigint | number
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type FoodKindRestaurantCreateManyFoodKindInput = {
    id?: bigint | number
    restaurantId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberFavoriteFoodKindUpdateWithoutFoodKindInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutMemberfavoriteFoodKindsNestedInput
  }

  export type MemberFavoriteFoodKindUncheckedUpdateWithoutFoodKindInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberFavoriteFoodKindUncheckedUpdateManyWithoutFoodKindInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type FoodKindRestaurantUpdateWithoutFoodKindInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutFoodKindRestaurantsNestedInput
  }

  export type FoodKindRestaurantUncheckedUpdateWithoutFoodKindInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type FoodKindRestaurantUncheckedUpdateManyWithoutFoodKindInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantCreateManyRegionInput = {
    id?: bigint | number
    ceoId: bigint | number
    name: string
    introduction: string
    startTime: string
    endTime: string
    totalRating?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type RestaurantUpdateWithoutRegionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    ceo?: MemberUpdateOneRequiredWithoutRestaurantsNestedInput
    missions?: MissionUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUpdateManyWithoutRestaurantNestedInput
    images?: ImageUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutRegionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ceoId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    missions?: MissionUncheckedUpdateManyWithoutRestaurantNestedInput
    foodKindRestaurants?: FoodKindRestaurantUncheckedUpdateManyWithoutRestaurantNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRestaurantNestedInput
    images?: ImageUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateManyWithoutRegionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ceoId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    totalRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MissionCreateManyRestaurantInput = {
    id?: bigint | number
    name: string
    introduction: string
    deadline: Date | string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type FoodKindRestaurantCreateManyRestaurantInput = {
    id?: bigint | number
    foodKindId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ReviewCreateManyRestaurantInput = {
    id?: bigint | number
    memberId: bigint | number
    rating?: Decimal | DecimalJsLike | number | string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ImageCreateManyRestaurantInput = {
    id?: bigint | number
    reviewId?: bigint | number | null
    inquiryId?: bigint | number | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MissionUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    memberMission?: MemberMissionUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    memberMission?: MemberMissionUncheckedUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateManyWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    introduction?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type FoodKindRestaurantUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    foodKind?: FoodKindUpdateOneRequiredWithoutFoodKindRestaurantsNestedInput
  }

  export type FoodKindRestaurantUncheckedUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    foodKindId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type FoodKindRestaurantUncheckedUpdateManyWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    foodKindId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutReviewsNestedInput
    replys?: ReplyUpdateManyWithoutReviewNestedInput
    images?: ImageUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    replys?: ReplyUncheckedUpdateManyWithoutReviewNestedInput
    images?: ImageUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ImageUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    review?: ReviewUpdateOneWithoutImagesNestedInput
    inquiry?: InquiryUpdateOneWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    inquiryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ImageUncheckedUpdateManyWithoutRestaurantInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    inquiryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberMissionCreateManyMissionInput = {
    id?: bigint | number
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type MemberMissionUpdateWithoutMissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutMemberMissionsNestedInput
  }

  export type MemberMissionUncheckedUpdateWithoutMissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type MemberMissionUncheckedUpdateManyWithoutMissionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReplyCreateManyReviewInput = {
    id?: bigint | number
    memberId: bigint | number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ImageCreateManyReviewInput = {
    id?: bigint | number
    restaurantId?: bigint | number | null
    inquiryId?: bigint | number | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ReplyUpdateWithoutReviewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    member?: MemberUpdateOneRequiredWithoutReplyNestedInput
  }

  export type ReplyUncheckedUpdateWithoutReviewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ReplyUncheckedUpdateManyWithoutReviewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ImageUpdateWithoutReviewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneWithoutImagesNestedInput
    inquiry?: InquiryUpdateOneWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutReviewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    inquiryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ImageUncheckedUpdateManyWithoutReviewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    inquiryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ImageCreateManyInquiryInput = {
    id?: bigint | number
    restaurantId?: bigint | number | null
    reviewId?: bigint | number | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type ImageUpdateWithoutInquiryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneWithoutImagesNestedInput
    review?: ReviewUpdateOneWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutInquiryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reviewId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ImageUncheckedUpdateManyWithoutInquiryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    restaurantId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reviewId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmNewMissionCreateManyAlarmInput = {
    id?: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmReviewRequestCreateManyAlarmInput = {
    id?: bigint | number
    title: string
    body: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: number
  }

  export type AlarmNewMissionUpdateWithoutAlarmInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmNewMissionUncheckedUpdateWithoutAlarmInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmNewMissionUncheckedUpdateManyWithoutAlarmInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmReviewRequestUpdateWithoutAlarmInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmReviewRequestUncheckedUpdateWithoutAlarmInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type AlarmReviewRequestUncheckedUpdateManyWithoutAlarmInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MemberCountOutputTypeDefaultArgs instead
     */
    export type MemberCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodKindCountOutputTypeDefaultArgs instead
     */
    export type FoodKindCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodKindCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionCountOutputTypeDefaultArgs instead
     */
    export type RegionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestaurantCountOutputTypeDefaultArgs instead
     */
    export type RestaurantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestaurantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionCountOutputTypeDefaultArgs instead
     */
    export type MissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewCountOutputTypeDefaultArgs instead
     */
    export type ReviewCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InquiryCountOutputTypeDefaultArgs instead
     */
    export type InquiryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InquiryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlarmCountOutputTypeDefaultArgs instead
     */
    export type AlarmCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlarmCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberDefaultArgs instead
     */
    export type MemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodKindDefaultArgs instead
     */
    export type FoodKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodKindDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberFavoriteFoodKindDefaultArgs instead
     */
    export type MemberFavoriteFoodKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberFavoriteFoodKindDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionDefaultArgs instead
     */
    export type RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RestaurantDefaultArgs instead
     */
    export type RestaurantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RestaurantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionDefaultArgs instead
     */
    export type MissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberMissionDefaultArgs instead
     */
    export type MemberMissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberMissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodKindRestaurantDefaultArgs instead
     */
    export type FoodKindRestaurantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodKindRestaurantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReplyDefaultArgs instead
     */
    export type ReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InquiryDefaultArgs instead
     */
    export type InquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InquiryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImageDefaultArgs instead
     */
    export type ImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlarmDefaultArgs instead
     */
    export type AlarmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlarmDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlarmNewMissionDefaultArgs instead
     */
    export type AlarmNewMissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlarmNewMissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlarmReviewRequestDefaultArgs instead
     */
    export type AlarmReviewRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlarmReviewRequestDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}